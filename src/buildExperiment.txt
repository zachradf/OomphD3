const OomphChart = function (d3, myExport) {
  'use strict';

  class ChartTypes {
    constructor() {
      const types = {
        adjacency: {
          _selfKey: 'adjacency',
          name: 'Adjacency',
          nameLong: 'Adjacency Matrix'
        },
        area: {
          _selfKey: 'area',
          name: 'Area',
          nameLong: 'Area Chart'
        },
        bar: {
          _selfKey: 'bar',
          name: 'Bar',
          nameLong: 'Bar Chart'
        },
        box: {
          _selfKey: 'box',
          name: 'Box',
          nameLong: 'Box Plot'
        },
        bubble: {
          _selfKey: 'bubble',
          name: 'Bubble',
          nameLong: 'Bubble Chart'
        },
        chord: {
          _selfKey: 'chord',
          name: 'Chord',
          nameLong: 'Chord Diagram'
        },
        cloud: {
          _selfKey: 'cloud',
          name: 'Cloud',
          nameLong: 'Cloud Diagram'
        },
        cluster: {
          _selfKey: 'cluster',
          name: 'Cluster',
          nameLong: 'Cluster Diagram'
        },
        dendrogram: {
          _selfKey: 'dendrogram',
          name: 'Dendrogram',
          nameLong: 'Dendrogram Chart'
        },
        donut: {
          _selfKey: 'donut',
          name: 'Donut',
          nameLong: 'Donut Chart'
        },
        funnel: {
          _selfKey: 'funnel',
          name: 'Funnel',
          nameLong: 'Funnel Chart'
        },
        gauge: {
          _selfKey: 'gauge',
          name: 'Gauge',
          nameLong: 'Gauge Chart'
        },
        heat: {
          _selfKey: 'heat',
          name: 'Heat',
          nameLong: 'Heat Map'
        },
        icicle: {
          _selfKey: 'icicle',
          name: 'Icicle',
          nameLong: 'Icicle Plot'
        },
        line: {
          _selfKey: 'line',
          name: 'Line',
          nameLong: 'Line Graph'
        },
        marimekko: {
          _selfKey: 'marimekko',
          name: 'Marimekko',
          nameLong: 'Marimekko Diagram'
        },
        pie: {
          _selfKey: 'pie',
          name: 'Pie',
          nameLong: 'Pie Chart'
        },
        polar: {
          _selfKey: 'polar',
          name: 'Polar',
          nameLong: 'Polar Chart'
        },
        radar: {
          _selfKey: 'radar',
          name: 'Radar',
          nameLong: 'Radar Chart'
        },
        radialTree: {
          _selfKey: 'radialTree',
          name: 'Radial Tree',
          nameLong: 'Radial Tree Diagram'
        },
        sankey: {
          _selfKey: 'sankey',
          name: 'Sankey',
          nameLong: 'Sankey Diagram'
        },
        scatter: {
          _selfKey: 'scatter',
          name: 'Scatter',
          nameLong: 'Scatter Plot'
        },
        stackedBar: {
          _selfKey: 'stackedBar',
          name: 'Stacked Bar',
          nameLong: 'Stacked Bar Chart'
        },
        sun: {
          _selfKey: 'sun',
          name: 'Sun Burst',
          nameLong: 'Sun Burst Diagram'
        },
        treeDiagram: {
          _selfKey: 'treeDiagram',
          name: 'Tree Diagram',
          nameLong: 'Tree Diagram'
        },
        treeMap: {
          _selfKey: 'treeMap',
          name: 'Tree Map',
          nameLong: 'Tree Map'
        },
        voronoi: {
          _selfKey: 'voronoi',
          name: 'Voronoi',
          nameLong: 'Voronoi Diagram'
        },
        waterfall: {
          _selfKey: 'waterfall',
          name: 'Waterfall',
          nameLong: 'Waterfall Chart'
        },
      };
      Object.assign(this, types);
    }
  }
  class D3OptionTypes {
    constructor() {
      const types = {
        funnelChart: {
          _selfKey: 'funnelChart',
          barWidth: 10,
          colors: ['steelblue', 'grey'],
          height: 400,
          margin: {
            bottom: 30,
            left: 100,
            right: 20,
            top: 20,
          },
          nodePadding: 1,
          nodeWidth: 10,
          onHover: false,
          overlay: false,
          padding: 2,
          radius: 10,
          strokeColor: '#000000',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLine: true,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLine: true,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
        },
        gauge: {
          _selfKey: 'gauge',
          height: 300,
          interval: 2e3,
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          minorTickColor: 'black',
          minorTicks: 4,
          overlay: false,
          pointerColor: 'red',
          pointerWidth: 10,
          startAngle: -Math.PI / 1.25,
          endAngle: Math.PI / 1.25,
          width: 300,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          barWidth: 10,
        },
        options0: {
          _selfKey: 'options0',
          barWidth: 10,
          childTextSize: 10,
          color: d3.scaleOrdinal(d3.schemeCategory10),
          diameter: 600,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          height: 800,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          maxValue: 100,
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: false,
          opacity: 0.75,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yLabel: 'yLabel',
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
        },
        options1: {
          _selfKey: 'options1',
          barWidth: -30,
          childTextSize: 10,
          color: 'red',
          colorScale: 'red',
          diameter: 600,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          gradient: true,
          gradientAxis: 'x',
          gradientColor: ['red', 'yellow'],
          height: 600,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: false,
          opacity: 1,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: true,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xLabelColor: 'red',
          xLabelFontSize: 10,
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'normal',
          xLabelOffsetX: 10,
          xLabelOffsetY: 10,
          xLabelRotation: 0,
          xLine: true,
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 0.21,
          xAxisColor: 'red',
          xAxisPosition: -1,
          yLabel: 'yLabel',
          yLabelColor: 'blue',
          yLabelFontSize: 10,
          yLabelFontFamily: 'sans-serif',
          yLabelFontWeight: 'normal',
          yLabelOffsetX: 10,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.1,
          yAxisColor: 'blue',
          yAxisPosition: 880,
        },
        options2: {
          _selfKey: 'options2',
          barWidth: 10,
          childTextSize: 5,
          color: 'red',
          diameter: 400,
          fillColor: ['red', 'blue', 'green', 'yellow', 'orange', 'purple'],
          fontColor: 'blue',
          height: 600,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          opacity: 0.61,
          overlay: true,
          parentTextSize: 10,
          radius: 10.5,
          showCategories: true,
          sortBy: 'y asc',
          stack: false,
          textAnchor: 'middle',
          width: 800,
          xLine: false,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: 10,
          xLabelRotation: 90,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabel: 'yLabel',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: false,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
        },
        options3: {
          _selfKey: 'options3',
          childTextSize: 10,
          color: 'red',
          colorScale: 'red',
          diameter: 600,
          duration: 500,
          endAngle: Math.PI / 1.25,
          fillColor: 'red',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          gradient: false,
          gradientAxis: 'x',
          gradientColor: ['red', 'yellow'],
          height: 600,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: true,
          opacity: 0.75,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          relativeNode: true,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xAxisPosition: -1,
          xLabel: 'xLabel',
          xLine: true,
          yAxisPosition: 880,
          barWidth: -30,
          yLabel: 'yLabel',
          yLine: false,
          xTickFrequency: 30,
          yTickFrequency: 30,
          xTickLength: 600,
          yTickLength: 900,
          xTickExtension: -580,
          yTickExtension: 880,
          xTickOpacity: 1,
          yTickOpacity: 1,
          xAxisColor: 'red',
          yAxisColor: 'blue',
          yLabelOffsetX: 0,
          yLabelOffsetY: 0,
          xLabelOffsetX: 0,
          xLabelOffsetY: 0,
          xLabelColor: 'red',
          yLabelColor: 'blue',
          xLabelFontSize: 10,
          yLabelFontSize: 10,
          xLabelFontWeight: 'normal',
          yLabelFontWeight: 'normal',
          xLabelFontFamily: 'sans-serif',
          yLabelFontFamily: 'sans-serif',
          xLabelRotation: 0,
          yLabelRotation: 0,
        },
        options4: {
          _selfKey: 'options4',
          barWidth: 10,
          childTextSize: 10,
          color: 'green',
          colorScale: 'red',
          diameter: 600,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          height: 800,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: false,
          opacity: 0.75,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          yLabel: 'yLabel',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
        },
        options5: {
          _selfKey: 'options5',
          animate: true,
          barWidth: 10,
          childTextSize: 10,
          color: 'green',
          colorScale: 'red',
          colorScheme: ['red', 'blue', 'green', 'yellow', 'orange', 'purple'],
          diameter: 400,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          gradient: false,
          gradientAxis: 'y',
          gradientColor: ['red', 'yellow'],
          height: 600,
          hoverColor: 'blue',
          innerRadius: 80,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          menu: 'rectangular',
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: true,
          opacity: 1,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          strokeWidth: 10,
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xLine: false,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yLine: false,
          yLabel: 'yLabel',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yTickExtension: 10,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
        },
        options6: {
          _selfKey: 'options6',
          barWidth: 10,
          childTextSize: 10,
          color: 'green',
          colorScale: 'red',
          diameter: 400,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          height: 600,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: true,
          opacity: 0.75,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 250,
          relativeNodeSize: false,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yLabel: 'yLabel',
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
        },
        options7: {
          _selfKey: 'options7',
          barWidth: 10,
          color: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
          // color scheme for the bars
          colorScale: 'red',
          diameter: 6,
          fillColor: 'red',
          height: 800,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          onHover: false,
          opacity: 0.75,
          overlay: false,
          radius: 200,
          showLabels: true,
          stack: false,
          strokeColor: 'blue',
          width: 900,
          xLabel: 'xLabel',
          xFontColor: 'red',
          xFontFamily: 'gothic',
          xFontOpacity: 1,
          xFontSize: 10,
          xFontStyle: 'italic',
          xFontWeight: 'bold',
          xLabelFontColor: 'blue',
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'bold',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xLine: true,
          xAxisColor: 'red',
          xAxisOpacity: 1,
          xAxisPosition: -1,
          xTextAnchor: 'start',
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          yFontColor: 'blue',
          yFontFamily: 'sans-serif',
          yFontOpacity: 1,
          yFontSize: 10,
          yFontStyle: 'italic',
          yFontWeight: 'bold',
          yLabel: 'yLabel',
          yLabelFontColor: 'red',
          yLabelFontFamily: 'gothic',
          yLabelFontWeight: 'bold',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yAxisColor: 'purple',
          yAxisOpacity: 1,
          yAxisPosition: 880,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 1,
        },
        options8: {
          _selfKey: 'options8',
          animate: true,
          barWidth: 10,
          boxShadow: true,
          color: 'green',
          diameter: 100,
          fillColor: ['red', 'blue', 'green', 'yellow', 'orange', 'purple'],
          height: 900,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          onHover: false,
          opacity: 1,
          overlay: true,
          radius: 50.5,
          showCategories: true,
          stack: false,
          textAnchor: 'middle',
          textColor: 'white',
          width: 1600,
          xLabel: 'xLabel',
          xFontColor: 'red',
          xFontFamily: 'gothic',
          xFontOpacity: 1,
          xFontSize: 10,
          xFontStyle: 'italic',
          xFontWeight: 'bold',
          xLabelFontColor: 'blue',
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'bold',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xLine: true,
          xAxisColor: 'red',
          xAxisOpacity: 1,
          xAxisPosition: -1,
          xTextAnchor: 'start',
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          yFontColor: 'blue',
          yFontFamily: 'sans-serif',
          yFontOpacity: 1,
          yFontSize: 10,
          yFontStyle: 'italic',
          yFontWeight: 'bold',
          yLabel: 'yLabel',
          yLabelFontColor: 'red',
          yLabelFontFamily: 'gothic',
          yLabelFontWeight: 'bold',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yAxisColor: 'purple',
          yAxisOpacity: 1,
          yAxisPosition: 420,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 1,
        },
        options9: {
          _selfKey: 'options9',
          barWidth: 10,
          color: d3.scaleOrdinal(d3.schemeCategory10),
          diameter: 100,
          fillColor: ['red', 'blue', 'green', 'yellow', 'orange', 'purple'],
          height: 900,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          onHover: false,
          opacity: 1,
          overlay: true,
          radius: 50.5,
          showCategories: true,
          stack: false,
          textAnchor: 'middle',
          textColor: 'white',
          width: 1600,
          xLabel: 'xLabel',
          xFontColor: 'red',
          xFontFamily: 'gothic',
          xFontOpacity: 1,
          xFontSize: 10,
          xFontStyle: 'italic',
          xFontWeight: 'bold',
          xLabelFontColor: 'blue',
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'bold',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xLine: true,
          xAxisColor: 'red',
          xAxisOpacity: 1,
          xAxisPosition: -1,
          xTextAnchor: 'start',
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          yFontColor: 'blue',
          yFontFamily: 'sans-serif',
          yFontOpacity: 1,
          yFontSize: 10,
          yFontStyle: 'italic',
          yFontWeight: 'bold',
          yLabel: 'yLabel',
          yLabelFontColor: 'red',
          yLabelFontFamily: 'gothic',
          yLabelFontWeight: 'bold',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yAxisColor: 'purple',
          yAxisOpacity: 1,
          yAxisPosition: 880,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 1,
        },
        options10: {
          _selfKey: 'options10',
          barWidth: 10,
          bubble: true,
          bubbleOpacity: 0.7,
          chargeStrength: 0.01,
          fontSize: (d) => Math.sqrt(d.value) * 2,
          height: 2600,
          maxRadius: 100,
          menu: 'dropdown',
          width: 2800,
          xLabel: 'xLabel',
          xFontColor: 'red',
          xFontFamily: 'gothic',
          xFontOpacity: 1,
          xFontSize: 10,
          xFontStyle: 'italic',
          xFontWeight: 'bold',
          xLabelFontColor: 'blue',
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'bold',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xLine: true,
          xAxisColor: 'red',
          xAxisOpacity: 1,
          xAxisPosition: -1,
          xTextAnchor: 'start',
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          yFontColor: 'blue',
          yFontFamily: 'sans-serif',
          yFontOpacity: 1,
          yFontSize: 10,
          yFontStyle: 'italic',
          yFontWeight: 'bold',
          yLabel: 'yLabel',
          yLabelFontColor: 'red',
          yLabelFontFamily: 'gothic',
          yLabelFontWeight: 'bold',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yAxisColor: 'purple',
          yAxisOpacity: 1,
          yAxisPosition: 880,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 1,
        },
        optionsForceDirected: {
          _selfKey: 'optionsForceDirected',
          chargeStrength: -200,
          height: 600,
          linkDistance: 50,
          width: 600,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          barWidth: 10,
        },
        polarChart: {
          _selfKey: 'polarChart',
          barWidth: 10,
          colors: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'],
          height: 600,
          innerRadius: 50,
          margin: {
            bottom: 20,
            left: 20,
            right: 20,
            top: 20,
          },
          outerRadius: 250,
          overlay: false,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          width: 600,
        },
        radarChart: {
          _selfKey: 'radarChart',
          barWidth: 10,
          colors: ['#1f77b4', '#2ca02c'],
          height: 500,
          levels: 5,
          // maybe should be calculated from data
          margin: {
            bottom: 50,
            left: 50,
            right: 50,
            top: 50,
          },
          maxValue: 100,
          // maybe should be calculated from data
          overlay: false,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          width: 600,
        },
        waterfall: {
          _selfKey: 'waterfall',
          barWidth: 10,
          color: 'steelblue',
          height: 400,
          margin: {
            bottom: 30,
            left: 50,
            right: 20,
            top: 20,
          },
          negativeColor: 'red',
          overlay: false,
          positiveColor: 'green',
          width: 600,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xDomain: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'],
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          yAxisColor: 'purple',
          yAxisPosition: 0,
          yDomain: [0, 100],
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
        }
      };
      Object.assign(this, types);
    }
  }
  function appendAxes(chart, options, chartComponents) {
    const { width } = options;
    const { height } = options;
    const { margin } = options;
    const { svg } = chartComponents;
    const { xAxis } = chartComponents;
    const { yAxis } = chartComponents;
    let xAxisBBox;
    let yAxisBBox;
    if (chart === 'polar' || chart === 'radar' || chart === 'pie' || chart === 'donut' || chart === 'heatmap' || chart === 'bubble') {return { xAxisBBox, yAxisBBox };}
    if (!options.isUpdating) {
      const xAxisG = svg.append('g').classed('x-axis', true).attr('transform', chart === 'stackedbar' ? `translate(0,${height - margin.bottom})` : '').call(xAxis);
      xAxisBBox = xAxisG.node().getBBox();
      xAxisG.selectAll('text').style('font-size', `${options.xTickFontSize}px`).style('fill', `${options.xFontColor}`).style('font-family', `${options.xFontFamily}`)
.style('font-weight', `${options.xFontWeight}`)
.style('opacity', `${options.xFontOpacity}`);
      xAxisG.append('text').classed('x-axis-label', true).attr('x', width - margin.right + options.xLabelOffsetX).attr('y', margin.bottom - 10 + options.xLabelOffsetY)
.attr('text-anchor', 'middle')
.attr('transform', `rotate(${options.xLabelRotation}, ${width - margin.right + options.xLabelOffsetX}, ${margin.bottom - 10 + options.xLabelOffsetY})`)
.text(options.xLabel)
.style('font-size', `${options.xLabelFontSize}px`)
.style('fill', `${options.xLabelFontColor}`)
.style('font-family', `${options.xLabelFontFamily}`)
.style('font-weight', `${options.xLabelFontWeight}`)
.style('opacity', `${options.xLabelFontOpacity}`);
      const yAxisG = svg.append('g').classed('y-axis', true).attr('transform', chart === 'stackedbar' ? `translate(${margin.left},0)` : '').call(yAxis);
      yAxisBBox = yAxisG.node().getBBox();
      yAxisG.selectAll('text').style('font-size', `${options.yTickFontSize}px`).style('fill', `${options.yFontColor}`).style('font-family', `${options.yFontFamily}`)
.style('font-weight', `${options.yFontWeight}`)
.style('opacity', `${options.yFontOpacity}`);
      yAxisG.append('text').classed('y-axis-label', true).attr('x', -margin.top + options.yLabelOffsetX).attr('y', margin.left - 10 + options.yLabelOffsetY)
.attr('text-anchor', 'end')
.attr('transform', `rotate(${options.yLabelRotation}, ${-margin.top + options.yLabelOffsetX}, ${margin.left - 10 + options.yLabelOffsetY})`)
.text(options.yLabel)
.style('font-size', `${options.yLabelFontSize}px`)
.style('fill', `${options.yLabelFontColor}`)
.style('font-family', `${options.yLabelFontFamily}`)
.style('font-weight', `${options.yLabelFontWeight}`)
.style('opacity', `${options.yLabelFontOpacity}`);
    }
    if (!options.yLine) {
      svg.select('.y-axis path').remove();
    }
    if (!options.xLine) {
      svg.select('.x-axis path').remove();
    }
    return { xAxisBBox, yAxisBBox };
  }
  function createYAxisLine(g, options, xAxisPosition) {
    if (!options.yLine || options.isUpdating) {return;}
    g.append('line').attr('stroke', options.yAxisColor).attr('stroke-opacity', options.yAxisOpacity).attr('stroke-width', `${options.yAxisWidth}`)
.attr('x1', 0)
.attr('x2', 0)
.attr('y1', options.margin.top - xAxisPosition)
.attr('y2', options.height - options.margin.bottom - xAxisPosition + options.height - options.margin.top - options.margin.bottom);
    g.select('.domain').remove();
  }
  function createXAxisLine(g, options) {
    if (!options.xLine || options.isUpdating) {return;}
    g.append('line').attr('stroke', options.xAxisColor).attr('stroke-opacity', options.xAxisOpacity).attr('stroke-width', `${options.xAxisWidth}`)
.attr('x1', options.margin.left)
.attr('x2', options.width - options.margin.right)
.attr('y1', 0)
.attr('y2', 0);
    g.select('.domain').remove();
  }
  function createAxes(data, chart, options) {
    const {
      margin,
      width,
      height,
      yDomain,
    } = options;
    const chartFunctions = {
      bar: (data2) => createBarBox(data2, options),
      box: (data2) => createBarBox(data2, options),
      funnel: (data2) => createFunnel(data2, options),
      waterfall: (data2) => createWaterfall(data2, options),
      stackedbar: (data2) => createStackedBar(data2, options),
      default: (data2) => createDefault(data2, options),
    };
    const x2 = (chartFunctions[chart] || chartFunctions.default)(data);
    const scaleFunctions = {
      bar: () => d3.scaleLinear().domain(yDomain || [0, d3.max(data, (d) => d.y)]).nice().range([height - margin.bottom, margin.top]),
      funnel: () => d3.scaleBand().domain(yDomain || data.map((d) => d.x)).range([margin.top, height - margin.bottom]).padding(0.1),
      stackedbar: () => d3.scaleLinear().domain(yDomain || [0, d3.max(data, (d) => d3.sum(d.values.map((v) => v.value)))]).nice().range([height - margin.bottom, margin.top]),
      waterfall: () => d3.scaleLinear().domain(yDomain || [d3.min(data, (d) => d.start), d3.max(data, (d) => d.end)]).nice().range([height - margin.bottom, margin.top]),
      default: () => d3.scaleLinear().domain(yDomain || d3.extent(data, (d) => d.y)).nice().range([height - margin.bottom, margin.top]),
    };
    const xAxisColor = options.xAxisColor || '#000';
    const xAxisPosition = options.xAxisPosition || height - margin.bottom;
    const xAxisWidth = options.xAxistWidth || 2;
    const xTickExtension = options.xTickExtension || 0;
    const xTickFrequency = options.xTickFrequency || width / 80;
    const xTickLength = options.xTickLength || width - margin.left - margin.right;
    const yAxisColor = options.yAxisColor || '#000';
    const yAxisPosition = options.yAxisPosition || margin.left;
    const yAxisWidth = options.yAxistWidth || 2;
    const yTickExtension = options.yTickExtension || 0;
    const yTickFrequency = options.yTickFrequency || width / 80;
    const yTickLength = options.yTickLength || height - margin.top - margin.bottom;
    const y2 = (scaleFunctions[chart] || scaleFunctions.default)();
    let xAxisBBox;
    let yAxisBBox;
    const xAxis = (g) => {
      g.attr('transform', `translate(0,${xAxisPosition})`).call(d3.axisBottom(x2).ticks(xTickFrequency).tickSizeOuter(0).tickSize(0)).call((g2) => {
        g2.selectAll('.tick').each(function () {
          d3.select(this).append('line').attr('stroke', `${xAxisColor}`).attr('stroke-width', `${xAxisWidth}`)
.attr('y2', -xTickLength)
.attr('opacity', options.xTickOpacity || 1);
          d3.select(this).append('line').attr('stroke', `${xAxisColor}`).attr('y2', -xTickExtension)
.attr('opacity', options.xTickOpacity || 1);
        });
      });
      if (options.xLine) {createXAxisLine(g, options, yAxisPosition);}
      xAxisBBox = g.node().getBBox();
    };
    const yAxis = (g) => {
      g.attr('transform', `translate(${yAxisPosition},0)`).call(d3.axisLeft(y2).tickSize(0).ticks(chart === 'stackedbar' ? null : yTickFrequency)).call((g2) => {
        g2.selectAll('.tick').each(function () {
          d3.select(this).append('line').attr('stroke', `${yAxisColor}`).attr('x2', yTickLength)
.attr('class', 'tick-line')
.attr('opacity', options.yTickOpacity || 1);
          d3.select(this).append('line').attr('stroke', `${yAxisColor}`).attr('x2', -yTickExtension)
.attr('class', 'tick-line')
.attr('opacity', options.yTickOpacity || 1);
        });
        if (options.yLine) {
          createYAxisLine(g2, options, xAxisPosition);
        }
      });
      yAxisBBox = g.node().getBBox();
    };
    return {
      x: x2,
      y: y2,
      xAxis,
      yAxis,
      xAxisBBox,
      yAxisBBox,
    };
  }
  function createBarBox(data, options) {
    data.sort((a2, b) => d3.ascending(a2.x, b.x));
    if (typeof data[0].x === 'string') {
      return d3.scaleBand().domain(options.xDomain ? options.xDomain : data.map((d) => d.x)).range([options.margin.left, options.width - options.margin.right]).padding(0.1);
    }
    return d3.scaleLinear().domain(options.xDomain ? options.xDomain : d3.extent(data, (d) => d.x)).nice().range([options.margin.left, options.width - options.margin.right]);
  }
  function createFunnel(data, options) {
    const totalValue = data.reduce((acc, curr) => acc + curr.y, 0);
    return d3.scaleLinear().domain(options.xDomain ? options.xDomain : [0, totalValue]).range([options.margin.left, options.width - options.margin.right]);
  }
  function createWaterfall(data, options) {
    return d3.scaleBand().domain(options.xDomain ? options.xDomain : [data[0].category, ...data.map((d) => d.category), data[data.length - 1].category]).range([options.margin.left, options.width - options.margin.right]).padding(0.1);
  }
  function createStackedBar(data, options) {
    return d3.scaleBand().domain(options.xDomain ? options.xDomain : data.map((d) => d.category)).range([options.margin.left, options.width - options.margin.right]).padding(0.1);
  }
  function createDefault(data, options) {
    return d3.scaleLinear().domain(options.xDomain ? options.xDomain : d3.extent(data, (d) => d.x)).nice().range([options.margin.left, options.width - options.margin.right]);
  }
  function createSVG(selector, chart, options) {
    let svg;
    if (options.stack) {
      const container = d3.select(selector).append('div').style('position', 'relative').style('width', `${options.width}px`)
.style('height', `${options.height}px`);
      svg = container.append('svg').attr('width', options.width).attr('height', options.height);
      if (chart === 'pie' || chart === 'donut' || chart === 'gauge' || chart === 'polar' || chart === 'radar') {
        svg.classed(`${options.chartClass}`, true);
        const g = svg.append('g');
        if (chart === 'polar') {
          g.attr('transform', `translate(${options.width / 2}, ${options.height / 2})`);
        }
        svg = g;
      } else {
        const chartWrapper = d3.select('body').append('div').classed('chart-wrapper', true).style('position', 'absolute')
.style('top', '0')
.style('left', '0');
        svg = chartWrapper.append('svg').attr('width', options.width).attr('height', options.height).classed(`${options.chartClass}`, true);
      }
      return svg;
    }
    if (chart === 'pie' || chart === 'donut' || chart === 'gauge' || chart === 'polar' || chart === 'radar' || chart === 'chord' || chart === 'cluster') {
      svg = d3.select(selector).append('svg').classed(`${options.chartClass}`, true).attr('width', options.width)
.attr('height', options.height)
.append('g');
      if (chart !== 'pie') {
        svg.attr('transform', `translate(${options.width / 2}, ${options.height / 2})`);
      }
      if (chart === 'bubble') {
        svg = d3.select(selector).append('svg').classed('bubble-chart', true).attr('width', options.diameter)
.attr('height', options.diameter);
      }
    } else {
      svg = d3.select(selector).append('svg').classed(`${options.chartClass}`, true).attr('width', options.width)
.attr('height', options.height);
    }
    return svg;
  }
  function onHover(selector, options) {
    options.forEach((option, i) => {
      const elements = d3.selectAll(`circle.${option.chartClass}${i}, rect.${option.chartClass}${i}, .node.${option.chartClass}${i}, .leaf.${option.chartClass}${i}, .link.${option.chartClass}${i}, .box-rect, .arc, path.${option.chartClass}${i}, svg.pie-chart path`);
      const tooltip = d3.select('body').append('div').attr('class', 'tooltip').style('position', 'absolute')
.style('background', 'rgba(0,0,0,0.6)')
.style('color', '#fff')
.style('padding', '5px 15px')
.style('border', '1px solid black')
.style('border-radius', '5px')
.style('pointer-events', 'none')
.style('z-index', '10')
.style('display', 'none');
      elements.each(function () {
        if (option.onHover) {
          const el = d3.select(this);
          el.attr('data-initialFill', el.style('fill')).on('mouseover', () => {
            if (option.onHover) {
              console.log('hovering');
              const initialTransform = el.attr('transform') || '';
              const initialFill = el.attr('data-initialFill');
              const fillColor = d3.color(initialFill);
              tooltip.html(`Data: ${JSON.stringify(el.datum())}`).style('left', `${event.pageX + 10}px`).style('top', `${event.pageY + 10}px`).style('display', 'block');
              el.style('fill', option.hoverColor || fillColor.darker(4));
            }
          }).on('mousemove', () => {
            tooltip.style('top', `${event.pageY - 10}px`).style('left', `${event.pageX + 10}px`);
          }).on('mouseout', function () {
            const initialFill = d3.select(this).attr('data-initialFill');
            const initialTransform = el.attr('data-initialTransform') || '';
            el.style('fill', initialFill).attr('transform', initialTransform);
            d3.select(this).style('fill', initialFill);
            tooltip.style('display', 'none');
          });
        }
      });
    });
  }
  function adjustNodeSize(selector, data, options) {
    function collectNodeValues(data2) {
      if (!data2.children) {
        return data2.map((d) => d.y);
      }
      return data2.children.flatMap(collectNodeValues);
    }
    const nodeValues = collectNodeValues(data);
    const minNodeSize = options.minNodeSize || 3;
    const maxNodeSize = options.maxNodeSize || 20;
    const nodeSizeScale = d3.scaleSqrt().domain([Math.min(...nodeValues), Math.max(...nodeValues)]).range([minNodeSize, maxNodeSize]);
    const nodes = d3.select(selector).selectAll('circle');
    console.log(nodes);
    nodes.each(function () {
      const el = d3.select(this);
      console.log('relative node', el);
      el.attr('r', (d) => {
        if (nodeSizeScale(d.y) <= 0) {
          return 1;
        }
        return nodeSizeScale(d.y);
      });
    });
  }
  function addGradient(selector, type, chartElements, data, options) {
    const { gradientAxis } = options;
    let xAxisBBox;
    let yAxisBBox;
    let xScale;
    let svg;
    if (type !== 'donut' && type !== 'pie' && type !== 'polar' && type !== 'radar') {
      xAxisBBox = chartElements.xAxisBBox ? chartElements.xAxisBBox : null;
      yAxisBBox = chartElements.yAxisBBox ? chartElements.yAxisBBox : null;
      xScale = chartElements.x ? chartElements.x : null;
    }
    const color1 = options.gradientColor[0];
    const color2 = options.gradientColor[1];
    if (!options.stack) {
      svg = d3.select(selector).select('svg');
    } else {
      svg = d3.select('.chart-wrapper').select('svg');
    }
    let minValue;
    let maxValue;
    if (type === 'bar') {
      maxValue = d3.max(data, (d) => d.y);
      minValue = d3.min(data, (d) => d.y);
    } else {
      minValue = d3.min(data, (d) => d[gradientAxis]);
      maxValue = d3.max(data, (d) => d[gradientAxis]);
    }
    const valueAccessor = (d) => d[gradientAxis];
    const gradient = svg.append('linearGradient').attr('id', 'gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0)
.attr('x2', 0)
.attr('y1', 0)
.attr('y2', 1);
    gradient.append('stop').attr('offset', '0%').attr('stop-color', color1);
    gradient.append('stop').attr('offset', '100%').attr('stop-color', color2);
    if (type === 'bar') {
      if (gradientAxis === 'y') {
        gradient.attr('y1', yAxisBBox.height).attr('y2', 0);
        svg.selectAll('rect').style('fill', 'url(#gradient)');
      } else if (gradientAxis === 'x') {
        const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
        const elements = d3.selectAll(`rect.${options.chartClass}${options.chartNumber}`);
        elements.style('fill', (d) => {
          colorScale(d.y);
        });
        d3.selectAll(`rect.${options.chartClass}${options.chartNumber}`).style('fill', (d) => colorScale(d.y));
      }
    } else if (type === 'scatter') {
      const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
      svg.selectAll('circle').style('fill', (d) => colorScale(valueAccessor(d)));
    } else if (type === 'pie' || type === 'polar') {
      const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
      console.log(colorScale);
      svg.selectAll('path').attr('fill', (d) => colorScale(d.data.y));
    } else if (type === 'donut') {
      const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
      svg.selectAll('path').attr('fill', (d) => colorScale(d.data.y));
    } else if (type === 'area' || type === 'line') {
      const elements = svg.selectAll(`path.${options.chartClass}${options.chartNumber}`);
      const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
      if (gradientAxis === 'x') {
        gradient.attr('x1', xAxisBBox.x).attr('x2', xAxisBBox.width).attr('y1', 0).attr('y2', 0);
      } else {
        console.log('YAXIS---------------------', yAxisBBox.height, 'xAXIS', xAxisBBox.width);
        gradient.attr('x1', 0).attr('x2', 0).attr('y1', yAxisBBox.height).attr('y2', 0);
      }
      if (type === 'area') {
        elements.style('fill', 'url(#gradient)');
      } else {
        const lineGradient = svg.append('linearGradient').attr('id', 'line-gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', gradientAxis === 'x' ? 0 : xAxisBBox.width)
.attr('x2', gradientAxis === 'x' ? xAxisBBox.width : 0)
.attr('y1', gradientAxis === 'y' ? 0 : yAxisBBox.height)
.attr('y2', gradientAxis === 'y' ? yAxisBBox.height : 0);
        data.forEach((d, i, arr) => {
          if (i === arr.length - 1) {
            return;
          }
          const color = colorScale(d[gradientAxis]);
          const relativePosition = (xScale(d.x) - xScale.range()[0]) / (xScale.range()[1] - xScale.range()[0]);
          lineGradient.append('stop').attr('offset', `${relativePosition * 100}%`).attr('stop-color', color);
        });
        elements.style('stroke', 'url(#line-gradient)');
      }
    } else {
      throw new Error(`Unsupported chart type ${type}`);
    }
  }
  function animateScatter(chartElements, data, chartComponents, duration) {
    const updateSelection = chartElements.data(data);
    const enterSelection = updateSelection.enter();
    const exitSelection = updateSelection.exit();
    enterSelection.append('circle').attr('class', 'scatter-plot0').attr('r', 5);
    updateSelection.merge(enterSelection).transition().duration(duration).attr('cx', (d) => chartComponents.x(d.x))
.attr('cy', (d) => chartComponents.y(d.y));
    exitSelection.remove();
  }
  function animateLine(chartElements, data, chartComponents, duration) {
    const line2 = d3.line().x((d) => chartComponents.x(d.x)).y((d) => chartComponents.y(d.y));
    const updateSelection = chartElements.data(data);
    const exitSelection = updateSelection.exit();
    const linePath = chartElements.filter('.line-graph0');
    linePath.data([data]).transition().duration(duration).attr('d', line2);
    exitSelection.remove();
  }
  function animateArea(chart, sortedData, chartComponents, options, duration) {
    console.log('animateArea', chart, sortedData, chartComponents, options, duration);
    const { y: y2 } = chartComponents;
    const area2 = d3.area().x((d) => chartComponents.x(d.x)).y0((d) => (d.y >= 0 ? y2(0) : y2(-d.y))).y1((d) => chartComponents.y(d.y));
    chart.select('svg .area-chart0').datum(sortedData).transition().duration(duration)
.attr('d', area2(sortedData));
  }
  function animateBar(selection, data, chartComponents, options, duration) {
    const { width, barWidth } = options;
    const { x: x2, y: y2 } = chartComponents;
    const isLinearScale = x2.domain()[1] !== void 0 && typeof x2.domain()[1] === 'number';
    const dynamicBarWidth = isLinearScale ? options.width / data.length + options.barWidth : x2.bandwidth() + options.barWidth;
    selection.transition().duration(duration).attr('x', (d) => (isLinearScale ? x2(d.x) - barWidth / 2 : x2(d.x))).attr('y', (d) => (d.y >= 0 ? y2(d.y) : y2(0)))
.attr('height', (d) => (d.y >= 0 ? y2(0) - y2(d.y) : y2(d.y) - y2(0)))
.attr('width', dynamicBarWidth);
  }
  function animatePie(chartComponents, data, duration, options) {
    const svg = d3.select('svg');
    console.log(svg);
    const chartGroup = svg.select('g').empty() ? svg.append('g').attr('transform', `translate(${options.width / 2}, ${options.height / 2})`) : svg.select('g');
    const color = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(d3.schemeCategory10);
    const pie2 = d3.pie().value((d) => d.y).sort(null);
    const arc2 = d3.arc().innerRadius(0).outerRadius(options.radius);
    const labelArc = d3.arc().innerRadius(options.radius * 0.6).outerRadius(options.radius * 0.6);
    const update = chartGroup.selectAll('path').data(pie2(data));
    update.join(
      (enter) => enter.append('path').attr('fill', (d) => color(d.data.y)).attr('stroke', `${options.strokeColor}` || 'white').attr('stroke-width', `${options.strokeWidth}` || 2)
.attr('d', arc2),
      (update2) => update2.transition().duration(duration).attr('d', arc2),
      (exit) => exit.remove()
    );
    const labelUpdate = chartGroup.selectAll('text').data(pie2(data));
    labelUpdate.join(
      (enter) => enter.append('text').attr('transform', (d) => `translate(${labelArc.centroid(d)})`).attr('text-anchor', `${options.textAnchor}`).attr('alignment-baseline', 'central')
.text((d) => d.data.x),
      (update2) => update2.transition().duration(duration).attr('transform', (d) => `translate(${labelArc.centroid(d)})`).text((d) => d.data.x),
      (exit) => exit.remove()
    );
  }
  function animateDonutChart(chartComponents, data, duration, options) {
    const svg = d3.select('svg');
    console.log(svg);
    const chartGroup = svg.select('g').empty() ? svg.append('g').attr('transform', `translate(${options.width / 2}, ${options.height / 2})`) : svg.select('g');
    const pie2 = d3.pie().value((d) => d.y).sort(null);
    const arc2 = d3.arc().innerRadius(options.radius * 0.5).outerRadius(options.radius * 0.8);
    const labelArc = d3.arc().innerRadius(options.radius * 0.6).outerRadius(options.radius * 0.6);
    const updateArcs = chartGroup.selectAll('.arc').data(pie2(data));
    updateArcs.join(
      (enter) => {
        const arcs = enter.append('g').attr('class', 'arc');
        arcs.append('path').attr('fill', (d, i) => options.fillColor[i]).attr('stroke', `${options.strokeColor}` || 'white').style('stroke-width', `${options.strokeWidth}` || 2)
.attr('d', arc2);
        return arcs;
      },
      (update) => update.select('path').transition().duration(duration).attr('d', arc2),
      (exit) => exit.remove()
    );
    const labelUpdate = chartGroup.selectAll('text').data(pie2(data));
    labelUpdate.join(
      (enter) => enter.append('text').attr('transform', (d) => `translate(${labelArc.centroid(d)})`).attr('text-anchor', `${options.textAnchor}`).style('fill', 'red')
.style('font-size', `${options.fontSize}`)
.style('font-weight', 'bold')
.text((d) => d.data.x),
      (update) => update.transition().duration(duration).attr('transform', (d) => `translate(${labelArc.centroid(d)})`).text((d) => d.data.x),
      (exit) => exit.remove()
    );
  }
  function updateD3FunnelChart(chartComponents, data, duration, options) {
    const { width } = options;
    const { colors } = options;
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const colorScale = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(colors);
    const svg = d3.select('svg');
    const rectsUpdate = svg.selectAll('rect.funnel-chart0').data(data, (d) => d.x);
    const rectHeight = options.height / data.length;
    rectsUpdate.join(
      (enter) => enter.append('rect').attr('class', 'funnel-chart0').attr('x', (d) => (width - x2(d.y) + x2(0)) / 2).attr('width', (d) => x2(d.y) - x2(0))
.attr('height', rectHeight)
.attr('fill', (d) => colorScale(d.x))
.attr('transform', (d, i) => `translate(0, ${y2(d.x)})`),
      (update) => update.transition().duration(duration).attr('x', (d) => (width - x2(d.y) + x2(0)) / 2).attr('width', (d) => x2(d.y) - x2(0))
.attr('height', y2.bandwidth())
.attr('fill', (d) => colorScale(d.x)),
      // .attr('transform', (d, i) => `translate(0, ${y(d.x)})`),
      (exit) => exit.remove()
    );
  }
  function createD3StackedBarChart$1(data, options, chartComponents) {
    const {
      x: x2,
      y: y2,
      svg,
    } = chartComponents;
    const color = d3.scaleOrdinal().domain(data[0].values.map((v) => v.group)).range(options.color);
    const stack2 = d3.stack().keys(data[0].values.map((v) => v.group)).value((d, key) => d.find((v) => v.group === key).value);
    const bars = svg.append('g').selectAll('g').data(stack2(data.map((d) => d.values))).join('g')
.attr('fill', (d) => color(d.key));
    bars.selectAll('rect').data((d) => d).join(
      (enter) => enter.append('rect').attr('x', (d, i) => x2(data[i].category)).attr('y', y2(0)).attr('height', 0)
.attr('width', x2.bandwidth())
.call((enterSelection) => animateBar(enterSelection, data, chartComponents, options, options.duration)),
      (update) => update.call((updateSelection) => animateBar(updateSelection, data, chartComponents, options, options.duration))
    ).transition()
.duration(options.duration)
.attr('x', (d, i) => x2(data[i].category))
.attr('y', (d) => y2(d[1]))
.attr('height', (d) => y2(d[0]) - y2(d[1]))
.attr('width', x2.bandwidth());
    bars.exit().remove();
  }
  function addAnimation(selector, data, options, chartComponents, duration = 1e3) {
    setTimeout(() => {
      const chart = d3.select(selector);
      chart.select('.x-axis').transition().duration(duration).call(chartComponents.xAxis);
      chart.select('.y-axis').transition().duration(duration).call(chartComponents.yAxis);
      const elements = chart.selectAll('g rect, g circle, .line-graph0, .area-chart0, path');
      const excludedElements = d3.selectAll('.shape-label, .shape-pointer');
      let chartElements = elements.filter(function () {
        const currentElement = d3.select(this);
        return !excludedElements.nodes().includes(currentElement.node());
      });
      console.log('chartElements should exclude pointer', chartElements);
      const type = chartElements.nodes()[0].className.baseVal;
      const sortedData = data.slice().sort((a2, b) => d3.ascending(a2.x, b.x));
      if (type === 'area-chart0' || type === 'line-graph0') {
        if (type === 'area-chart0') {
          animateArea(chart, sortedData, chartComponents, options, duration);
          return;
        }
        animateLine(chartElements, sortedData, chartComponents, duration);
        return;
      }
      let numPlaceholders = data.length - chartElements.size();
      if (numPlaceholders > 0) {
        while (numPlaceholders > 0) {
          const selectedElement = chartElements.nodes()[0];
          const clonedElement = selectedElement.cloneNode(true);
          const g = chart.select('g');
          g.node().appendChild(clonedElement);
          numPlaceholders -= 1;
        }
      } else if (numPlaceholders < 0) {
        const nodes = chartElements.nodes();
        while (numPlaceholders < 0) {
          const selectedElement = nodes.pop();
          selectedElement.remove();
          numPlaceholders++;
        }
      }
      chartElements = chart.selectAll('g rect, g circle, .line-graph0, .area-chart0 path, path').data(data);
      console.log('TYPE', type, 'chartElements', chartElements);
      switch (type) {
        case 'bar-chart0':
          animateBar(chartElements, data, chartComponents, options, duration);
          break;
        case 'scatter-plot0':
          animateScatter(chartElements, data, chartComponents, duration);
          break;
        case 'pie-chart0':
          animatePie(chartComponents, data, duration, options);
          break;
        case 'donut-chart0':
          animateDonutChart(chartComponents, data, duration, options);
          break;
        case 'funnel-chart0':
          updateD3FunnelChart(chartComponents, data, duration, options);
          break;
        case 'stacked-bar-chart0':
          createD3StackedBarChart$1(chartComponents, data, duration, options);
          break;
        default:
          console.log('No animation for this chart type', type);
      }
      if (!options.yLine) {
        chart.select('.y-axis path').remove();
      }
      if (!options.xLine) {
        chart.select('.x-axis path').remove();
      }
      if (options.onHover) {
        onHover(selector, [options]);
      }
      if (options.relativeNode) {
        adjustNodeSize(selector, data, options);
      }
      if (options.gradient) {
        addGradient(selector, options.gradientColor[0], options.gradientColor[1], type, options.gradientAxis, data);
      }
    }, duration);
  }
  function createAdjacencyMatrix(data, options, chartComponents) {
    const { svg } = chartComponents;
    const g = svg.append('g').attr('transform', `translate(${options.margin.left}, ${options.margin.top})`);
    const x2 = d3.scaleBand().domain(data.nodes.map((d) => d.id)).range([0, options.width - options.margin.left - options.margin.right]).padding(0.1);
    const y2 = d3.scaleBand().domain(data.nodes.map((d) => d.id)).range([0, options.height - options.margin.top - options.margin.bottom]).padding(0.1);
    const colorScale = d3.scaleLinear().domain([0, d3.max(data.links.map((d) => d.value))]).range([options.minColor, options.maxColor]);
    g.selectAll('rect').data(data.links).enter().append('rect')
.attr('x', (d) => x2(d.source))
.attr('y', (d) => y2(d.target))
.attr('width', x2.bandwidth())
.attr('height', y2.bandwidth())
.attr('fill', (d) => colorScale(d.value));
    const xAxis = d3.axisBottom(x2);
    g.append('g').attr('transform', `translate(0, ${options.height - options.margin.top - options.margin.bottom})`).call(xAxis);
    const yAxis = d3.axisLeft(y2);
    g.append('g').call(yAxis);
  }
  function createD3AreaChart(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    const area2 = d3.area().x((d) => x2(d.x)).y0((d) => (d.y >= 0 ? y2(0) : y2(-d.y))).y1((d) => y2(d.y));
    const sortedData = data.sort((a2, b) => a2.x - b.x);
    svg.append('path').datum(sortedData).attr('fill', `${options.fillColor}`).attr('d', area2);
  }
  function createD3BarChart(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    data.sort((a2, b) => d3.ascending(a2.x, b.x));
    const isLinearScale = x2.domain()[1] !== void 0 && typeof x2.domain()[1] === 'number';
    const barWidth = isLinearScale ? options.width / data.length + options.barWidth : x2.bandwidth();
    svg.append('g').selectAll('rect').data(data).join('rect')
.attr('x', (d) => (isLinearScale ? x2(d.x) - barWidth / 2 : x2(d.x)))
.attr('y', (d) => (d.y >= 0 ? y2(d.y) : y2(0)))
.attr('height', (d) => (d.y >= 0 ? y2(0) - y2(d.y) : y2(d.y) - y2(0)))
.attr('fill', options.color)
.attr('width', barWidth);
  }
  function createD3BoxPlot(data, options, chartComponents) {
    const fillColor = options.fillColor || 'steelblue';
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { xAxis } = chartComponents;
    const { yAxis } = chartComponents;
    const { svg } = chartComponents;
    function update(data2) {
      x2.domain(data2.map((d) => d.category));
      y2.domain([d3.min(data2, (d) => d.min), d3.max(data2, (d) => d.max)]).nice();
      svg.selectAll('.x-axis').call(xAxis);
      svg.selectAll('.y-axis').call(yAxis);
      const boxWidth = Math.min(x2.bandwidth(), 50);
      const box = svg.selectAll('.box').data(data2, (d) => d.category).join('g').attr('class', 'box')
.attr('transform', (d) => `translate(${x2(d.category)},0)`);
      box.selectAll('.min').data((d) => [d]).join('line').attr('class', 'min')
.attr('x1', boxWidth / 2)
.attr('x2', boxWidth / 2)
.attr('y1', (d) => y2(d.min))
.attr('y2', (d) => y2(d.q1))
.attr('stroke', `${options.strokeColor}` || 'black');
      box.selectAll('.max').data((d) => [d]).join('line').attr('class', 'max')
.attr('x1', boxWidth / 2)
.attr('x2', boxWidth / 2)
.attr('y1', (d) => y2(d.q3))
.attr('y2', (d) => y2(d.max))
.attr('stroke', `${options.strokeColor}` || 'black');
      box.selectAll('.box-rect').data((d) => [d]).join('rect').attr('class', 'box-rect')
.attr('x', 0)
.attr('width', boxWidth)
.attr('y', (d) => y2(d.q3))
.attr('height', (d) => y2(d.q1) - y2(d.q3))
.attr('fill', fillColor);
    }
    update(data);
    return { update };
  }
  function createBubbleChart(data, options, chartComponents) {
    const { diameter } = options;
    const { svg } = chartComponents;
    const colorScheme = options.colorScheme || d3.schemeCategory10;
    const root = d3.hierarchy({ children: data }).sum((d) => d.value).sort((a2, b) => b.value - a2.value);
    const bubbleLayout = d3.pack().size([diameter, diameter]).padding(options.padding);
    bubbleLayout(root);
    const nodes = svg.selectAll('g').data(root.descendants()).enter().append('g')
.attr('class', 'node')
.attr('transform', (d) => `translate(${d.x},${d.y})`);
    nodes.append('circle').attr('r', (d) => d.r).style('fill', (d) => colorScheme[d.depth]).style('opacity', (d) => (d.depth <= 1 ? 1 : options.opacity));
    nodes.append('text').attr('dy', '.3em').style('text-anchor', `${options.textAnchor}`).style('font-size', (d) => (d.depth === 1 ? `${options.parentTextSize}` : `${options.childTextSize}`))
.style('fill', `${options.fontColor}`)
.text((d) => {
      if (d.depth === 1) {
        return d.data.name;
      }
      if (d.depth === 2) {
        return d.data.name;
      }
      return null;
    })
.attr('x', 0)
.attr('y', (d) => (d.depth === 1 ? -options.height / 6 : 0));
    nodes.selectAll('text').filter((d) => d.depth === 1).attr('y', (d) => -d.r);
  }
  function createChordDiagram(data, options, chartComponents) {
    const {
      width,
      height,
      color,
      strokeColor,
      outerRadius,
      innerRadius,
    } = options;
    const labels = data.pop();
    const { svg } = chartComponents;
    const chord = d3.chord().padAngle(0.05).sortSubgroups(d3.descending);
    const arc2 = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
    const ribbon = d3.ribbon().radius(innerRadius);
    const chords = chord(data);
    const group2 = svg.append('g').selectAll('g').data(chords.groups).join('g');
    group2.append('path').attr('class', 'arc').attr('d', arc2).attr('fill', (d) => color(d.index))
.attr('stroke', strokeColor);
    const ribbons = svg.append('g').attr('fill-opacity', 0.75).selectAll('path').data(chords)
.join('path')
.attr('class', 'ribbon')
.attr('d', ribbon)
.attr('fill', (d) => color(d.source.index))
.attr('stroke', strokeColor);
    group2.append('text').each(function (d) {
      const centroid2 = arc2.centroid(d);
      d3.select(this).attr('x', centroid2[0]).attr('y', centroid2[1]).attr('dy', '0.35em')
.attr('text-anchor', `${options.textAnchor}`)
.style('font-size', `${options.childTextSize}`)
.text(labels[d.index]);
    });
  }
  function createClusterDiagram(data, options, chartComponents) {
    const {
      width,
      height,
      color = d3.scaleOrdinal(d3.schemeCategory10),
      nodeRadius,
      strokeColor,
    } = options;
    const { svg } = chartComponents;
    const cluster = d3.cluster().size([360, height / 2 - 100]);
    const root = d3.hierarchy(data);
    cluster(root);
    const link2 = svg.selectAll('.link').data(root.links()).join('line').attr('class', 'link')
.attr('stroke', strokeColor)
.attr('stroke-width', `${options.strokeWidth}` || 1.5)
.attr('x1', (d) => d.source.y * Math.cos((d.source.x - 90) * Math.PI / 180))
.attr('y1', (d) => d.source.y * Math.sin((d.source.x - 90) * Math.PI / 180))
.attr('x2', (d) => d.target.y * Math.cos((d.target.x - 90) * Math.PI / 180))
.attr('y2', (d) => d.target.y * Math.sin((d.target.x - 90) * Math.PI / 180));
    const node = svg.selectAll('.node').data(root.descendants()).join('g').attr('class', 'node')
.attr('transform', (d) => `translate(${d.y * Math.cos((d.x - 90) * Math.PI / 180)}, ${d.y * Math.sin((d.x - 90) * Math.PI / 180)})`);
    node.append('circle').attr('r', nodeRadius).style('fill', (d) => color(d.data.group));
    node.append('text').attr('dy', '0.31em').attr('x', (d) => (d.children ? -nodeRadius : nodeRadius)).style('text-anchor', (d) => (d.children ? "end" : "start"))
.style('font-size', `${options.childTextSize}`)
.style('fill', '#000')
.text((d) => d.data.name);
  }
  function createDendrogram(data, options, chartComponents) {
    const { svg } = chartComponents;
    const g = svg.append('g').attr('transform', `translate(${options.margin.left}, ${options.margin.top})`);
    const layout = d3.cluster().size([options.height - options.margin.top - options.margin.bottom, options.width - options.margin.left - options.margin.right]);
    const root = d3.hierarchy(data);
    layout(root);
    const link2 = g.selectAll('.link').data(root.descendants().slice(1)).enter().append('path')
.attr('class', 'link')
.attr('d', (d) => `M${d.y},${d.x}V${(d.x + d.parent.x) / 2}H${d.parent.y}V${d.parent.x}`)
.style('stroke', options.linkColor)
.style('fill', 'none');
    const node = g.selectAll('.node').data(root.descendants()).enter().append('g')
.attr('class', (d) => `node${d.children ? ' node--internal' : ' node--leaf'}`)
.attr('transform', (d) => `translate(${d.y},${d.x})`);
    node.append('circle').attr('r', options.nodeRadius).style('fill', options.nodeColor);
    node.append('text').attr('dy', '.35em').attr('x', (d) => (d.children ? -options.nodeRadius - 2 : options.nodeRadius + 2)).style('text-anchor', (d) => (d.children ? "end" : "start"))
.text((d) => d.data.name)
.style('font-size', options.textSize)
.style('fill', options.textColor);
  }
  function createD3DonutChart(data, options, chartComponents) {
    const { svg } = chartComponents;
    const chartGroup = svg.append('g');
    const arc2 = d3.arc().innerRadius(options.innerRadius).outerRadius(options.outerRadius);
    const pie2 = d3.pie().sort(null).value((d) => d.y);
    const arcs = chartGroup.selectAll('.arc').data(pie2(data)).enter().append('g')
.attr('class', 'arc');
    arcs.append('path').attr('d', arc2).attr('fill', (d, i) => options.colorScheme[i]).attr('stroke', `${options.strokeColor}`)
.style('stroke-width', `${options.strokeWidth}` || 2);
    arcs.append('text').attr('transform', (d) => `translate(${arc2.centroid(d)})`).attr('text-anchor', `${options.textAnchor}`).text((d) => d.data.x)
.style('fill', 'red')
.style('font-size', `${options.fontSize}`)
.style('font-weight', 'bold');
  }
  function createD3FunnelChart(data, options, chartComponents) {
    const { width } = options;
    const { colors } = options;
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    const colorScale = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(colors);
    const funnel = svg.selectAll('g').data(data).join('g').attr('transform', (d, i) => `translate(0, ${y2(d.x)})`);
    funnel.append('rect').attr('x', (d) => (width - x2(d.y) + x2(0)) / 2).attr('width', (d) => x2(d.y) - x2(0)).attr('height', y2.bandwidth())
.attr('fill', (d) => colorScale(d.x));
  }
  function createD3GaugeChart(sampleValues, options, chartComponents) {
    const width = options.width || 300;
    const height = options.height || 300;
    const radius = Math.min(width, height) / 2;
    const startAngle = options.startAngle || -Math.PI / 1.25;
    const endAngle = options.endAngle || Math.PI / 1.25;
    const majorTicks = options.majorTicks || 5;
    const minorTicks = options.minorTicks || 4;
    const majorTickColor = options.majorTickColor || 'black';
    const minorTickColor = options.minorTickColor || 'black';
    const pointerColor = options.pointerColor || 'red';
    const arcColors = options.arcColors || d3.schemeCategory10;
    const { svg } = chartComponents;
    let currentValue = 0;
    const arc2 = d3.arc().innerRadius(0.7 * radius).outerRadius(0.85 * radius).startAngle((d, i) => startAngle + i * (endAngle - startAngle) / majorTicks)
.endAngle((d, i) => startAngle + (i + 1) * (endAngle - startAngle) / majorTicks);
    const minorTickValue = (endAngle - startAngle) / (majorTicks * minorTicks);
    const minorTickAngle = minorTickValue;
    svg.selectAll('.majorTicks').data(d3.range(majorTicks)).enter().append('path')
.attr('class', 'majorTicks')
.attr('fill', majorTickColor)
.attr('d', arc2);
    svg.selectAll('.minorTicks').data(d3.range(majorTicks * minorTicks)).enter().append('path')
.attr('class', 'minorTicks')
.attr('fill', minorTickColor)
.attr('d', arc2.innerRadius(0.75 * radius).outerRadius(0.85 * radius));
    svg.selectAll('.minorTickValues').data(d3.range(majorTicks * minorTicks)).enter().append('text')
.attr('class', 'minorTickValues')
.attr('fill', minorTickColor)
.attr('text-anchor', `${options.textAnchor}`)
.attr('font-size', `${options.childTextSize}`)
.attr('x', (d, i) => {
      const tickValueAngle = startAngle + i * minorTickAngle;
      return 0.68 * radius * Math.cos(tickValueAngle - Math.PI / 2);
    })
.attr('y', (d, i) => {
      const tickValueAngle = startAngle + i * minorTickAngle;
      return 0.68 * radius * Math.sin(tickValueAngle - Math.PI / 2) + 4;
    })
.text((d, i) => Number.parseFloat(i * minorTickValue).toFixed(1));
    const pointer = svg.append('path').attr('class', 'pointer').attr('fill', pointerColor).attr('stroke', `${options.strokeColor}` || 'black')
.attr('stroke-width', `${options.strokeWidth}` || 1);
    function updateGauge(value2) {
      const angle = startAngle + (endAngle - startAngle) * value2 / (majorTicks * minorTicks);
      const pointerPath = d3.arc().innerRadius(0.6 * radius).outerRadius(0.9 * radius).startAngle(angle - 0.05)
.endAngle(angle + 0.05);
      pointer.transition().duration(1e3).attrTween('d', () => {
        const currentAngle = startAngle + (endAngle - startAngle) * currentValue / (majorTicks * minorTicks);
        const interpolate = d3.interpolate(currentAngle, angle);
        return (t) => {
          const interpolatedAngle = interpolate(t);
          const updatedPointerPath = d3.arc().innerRadius(0.6 * radius).outerRadius(0.9 * radius).startAngle(interpolatedAngle - 0.05)
.endAngle(interpolatedAngle + 0.05);
          return updatedPointerPath();
        };
      });
      currentValue = value2;
    }
    if (Array.isArray(sampleValues)) {
      let index2 = 0;
      setInterval(() => {
        updateGauge(sampleValues[index2]);
        index2 = (index2 + 1) % sampleValues.length;
      }, options.interval || 1e3);
    } else {
      updateGauge(sampleValues);
    }
  }
  function createD3Heatmap(data, options, chartComponents) {
    const {
      width,
      height,
      margin,
      colorScale,
      x: x2 = 'x',
      y: y2 = 'y'
    } = options;
    const { svg } = chartComponents;
    const xScale = d3.scaleBand().domain(data.map((d) => d[x2])).range([margin.left, width - margin.right]).padding(0.25);
    const yScale = d3.scaleBand().domain(data.map((d) => d[y2])).range([margin.top, height - margin.bottom]).padding(0.25);
    const color = d3.scaleSequential(colorScale).domain(d3.extent(data, (d) => d.y));
    svg.selectAll('.heatmap-cell').data(data).join('rect').classed('heatmap-cell', true)
.attr('x', (d) => xScale(d[x2]))
.attr('y', (d) => yScale(d[y2]))
.attr('width', xScale.bandwidth())
.attr('height', yScale.bandwidth())
.attr('fill', (d) => color(d.y));
    svg.append('g').classed('x-axis', true).attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(xScale).tickSizeOuter(0))
.append('text')
.classed('x-axis-label', true)
.attr('x', width - margin.right)
.attr('y', margin.bottom - 10)
.attr('text-anchor', `${options.textAnchor}`)
.text(x2);
    svg.append('g').classed('y-axis', true).attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(yScale).tickSizeOuter(0))
.append('text')
.classed('y-axis-label', true)
.attr('x', -margin.top)
.attr('y', margin.left - 10)
.attr('text-anchor', `${options.textAnchor}`)
.attr('transform', 'rotate(-90)')
.text(y2);
  }
  function createIcicleChart(data, options, chartComponents) {
    const width = options.width || 960;
    const height = options.height || 500;
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const { svg } = chartComponents;
    const partition = (data2) => {
      const root2 = d3.hierarchy(data2).sum((d) => d.value).sort((a2, b) => b.height - a2.height || b.value - a2.value);
      return d3.partition().size([height, width]).padding(1)(root2);
    };
    const root = partition(data);
    const nodes = root.descendants();
    svg.selectAll('.node').data(nodes).enter().append('rect')
.attr('class', 'node')
.attr('x', (d) => d.x0)
.attr('y', (d) => d.y0)
.attr('width', (d) => d.x1 - d.x0)
.attr('height', (d) => d.y1 - d.y0)
.style('fill', (d) => color((d.children ? d : d.parent).data.name));
    svg.selectAll('.label').data(nodes.filter((d) => d.x1 - d.x0 > 6)).enter().append('text')
.attr('class', 'label')
.attr('dy', '.35em')
.attr('transform', (d) => `translate(${(d.x0 + d.x1) / 2},${(d.y0 + d.y1) / 2})rotate(90)`)
.text((d) => d.data.name)
.style('font-size', `${options.childTextSize}`);
  }
  function createD3LineGraph(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    if (typeof data[0].x === 'number') {
      data.sort((a2, b) => d3.ascending(a2.x, b.x));
    }
    const line2 = d3.line().x((d) => x2(d.x)).y((d) => y2(d.y));
    const sortedData = data.sort((a2, b) => a2.x - b.x);
    svg.append('path').datum(sortedData).attr('fill', 'none').attr('stroke', options.strokeColor || 'steelblue')
.attr('stroke-width', options.strokeWidth || 1.5)
.attr('d', line2);
  }
  function createMarimekkoChart(data, options, chartComponents) {
    const { svg } = chartComponents;
    const g = svg.append('g').attr('transform', `translate(${options.margin.left}, ${options.margin.top})`);
    const x2 = d3.scaleBand().domain(data.map((d) => d.category)).range([0, options.width - options.margin.left - options.margin.right]).padding(0.1);
    const y2 = d3.scaleLinear().domain([0, 1]).range([options.height - options.margin.top - options.margin.bottom, 0]);
    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const parentRects = g.selectAll('.parent-rect').data(data).enter().append('g')
.attr('class', 'parent-rect')
.attr('transform', (d) => `translate(${x2(d.category)}, 0)`);
    parentRects.each(function (parentData) {
      const parentGroup = d3.select(this);
      let yOffset = 0;
      parentData.children.forEach((childData) => {
        parentGroup.append('rect').datum(childData).attr('x', 0).attr('y', (d) => {
          const yPos = yOffset;
          yOffset += y2(0) - y2(d.percentage);
          return yPos;
        })
.attr('width', x2.bandwidth())
.attr('height', (d) => y2(0) - y2(d.percentage))
.style('fill', (d) => colorScale(d.subCategory))
.attr('class', 'child-rect')
.text((d) => d.subCategory)
.attr('text-color', 'white');
        parentGroup.append('text').datum(childData).attr('x', x2.bandwidth() / 2).attr('y', yOffset - 30 / 2)
.attr('text-anchor', 'middle')
.attr('dominant-baseline', 'central')
.text((d) => d.subCategory)
.style('fill', 'white');
      });
    });
    g.append('g').attr('transform', `translate(0, ${options.height - options.margin.top - options.margin.bottom})`).call(d3.axisBottom(x2));
    g.append('g').call(d3.axisLeft(y2));
  }
  function createD3PieChart(data, options, chartComponents) {
    const { width } = options;
    const { height } = options;
    const { svg } = chartComponents;
    const radius = Math.min(width, height) / 2;
    const chartGroup = svg.append('g').attr('transform', `translate(${width / 2}, ${height / 2})`);
    const color = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(d3.schemeCategory10);
    const pie2 = d3.pie().value((d) => d.y).sort(null);
    const arc2 = d3.arc().innerRadius(0).outerRadius(radius);
    chartGroup.selectAll('path').data(pie2(data)).enter().append('path')
.attr('fill', (d) => color(d.data.y))
.attr('d', arc2)
.attr('stroke', `${options.strokeColor}` || 'white')
.attr('stroke-width', `${options.strokeWidth}px` || '2px');
    if (options.showCategories) {
      const categoryArc = d3.arc().innerRadius(radius * 0.6).outerRadius(radius * 0.6);
      chartGroup.selectAll('text').data(pie2(data)).join('text').attr('transform', (d) => `translate(${categoryArc.centroid(d)})`)
.attr('text-anchor', `${options.textAnchor}`)
.attr('alignment-baseline', 'central')
.text((d) => d.data.x);
    }
  }
  function createD3PolarChart(data, options, chartComponents) {
    const {
      colorScheme,
      innerRadius,
      outerRadius,
    } = options;
    const { svg } = chartComponents;
    const x2 = d3.scaleBand().domain(data.map((d) => d.x)).range([0, 2 * Math.PI]).padding(0.1);
    const y2 = d3.scaleLinear().domain([0, d3.max(data, (d) => d.y)]).range([innerRadius, outerRadius]);
    console.log(data[0].x);
    const colorScale = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(colorScheme);
    const arc2 = d3.arc().innerRadius(0).outerRadius((d) => y2(d.y)).startAngle((d) => x2(d.x))
.endAngle((d) => x2(d.x) + x2.bandwidth())
.padAngle(0.01)
.padRadius(innerRadius);
    svg.selectAll('path').data(data).join('path').attr('d', arc2)
.attr('fill', (d) => colorScale(d.x));
    svg.selectAll('text').data(data).join('text').attr('x', (d) => (y2(d.y) + 10) * Math.cos(x2(d.x) + x2.bandwidth() / 2 - Math.PI / 2))
.attr('y', (d) => (y2(d.y) + 10) * Math.sin(x2(d.x) + x2.bandwidth() / 2 - Math.PI / 2))
.text((d) => d.x)
.attr('text-anchor', `${options.textAnchor}`)
.attr('font-size', `${options.childTextSize}`);
  }
  function createD3RadarChart(data, options, chartComponents) {
    const {
      width,
      height,
      colorScheme,
      maxValue,
      levels,
    } = options;
    const { svg } = chartComponents;
    const radius = Math.min(width, height) / 2;
    const angleSlice = 2 * Math.PI / data.length;
    const rScale = d3.scaleLinear().domain([0, maxValue]).range([0, radius]);
    const lineGenerator = d3.lineRadial().curve(d3.curveLinearClosed);
    svg.selectAll('.radar-chart-path').data([data]).join('path').attr('class', 'radar-chart-path')
.attr('d', lineGenerator.radius((d) => rScale(d.y)).angle((d, i) => i * angleSlice))
.attr('fill', colorScheme[0])
.attr('fill-opacity', 0.6)
.attr('stroke', colorScheme[1])
.attr('stroke-width', `${options.strokeWidth}` || 2);
    for (let level = 0; level < levels; level++) {
      const levelFactor = radius * ((level + 1) / levels);
      svg.selectAll(`.ticks-${level}`).data(data).join('line').attr('class', `ticks ticks-${level}`)
.attr('x1', (d, i) => levelFactor * Math.cos(angleSlice * i - Math.PI / 2))
.attr('y1', (d, i) => levelFactor * Math.sin(angleSlice * i - Math.PI / 2))
.attr('x2', (d, i) => levelFactor * Math.cos(angleSlice * (i + 1) - Math.PI / 2))
.attr('y2', (d, i) => levelFactor * Math.sin(angleSlice * (i + 1) - Math.PI / 2))
.attr('stroke', 'gray')
.attr('stroke-opacity', 0.6)
.attr('stroke-width', `${options.strokeWidth}` || 0.5);
    }
    svg.selectAll('.label').data(data).join('text').attr('class', 'label')
.attr('x', (d, i) => rScale(maxValue) * Math.cos(angleSlice * i - Math.PI / 2))
.attr('y', (d, i) => rScale(maxValue) * Math.sin(angleSlice * i - Math.PI / 2))
.text((d) => d.x)
.attr('text-anchor', 'middle')
.attr('font-size', '12px');
    svg.selectAll('.label-line').data(data).join('line').attr('class', 'label-line')
.attr('x1', 0)
.attr('y1', 0)
.attr('x2', (d, i) => rScale(maxValue) * Math.cos(angleSlice * i - Math.PI / 2))
.attr('y2', (d, i) => rScale(maxValue) * Math.sin(angleSlice * i - Math.PI / 2))
.attr('stroke', 'gray')
.attr('stroke-opacity', 0.6)
.attr('stroke-width', 0.5);
  }
  function createRadialTree(data, options, chartComponents) {
    const { svg } = chartComponents;
    const g = svg.append('g').attr('transform', `translate(${options.width / 2}, ${options.height / 2})`);
    const layout = d3.tree().size([2 * Math.PI, options.radius]);
    const root = d3.hierarchy(data);
    layout(root);
    const linkGenerator = d3.linkRadial().angle((d) => d.x).radius((d) => d.y);
    const link2 = g.selectAll('.link').data(root.links()).enter().append('path')
.attr('class', 'link')
.attr('d', linkGenerator)
.style('stroke', options.linkColor)
.style('fill', 'none');
    const node = g.selectAll('.node').data(root.descendants()).enter().append('g')
.attr('class', (d) => `node${d.children ? ' node--internal' : ' node--leaf'}`)
.attr('transform', (d) => `translate(${radialPoint(d.x, d.y)})`);
    node.append('circle').attr('r', options.nodeRadius).style('fill', options.nodeColor);
    node.append('text').attr('dy', '.31em').attr('x', (d) => (d.x < Math.PI === !d.children ? 6 : -6)).attr('text-anchor', (d) => (d.x < Math.PI === !d.children ? "start" : "end"))
.attr('transform', (d) => {
      const angle = d.x * 180 / Math.PI;
      const rotation = angle < 180 ? angle - 90 : angle + 90;
      return `rotate(${rotation})`;
    })
.text((d) => d.data.name)
.style('font-size', options.childTextSize)
.style('fill', options.textColor);
    function radialPoint(x2, y2) {
      return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
    }
  }
  function ascending$2(a2, b) {
    return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  }
  function bisector$1(f) {
    let delta = f;
    let compare = f;
    if (f.length === 1) {
      delta = (d, x2) => f(d) - x2;
      compare = ascendingComparator$1(f);
    }
    function left2(a2, x2, lo, hi) {
      if (lo == null) {lo = 0;}
      if (hi == null) {hi = a2.length;}
      while (lo < hi) {
        const mid = lo + hi >>> 1;
        if (compare(a2[mid], x2) < 0) {lo = mid + 1;}
        else {hi = mid;}
      }
      return lo;
    }
    function right2(a2, x2, lo, hi) {
      if (lo == null) {lo = 0;}
      if (hi == null) {hi = a2.length;}
      while (lo < hi) {
        const mid = lo + hi >>> 1;
        if (compare(a2[mid], x2) > 0) {hi = mid;}
        else {lo = mid + 1;}
      }
      return lo;
    }
    function center2(a2, x2, lo, hi) {
      if (lo == null) {lo = 0;}
      if (hi == null) {hi = a2.length;}
      const i = left2(a2, x2, lo, hi - 1);
      return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function ascendingComparator$1(f) {
    return (d, x2) => ascending$2(f(d), x2);
  }
  function number$1(x2) {
    return x2 === null ? NaN : +x2;
  }
  function* numbers$1(values, valueof) {
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          yield value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
          yield value2;
        }
      }
    }
  }
  const ascendingBisect$1 = bisector$1(ascending$2);
  const bisectRight$1 = ascendingBisect$1.right;
  const bisectLeft$1 = ascendingBisect$1.left;
  const bisectCenter$1 = bisector$1(number$1).center;
  function count$1(values, valueof) {
    let count2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          ++count2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
          ++count2;
        }
      }
    }
    return count2;
  }
  function length$4(array2) {
    return array2.length | 0;
  }
  function empty$1(length2) {
    return !(length2 > 0);
  }
  function arrayify$1(values) {
    return typeof values !== 'object' || 'length' in values ? values : Array.from(values);
  }
  function reducer$1(reduce2) {
    return (values) => reduce2(...values);
  }
  function cross$4(...values) {
    const reduce2 = typeof values[values.length - 1] === 'function' && reducer$1(values.pop());
    values = values.map(arrayify$1);
    const lengths = values.map(length$4);
    const j = values.length - 1;
    const index2 = new Array(j + 1).fill(0);
    const product = [];
    if (j < 0 || lengths.some(empty$1)) {return product;}
    while (true) {
      product.push(index2.map((j2, i2) => values[i2][j2]));
      let i = j;
      while (++index2[i] === lengths[i]) {
        if (i === 0) {return reduce2 ? product.map(reduce2) : product;}
        index2[i--] = 0;
      }
    }
  }
  function cumsum$1(values, valueof) {
    let sum2 = 0; var 
index2 = 0;
    return Float64Array.from(values, valueof === void 0 ? (v) => sum2 += +v || 0 : (v) => sum2 += +valueof(v, index2++, values) || 0);
  }
  function descending$3(a2, b) {
    return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
  }
  function variance$1(values, valueof) {
    let count2 = 0;
    let delta;
    let mean2 = 0;
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          delta = value2 - mean2;
          mean2 += delta / ++count2;
          sum2 += delta * (value2 - mean2);
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
          delta = value2 - mean2;
          mean2 += delta / ++count2;
          sum2 += delta * (value2 - mean2);
        }
      }
    }
    if (count2 > 1) {return sum2 / (count2 - 1);}
  }
  function deviation$1(values, valueof) {
    const v = variance$1(values, valueof);
    return v ? Math.sqrt(v) : v;
  }
  function extent(values, valueof) {
    let min2;
    let max2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null) {
          if (min2 === void 0) {
            if (value2 >= value2) {min2 = max2 = value2;}
          } else {
            if (min2 > value2) {min2 = value2;}
            if (max2 < value2) {max2 = value2;}
          }
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null) {
          if (min2 === void 0) {
            if (value2 >= value2) {min2 = max2 = value2;}
          } else {
            if (min2 > value2) {min2 = value2;}
            if (max2 < value2) {max2 = value2;}
          }
        }
      }
    }
    return [min2, max2];
  }
  const Adder$1 = class Adder {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x2) {
      const p = this._partials;
      let i = 0;
      for (let j = 0; j < this._n && j < 32; j++) {
        const y2 = p[j], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
        if (lo)
          p[i++] = lo;
        x2 = hi;
      }
      p[i] = x2;
      this._n = i + 1;
      return this;
    }
    valueOf() {
      const p = this._partials;
      let n = this._n, x2, y2, lo, hi = 0;
      if (n > 0) {
        hi = p[--n];
        while (n > 0) {
          x2 = hi;
          y2 = p[--n];
          hi = x2 + y2;
          lo = y2 - (hi - x2);
          if (lo)
            break;
        }
        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
          y2 = lo * 2;
          x2 = hi + y2;
          if (y2 == x2 - hi)
            hi = x2;
        }
      }
      return hi;
    }
  };
  function fsum$1(values, valueof) {
    const adder = new Adder$1();
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 = +value2) {
          adder.add(value2);
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if (value2 = +valueof(value2, ++index2, values)) {
          adder.add(value2);
        }
      }
    }
    return +adder;
  }
  function fcumsum$1(values, valueof) {
    const adder = new Adder$1();
    let index2 = -1;
    return Float64Array.from(
      values,
      valueof === void 0 ? (v) => adder.add(+v || 0) : (v) => adder.add(+valueof(v, ++index2, values) || 0)
    );
  }
  const InternMap$1 = class InternMap extends Map {
    constructor(entries, key = keyof$1) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null)
        for (const [key2, value2] of entries)
          this.set(key2, value2);
    }
    get(key) {
      return super.get(intern_get$1(this, key));
    }
    has(key) {
      return super.has(intern_get$1(this, key));
    }
    set(key, value2) {
      return super.set(intern_set$1(this, key), value2);
    }
    delete(key) {
      return super.delete(intern_delete$1(this, key));
    }
  };
  const InternSet$1 = class InternSet extends Set {
    constructor(values, key = keyof$1) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (values != null)
        for (const value2 of values)
          this.add(value2);
    }
    has(value2) {
      return super.has(intern_get$1(this, value2));
    }
    add(value2) {
      return super.add(intern_set$1(this, value2));
    }
    delete(value2) {
      return super.delete(intern_delete$1(this, value2));
    }
  };
  function intern_get$1({ _intern, _key }, value2) {
    const key = _key(value2);
    return _intern.has(key) ? _intern.get(key) : value2;
  }
  function intern_set$1({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) {return _intern.get(key);}
    _intern.set(key, value2);
    return value2;
  }
  function intern_delete$1({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) {
      value2 = _intern.get(value2);
      _intern.delete(key);
    }
    return value2;
  }
  function keyof$1(value2) {
    return value2 !== null && typeof value2 === 'object' ? value2.valueOf() : value2;
  }
  function identity$2(x2) {
    return x2;
  }
  function group$1(values, ...keys) {
    return nest$1(values, identity$2, identity$2, keys);
  }
  function groups$1(values, ...keys) {
    return nest$1(values, Array.from, identity$2, keys);
  }
  function rollup$1(values, reduce2, ...keys) {
    return nest$1(values, identity$2, reduce2, keys);
  }
  function rollups$1(values, reduce2, ...keys) {
    return nest$1(values, Array.from, reduce2, keys);
  }
  function index$1(values, ...keys) {
    return nest$1(values, identity$2, unique$1, keys);
  }
  function indexes$1(values, ...keys) {
    return nest$1(values, Array.from, unique$1, keys);
  }
  function unique$1(values) {
    if (values.length !== 1) {throw new Error("duplicate key");}
    return values[0];
  }
  function nest$1(values, map2, reduce2, keys) {
    return (function regroup(values2, i) {
      if (i >= keys.length)
        return reduce2(values2);
      const groups2 = new InternMap$1();
      const keyof2 = keys[i++];
      let index2 = -1;
      for (const value2 of values2) {
        const key = keyof2(value2, ++index2, values2);
        const group2 = groups2.get(key);
        if (group2)
          group2.push(value2);
        else
          groups2.set(key, [value2]);
      }
      for (const [key, values3] of groups2) {
        groups2.set(key, regroup(values3, i));
      }
      return map2(groups2);
    }(values, 0));
  }
  function permute$1(source, keys) {
    return Array.from(keys, (key) => source[key]);
  }
  function sort$1(values, ...F) {
    if (typeof values[Symbol.iterator] !== 'function') {throw new TypeError("values is not iterable");}
    values = Array.from(values);
    let [f = ascending$2] = F;
    if (f.length === 1 || F.length > 1) {
      const index2 = Uint32Array.from(values, (d, i) => i);
      if (F.length > 1) {
        F = F.map((f2) => values.map(f2));
        index2.sort((i, j) => {
          for (const f2 of F) {
            const c2 = ascending$2(f2[i], f2[j]);
            if (c2) {return c2;}
          }
        });
      } else {
        f = values.map(f);
        index2.sort((i, j) => ascending$2(f[i], f[j]));
      }
      return permute$1(values, index2);
    }
    return values.sort(f);
  }
  function groupSort$1(values, reduce2, key) {
    return (reduce2.length === 1 ? sort$1(rollup$1(values, reduce2, key), ([ak, av], [bk, bv]) => ascending$2(av, bv) || ascending$2(ak, bk)) : sort$1(group$1(values, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending$2(ak, bk))).map(([key2]) => key2);
  }
  let array$1 = Array.prototype;
  let slice$2 = array$1.slice;
  let map$3 = array$1.map;
  function constant$3(x2) {
    return function () {
      return x2;
    };
  }
  let e10$1 = Math.sqrt(50); var e5$1 = Math.sqrt(10); var 
e2$1 = Math.sqrt(2);
  function ticks$1(start, stop, count2) {
    let reverse2; var i = -1; var n; var ticks2; var 
step2;
    stop = +stop, start = +start, count2 = +count2;
    if (start === stop && count2 > 0) {return [start];}
    if (reverse2 = stop < start) {n = start, start = stop, stop = n;}
    if ((step2 = tickIncrement$1(start, stop, count2)) === 0 || !isFinite(step2)) {return [];}
    if (step2 > 0) {
      let r0 = Math.round(start / step2); let 
r1 = Math.round(stop / step2);
      if (r0 * step2 < start) {++r0;}
      if (r1 * step2 > stop) {--r1;}
      ticks2 = new Array(n = r1 - r0 + 1);
      while (++i < n) {ticks2[i] = (r0 + i) * step2;}
    } else {
      step2 = -step2;
      let r0 = Math.round(start * step2); let 
r1 = Math.round(stop * step2);
      if (r0 / step2 < start) {++r0;}
      if (r1 / step2 > stop) {--r1;}
      ticks2 = new Array(n = r1 - r0 + 1);
      while (++i < n) {ticks2[i] = (r0 + i) / step2;}
    }
    if (reverse2) {ticks2.reverse();}
    return ticks2;
  }
  function tickIncrement$1(start, stop, count2) {
    let step2 = (stop - start) / Math.max(0, count2); var power = Math.floor(Math.log(step2) / Math.LN10); var 
error = step2 / 10**power;
    return power >= 0 ? (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1) * 10**power : -(10**-power) / (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1);
  }
  function tickStep$1(start, stop, count2) {
    let step0 = Math.abs(stop - start) / Math.max(0, count2); var step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)); var 
error = step0 / step1;
    if (error >= e10$1) {step1 *= 10;}
    else if (error >= e5$1) {step1 *= 5;}
    else if (error >= e2$1) {step1 *= 2;}
    return stop < start ? -step1 : step1;
  }
  function nice$1(start, stop, count2) {
    let prestep;
    while (true) {
      const step2 = tickIncrement$1(start, stop, count2);
      if (step2 === prestep || step2 === 0 || !isFinite(step2)) {
        return [start, stop];
      } if (step2 > 0) {
        start = Math.floor(start / step2) * step2;
        stop = Math.ceil(stop / step2) * step2;
      } else if (step2 < 0) {
        start = Math.ceil(start * step2) / step2;
        stop = Math.floor(stop * step2) / step2;
      }
      prestep = step2;
    }
  }
  function sturges$1(values) {
    return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
  }
  function bin$1() {
    let value2 = identity$2; var domain = extent; var 
threshold = sturges$1;
    function histogram(data) {
      if (!Array.isArray(data)) {data = Array.from(data);}
      let i; var n = data.length; var x2; var 
values = new Array(n);
      for (i = 0; i < n; ++i) {
        values[i] = value2(data[i], i, data);
      }
      let xz = domain(values); var x0 = xz[0]; var x1 = xz[1]; var 
tz = threshold(values, x0, x1);
      if (!Array.isArray(tz)) {
        const max2 = x1; const 
tn = +tz;
        if (domain === extent) {[x0, x1] = nice$1(x0, x1, tn);}
        tz = ticks$1(x0, x1, tn);
        if (tz[tz.length - 1] >= x1) {
          if (max2 >= x1 && domain === extent) {
            const step2 = tickIncrement$1(x0, x1, tn);
            if (isFinite(step2)) {
              if (step2 > 0) {
                x1 = (Math.floor(x1 / step2) + 1) * step2;
              } else if (step2 < 0) {
                x1 = (Math.ceil(x1 * -step2) + 1) / -step2;
              }
            }
          } else {
            tz.pop();
          }
        }
      }
      let m = tz.length;
      while (tz[0] <= x0) {tz.shift(), --m;}
      while (tz[m - 1] > x1) {tz.pop(), --m;}
      let bins = new Array(m + 1); var 
bin2;
      for (i = 0; i <= m; ++i) {
        bin2 = bins[i] = [];
        bin2.x0 = i > 0 ? tz[i - 1] : x0;
        bin2.x1 = i < m ? tz[i] : x1;
      }
      for (i = 0; i < n; ++i) {
        x2 = values[i];
        if (x0 <= x2 && x2 <= x1) {
          bins[bisectRight$1(tz, x2, 0, m)].push(data[i]);
        }
      }
      return bins;
    }
    histogram.value = function (_) {
      return arguments.length ? (value2 = typeof _ === 'function' ? _ : constant$3(_), histogram) : value2;
    };
    histogram.domain = function (_) {
      return arguments.length ? (domain = typeof _ === 'function' ? _ : constant$3([_[0], _[1]]), histogram) : domain;
    };
    histogram.thresholds = function (_) {
      return arguments.length ? (threshold = typeof _ === 'function' ? _ : Array.isArray(_) ? constant$3(slice$2.call(_)) : constant$3(_), histogram) : threshold;
    };
    return histogram;
  }
  function max$2(values, valueof) {
    let max2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2;
        }
      }
    }
    return max2;
  }
  function min$2(values, valueof) {
    let min2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2;
        }
      }
    }
    return min2;
  }
  function quickselect$1(array2, k2, left2 = 0, right2 = array2.length - 1, compare = ascending$2) {
    while (right2 > left2) {
      if (right2 - left2 > 600) {
        const n = right2 - left2 + 1;
        const m = k2 - left2 + 1;
        const z = Math.log(n);
        const s2 = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left2, Math.floor(k2 - m * s2 / n + sd));
        const newRight = Math.min(right2, Math.floor(k2 + (n - m) * s2 / n + sd));
        quickselect$1(array2, k2, newLeft, newRight, compare);
      }
      const t = array2[k2];
      let i = left2;
      let j = right2;
      swap$1(array2, left2, k2);
      if (compare(array2[right2], t) > 0) {swap$1(array2, left2, right2);}
      while (i < j) {
        swap$1(array2, i, j), ++i, --j;
        while (compare(array2[i], t) < 0) {++i;}
        while (compare(array2[j], t) > 0) {--j;}
      }
      if (compare(array2[left2], t) === 0) {swap$1(array2, left2, j);}
      else {++j, swap$1(array2, j, right2);}
      if (j <= k2) {left2 = j + 1;}
      if (k2 <= j) {right2 = j - 1;}
    }
    return array2;
  }
  function swap$1(array2, i, j) {
    const t = array2[i];
    array2[i] = array2[j];
    array2[j] = t;
  }
  function quantile$1(values, p, valueof) {
    values = Float64Array.from(numbers$1(values, valueof));
    if (!(n = values.length)) {return;}
    if ((p = +p) <= 0 || n < 2) {return min$2(values);}
    if (p >= 1) {return max$2(values);}
    let n; var i = (n - 1) * p; var i0 = Math.floor(i); var value0 = max$2(quickselect$1(values, i0).subarray(0, i0 + 1)); var 
value1 = min$2(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileSorted$1(values, p, valueof = number$1) {
    if (!(n = values.length)) {return;}
    if ((p = +p) <= 0 || n < 2) {return +valueof(values[0], 0, values);}
    if (p >= 1) {return +valueof(values[n - 1], n - 1, values);}
    let n; var i = (n - 1) * p; var i0 = Math.floor(i); var value0 = +valueof(values[i0], i0, values); var 
value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  }
  function freedmanDiaconis$1(values, min2, max2) {
    return Math.ceil((max2 - min2) / (2 * (quantile$1(values, 0.75) - quantile$1(values, 0.25)) * count$1(values)**(-1 / 3)));
  }
  function scott$1(values, min2, max2) {
    return Math.ceil((max2 - min2) / (3.5 * deviation$1(values) * count$1(values)**(-1 / 3)));
  }
  function maxIndex$1(values, valueof) {
    let max2;
    let maxIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value2 of values) {
        ++index2;
        if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2, maxIndex2 = index2;
        }
      }
    } else {
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2, maxIndex2 = index2;
        }
      }
    }
    return maxIndex2;
  }
  function mean$1(values, valueof) {
    let count2 = 0;
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          ++count2, sum2 += value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
          ++count2, sum2 += value2;
        }
      }
    }
    if (count2) {return sum2 / count2;}
  }
  function median$1(values, valueof) {
    return quantile$1(values, 0.5, valueof);
  }
  function* flatten$1(arrays) {
    for (const array2 of arrays) {
      yield* array2;
    }
  }
  function merge$1(arrays) {
    return Array.from(flatten$1(arrays));
  }
  function minIndex$1(values, valueof) {
    let min2;
    let minIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value2 of values) {
        ++index2;
        if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2, minIndex2 = index2;
        }
      }
    } else {
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2, minIndex2 = index2;
        }
      }
    }
    return minIndex2;
  }
  function pairs$1(values, pairof = pair$1) {
    const pairs2 = [];
    let previous;
    let first = false;
    for (const value2 of values) {
      if (first) {pairs2.push(pairof(previous, value2));}
      previous = value2;
      first = true;
    }
    return pairs2;
  }
  function pair$1(a2, b) {
    return [a2, b];
  }
  function range$1(start, stop, step2) {
    start = +start, stop = +stop, step2 = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step2;
    var i = -1; var n = Math.max(0, Math.ceil((stop - start) / step2)) | 0; var 
range2 = new Array(n);
    while (++i < n) {
      range2[i] = start + i * step2;
    }
    return range2;
  }
  function least$1(values, compare = ascending$2) {
    let min2;
    let defined = false;
    if (compare.length === 1) {
      let minValue;
      for (const element of values) {
        const value2 = compare(element);
        if (defined ? ascending$2(value2, minValue) < 0 : ascending$2(value2, value2) === 0) {
          min2 = element;
          minValue = value2;
          defined = true;
        }
      }
    } else {
      for (const value2 of values) {
        if (defined ? compare(value2, min2) < 0 : compare(value2, value2) === 0) {
          min2 = value2;
          defined = true;
        }
      }
    }
    return min2;
  }
  function leastIndex$1(values, compare = ascending$2) {
    if (compare.length === 1) {return minIndex$1(values, compare);}
    let minValue;
    let min2 = -1;
    let index2 = -1;
    for (const value2 of values) {
      ++index2;
      if (min2 < 0 ? compare(value2, value2) === 0 : compare(value2, minValue) < 0) {
        minValue = value2;
        min2 = index2;
      }
    }
    return min2;
  }
  function greatest$1(values, compare = ascending$2) {
    let max2;
    let defined = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element of values) {
        const value2 = compare(element);
        if (defined ? ascending$2(value2, maxValue) > 0 : ascending$2(value2, value2) === 0) {
          max2 = element;
          maxValue = value2;
          defined = true;
        }
      }
    } else {
      for (const value2 of values) {
        if (defined ? compare(value2, max2) > 0 : compare(value2, value2) === 0) {
          max2 = value2;
          defined = true;
        }
      }
    }
    return max2;
  }
  function greatestIndex$1(values, compare = ascending$2) {
    if (compare.length === 1) {return maxIndex$1(values, compare);}
    let maxValue;
    let max2 = -1;
    let index2 = -1;
    for (const value2 of values) {
      ++index2;
      if (max2 < 0 ? compare(value2, value2) === 0 : compare(value2, maxValue) > 0) {
        maxValue = value2;
        max2 = index2;
      }
    }
    return max2;
  }
  function scan$1(values, compare) {
    const index2 = leastIndex$1(values, compare);
    return index2 < 0 ? void 0 : index2;
  }
  const shuffle$1 = shuffler$1(Math.random);
  function shuffler$1(random) {
    return function shuffle2(array2, i0 = 0, i1 = array2.length) {
      let m = i1 - (i0 = +i0);
      while (m) {
        const i = random() * m-- | 0; const 
t = array2[m + i0];
        array2[m + i0] = array2[i + i0];
        array2[i + i0] = t;
      }
      return array2;
    };
  }
  function sum$2(values, valueof) {
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 = +value2) {
          sum2 += value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if (value2 = +valueof(value2, ++index2, values)) {
          sum2 += value2;
        }
      }
    }
    return sum2;
  }
  function transpose$1(matrix) {
    if (!(n = matrix.length)) {return [];}
    for (var i = -1, m = min$2(matrix, length$3), transpose2 = new Array(m); ++i < m;) {
      for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n;) {
        row[j] = matrix[j][i];
      }
    }
    return transpose2;
  }
  function length$3(d) {
    return d.length;
  }
  function zip$1() {
    return transpose$1(arguments);
  }
  function every$1(values, test) {
    if (typeof test !== 'function') {throw new TypeError("test is not a function");}
    let index2 = -1;
    for (const value2 of values) {
      if (!test(value2, ++index2, values)) {
        return false;
      }
    }
    return true;
  }
  function some$1(values, test) {
    if (typeof test !== 'function') {throw new TypeError("test is not a function");}
    let index2 = -1;
    for (const value2 of values) {
      if (test(value2, ++index2, values)) {
        return true;
      }
    }
    return false;
  }
  function filter$1(values, test) {
    if (typeof test !== 'function') {throw new TypeError("test is not a function");}
    const array2 = [];
    let index2 = -1;
    for (const value2 of values) {
      if (test(value2, ++index2, values)) {
        array2.push(value2);
      }
    }
    return array2;
  }
  function map$2(values, mapper) {
    if (typeof values[Symbol.iterator] !== 'function') {throw new TypeError("values is not iterable");}
    if (typeof mapper !== 'function') {throw new TypeError("mapper is not a function");}
    return Array.from(values, (value2, index2) => mapper(value2, index2, values));
  }
  function reduce$1(values, reducer2, value2) {
    if (typeof reducer2 !== 'function') {throw new TypeError("reducer is not a function");}
    const iterator = values[Symbol.iterator]();
    let done; let next; let 
index2 = -1;
    if (arguments.length < 3) {
      ({ done, value: value2 } = iterator.next());
      if (done) {return;}
      ++index2;
    }
    while ({ done, value: next } = iterator.next(), !done) {
      value2 = reducer2(value2, next, ++index2, values);
    }
    return value2;
  }
  function reverse$2(values) {
    if (typeof values[Symbol.iterator] !== 'function') {throw new TypeError("values is not iterable");}
    return Array.from(values).reverse();
  }
  function difference$1(values, ...others) {
    values = new Set(values);
    for (const other of others) {
      for (const value2 of other) {
        values.delete(value2);
      }
    }
    return values;
  }
  function disjoint$1(values, other) {
    const iterator = other[Symbol.iterator](); const 
set2 = /* @__PURE__ */ new Set();
    for (const v of values) {
      if (set2.has(v)) {return false;}
      let value2; let 
done;
      while ({ value: value2, done } = iterator.next()) {
        if (done) {break;}
        if (Object.is(v, value2)) {return false;}
        set2.add(value2);
      }
    }
    return true;
  }
  function set$2(values) {
    return values instanceof Set ? values : new Set(values);
  }
  function intersection$1(values, ...others) {
    values = new Set(values);
    others = others.map(set$2);
    out:
    for (const value2 of values) {
      for (const other of others) {
        if (!other.has(value2)) {
          values.delete(value2);
          continue out;
        }
      }
    }
    return values;
  }
  function superset$1(values, other) {
    const iterator = values[Symbol.iterator](); const 
set2 = /* @__PURE__ */ new Set();
    for (const o of other) {
      if (set2.has(o)) {continue;}
      let value2; let 
done;
      while ({ value: value2, done } = iterator.next()) {
        if (done) {return false;}
        set2.add(value2);
        if (Object.is(o, value2)) {break;}
      }
    }
    return true;
  }
  function subset$1(values, other) {
    return superset$1(other, values);
  }
  function union$1(...others) {
    const set2 = /* @__PURE__ */ new Set();
    for (const other of others) {
      for (const o of other) {
        set2.add(o);
      }
    }
    return set2;
  }
  function targetDepth(d) {
    return d.target.depth;
  }
  function left(node) {
    return node.depth;
  }
  function right(node, n) {
    return n - 1 - node.height;
  }
  function justify(node, n) {
    return node.sourceLinks.length ? node.depth : n - 1;
  }
  function center(node) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min$2(node.sourceLinks, targetDepth) - 1 : 0;
  }
  function constant$2(x2) {
    return function () {
      return x2;
    };
  }
  function ascendingSourceBreadth(a2, b) {
    return ascendingBreadth(a2.source, b.source) || a2.index - b.index;
  }
  function ascendingTargetBreadth(a2, b) {
    return ascendingBreadth(a2.target, b.target) || a2.index - b.index;
  }
  function ascendingBreadth(a2, b) {
    return a2.y0 - b.y0;
  }
  function value(d) {
    return d.value;
  }
  function defaultId(d) {
    return d.index;
  }
  function defaultNodes(graph) {
    return graph.nodes;
  }
  function defaultLinks(graph) {
    return graph.links;
  }
  function find(nodeById, id) {
    const node = nodeById.get(id);
    if (!node) {throw new Error("missing: " + id);}
    return node;
  }
  function computeLinkBreadths({ nodes }) {
    for (const node of nodes) {
      let {y0} = node;
      let y1 = y0;
      for (const link2 of node.sourceLinks) {
        link2.y0 = y0 + link2.width / 2;
        y0 += link2.width;
      }
      for (const link2 of node.targetLinks) {
        link2.y1 = y1 + link2.width / 2;
        y1 += link2.width;
      }
    }
  }
  function Sankey() {
    let x0 = 0; let y0 = 0; let x1 = 1; let 
y1 = 1;
    let dx = 24;
    let dy = 8; let 
py;
    let id = defaultId;
    let align = justify;
    let sort2;
    let linkSort;
    let nodes = defaultNodes;
    let links = defaultLinks;
    let iterations = 6;
    function sankey() {
      const graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
      computeNodeLinks(graph);
      computeNodeValues(graph);
      computeNodeDepths(graph);
      computeNodeHeights(graph);
      computeNodeBreadths(graph);
      computeLinkBreadths(graph);
      return graph;
    }
    sankey.update = function (graph) {
      computeLinkBreadths(graph);
      return graph;
    };
    sankey.nodeId = function (_) {
      return arguments.length ? (id = typeof _ === 'function' ? _ : constant$2(_), sankey) : id;
    };
    sankey.nodeAlign = function (_) {
      return arguments.length ? (align = typeof _ === 'function' ? _ : constant$2(_), sankey) : align;
    };
    sankey.nodeSort = function (_) {
      return arguments.length ? (sort2 = _, sankey) : sort2;
    };
    sankey.nodeWidth = function (_) {
      return arguments.length ? (dx = +_, sankey) : dx;
    };
    sankey.nodePadding = function (_) {
      return arguments.length ? (dy = py = +_, sankey) : dy;
    };
    sankey.nodes = function (_) {
      return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant$2(_), sankey) : nodes;
    };
    sankey.links = function (_) {
      return arguments.length ? (links = typeof _ === 'function' ? _ : constant$2(_), sankey) : links;
    };
    sankey.linkSort = function (_) {
      return arguments.length ? (linkSort = _, sankey) : linkSort;
    };
    sankey.size = function (_) {
      return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
    };
    sankey.extent = function (_) {
      return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
    };
    sankey.iterations = function (_) {
      return arguments.length ? (iterations = +_, sankey) : iterations;
    };
    function computeNodeLinks({ nodes: nodes2, links: links2 }) {
      for (const [i, node] of nodes2.entries()) {
        node.index = i;
        node.sourceLinks = [];
        node.targetLinks = [];
      }
      const nodeById = new Map(nodes2.map((d, i) => [id(d, i, nodes2), d]));
      for (const [i, link2] of links2.entries()) {
        link2.index = i;
        let { source, target } = link2;
        if (typeof source !== 'object') {source = link2.source = find(nodeById, source);}
        if (typeof target !== 'object') {target = link2.target = find(nodeById, target);}
        source.sourceLinks.push(link2);
        target.targetLinks.push(link2);
      }
      if (linkSort != null) {
        for (const { sourceLinks, targetLinks } of nodes2) {
          sourceLinks.sort(linkSort);
          targetLinks.sort(linkSort);
        }
      }
    }
    function computeNodeValues({ nodes: nodes2 }) {
      for (const node of nodes2) {
        node.value = node.fixedValue === void 0 ? Math.max(sum$2(node.sourceLinks, value), sum$2(node.targetLinks, value)) : node.fixedValue;
      }
    }
    function computeNodeDepths({ nodes: nodes2 }) {
      const n = nodes2.length;
      let current = new Set(nodes2);
      let next = /* @__PURE__ */ new Set();
      let x2 = 0;
      while (current.size) {
        for (const node of current) {
          node.depth = x2;
          for (const { target } of node.sourceLinks) {
            next.add(target);
          }
        }
        if (++x2 > n) {throw new Error("circular link");}
        current = next;
        next = /* @__PURE__ */ new Set();
      }
    }
    function computeNodeHeights({ nodes: nodes2 }) {
      const n = nodes2.length;
      let current = new Set(nodes2);
      let next = /* @__PURE__ */ new Set();
      let x2 = 0;
      while (current.size) {
        for (const node of current) {
          node.height = x2;
          for (const { source } of node.targetLinks) {
            next.add(source);
          }
        }
        if (++x2 > n) {throw new Error("circular link");}
        current = next;
        next = /* @__PURE__ */ new Set();
      }
    }
    function computeNodeLayers({ nodes: nodes2 }) {
      const x2 = max$2(nodes2, (d) => d.depth) + 1;
      const kx2 = (x1 - x0 - dx) / (x2 - 1);
      const columns = new Array(x2);
      for (const node of nodes2) {
        const i = Math.max(0, Math.min(x2 - 1, Math.floor(align.call(null, node, x2))));
        node.layer = i;
        node.x0 = x0 + i * kx2;
        node.x1 = node.x0 + dx;
        if (columns[i]) {columns[i].push(node);}
        else {columns[i] = [node];}
      }
      if (sort2) {for (const column of columns) {
          column.sort(sort2);
        }}
      return columns;
    }
    function initializeNodeBreadths(columns) {
      const ky2 = min$2(columns, (c2) => (y1 - y0 - (c2.length - 1) * py) / sum$2(c2, value));
      for (const nodes2 of columns) {
        let y2 = y0;
        for (const node of nodes2) {
          node.y0 = y2;
          node.y1 = y2 + node.value * ky2;
          y2 = node.y1 + py;
          for (const link2 of node.sourceLinks) {
            link2.width = link2.value * ky2;
          }
        }
        y2 = (y1 - y2 + py) / (nodes2.length + 1);
        for (let i = 0; i < nodes2.length; ++i) {
          const node = nodes2[i];
          node.y0 += y2 * (i + 1);
          node.y1 += y2 * (i + 1);
        }
        reorderLinks(nodes2);
      }
    }
    function computeNodeBreadths(graph) {
      const columns = computeNodeLayers(graph);
      py = Math.min(dy, (y1 - y0) / (max$2(columns, (c2) => c2.length) - 1));
      initializeNodeBreadths(columns);
      for (let i = 0; i < iterations; ++i) {
        const alpha = 0.99**i;
        const beta = Math.max(1 - alpha, (i + 1) / iterations);
        relaxRightToLeft(columns, alpha, beta);
        relaxLeftToRight(columns, alpha, beta);
      }
    }
    function relaxLeftToRight(columns, alpha, beta) {
      for (let i = 1, n = columns.length; i < n; ++i) {
        const column = columns[i];
        for (const target of column) {
          let y2 = 0;
          let w = 0;
          for (const { source, value: value2 } of target.targetLinks) {
            const v = value2 * (target.layer - source.layer);
            y2 += targetTop(source, target) * v;
            w += v;
          }
          if (!(w > 0)) {continue;}
          const dy2 = (y2 / w - target.y0) * alpha;
          target.y0 += dy2;
          target.y1 += dy2;
          reorderNodeLinks(target);
        }
        if (sort2 === void 0) {column.sort(ascendingBreadth);}
        resolveCollisions(column, beta);
      }
    }
    function relaxRightToLeft(columns, alpha, beta) {
      for (let n = columns.length, i = n - 2; i >= 0; --i) {
        const column = columns[i];
        for (const source of column) {
          let y2 = 0;
          let w = 0;
          for (const { target, value: value2 } of source.sourceLinks) {
            const v = value2 * (target.layer - source.layer);
            y2 += sourceTop(source, target) * v;
            w += v;
          }
          if (!(w > 0)) {continue;}
          const dy2 = (y2 / w - source.y0) * alpha;
          source.y0 += dy2;
          source.y1 += dy2;
          reorderNodeLinks(source);
        }
        if (sort2 === void 0) {column.sort(ascendingBreadth);}
        resolveCollisions(column, beta);
      }
    }
    function resolveCollisions(nodes2, alpha) {
      const i = nodes2.length >> 1;
      const subject = nodes2[i];
      resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
      resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
      resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
      resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
    }
    function resolveCollisionsTopToBottom(nodes2, y2, i, alpha) {
      for (; i < nodes2.length; ++i) {
        const node = nodes2[i];
        const dy2 = (y2 - node.y0) * alpha;
        if (dy2 > 1e-6) {node.y0 += dy2, node.y1 += dy2;}
        y2 = node.y1 + py;
      }
    }
    function resolveCollisionsBottomToTop(nodes2, y2, i, alpha) {
      for (; i >= 0; --i) {
        const node = nodes2[i];
        const dy2 = (node.y1 - y2) * alpha;
        if (dy2 > 1e-6) {node.y0 -= dy2, node.y1 -= dy2;}
        y2 = node.y0 - py;
      }
    }
    function reorderNodeLinks({ sourceLinks, targetLinks }) {
      if (linkSort === void 0) {
        for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
          sourceLinks2.sort(ascendingTargetBreadth);
        }
        for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
          targetLinks2.sort(ascendingSourceBreadth);
        }
      }
    }
    function reorderLinks(nodes2) {
      if (linkSort === void 0) {
        for (const { sourceLinks, targetLinks } of nodes2) {
          sourceLinks.sort(ascendingTargetBreadth);
          targetLinks.sort(ascendingSourceBreadth);
        }
      }
    }
    function targetTop(source, target) {
      let y2 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
      for (const { target: node, width } of source.sourceLinks) {
        if (node === target) {break;}
        y2 += width + py;
      }
      for (const { source: node, width } of target.targetLinks) {
        if (node === source) {break;}
        y2 -= width;
      }
      return y2;
    }
    function sourceTop(source, target) {
      let y2 = target.y0 - (target.targetLinks.length - 1) * py / 2;
      for (const { source: node, width } of target.targetLinks) {
        if (node === source) {break;}
        y2 += width + py;
      }
      for (const { target: node, width } of source.sourceLinks) {
        if (node === target) {break;}
        y2 -= width;
      }
      return y2;
    }
    return sankey;
  }
  let pi$1 = Math.PI; var tau$1 = 2 * pi$1; var epsilon$2 = 1e-6; var 
tauEpsilon = tau$1 - epsilon$2;
  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = '';
  }
  function path() {
    return new Path();
  }
  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo(x2, y2) {
      this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
    },
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo(x2, y2) {
      this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
    },
    quadraticCurveTo(x1, y1, x2, y2) {
      this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
    },
    bezierCurveTo(x1, y1, x2, y2, x3, y3) {
      this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
    },
    arcTo(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
      if (r < 0)
        throw new Error("negative radius: " + r);
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      } else if (!(l01_2 > epsilon$2))
        ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$2) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      } else {
        var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
        if (Math.abs(t01 - 1) > epsilon$2) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }
        this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc(x2, y2, r, a0, a1, ccw) {
      x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (r < 0)
        throw new Error("negative radius: " + r);
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      } else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) {
        this._ += "L" + x0 + "," + y0;
      }
      if (!r)
        return;
      if (da < 0)
        da = da % tau$1 + tau$1;
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      } else if (da > epsilon$2) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi$1) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
      }
    },
    rect(x2, y2, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
    },
    toString() {
      return this._;
    }
  };
  function constant$1(x2) {
    return function constant2() {
      return x2;
    };
  }
  let {abs} = Math;
  let {atan2} = Math;
  let {cos} = Math;
  let max$1 = Math.max;
  let min$1 = Math.min;
  let {sin} = Math;
  let {sqrt} = Math;
  let epsilon$1 = 1e-12;
  let pi = Math.PI;
  let halfPi = pi / 2;
  let tau = 2 * pi;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
  }
  function asin(x2) {
    return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
  }
  function arcInnerRadius(d) {
    return d.innerRadius;
  }
  function arcOuterRadius(d) {
    return d.outerRadius;
  }
  function arcStartAngle(d) {
    return d.startAngle;
  }
  function arcEndAngle(d) {
    return d.endAngle;
  }
  function arcPadAngle(d) {
    return d && d.padAngle;
  }
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    let x10 = x1 - x0; var y10 = y1 - y0; var x32 = x3 - x2; var y32 = y3 - y2; var 
t = y32 * x10 - x32 * y10;
    if (t * t < epsilon$1) {return;}
    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
    return [x0 + t * x10, y0 + t * y10];
  }
  function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
    let x01 = x0 - x1; var y01 = y0 - y1; var lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01); var ox = lo * y01; var oy = -lo * x01; var x11 = x0 + ox; var y11 = y0 + oy; var x10 = x1 + ox; var y10 = y1 + oy; var x00 = (x11 + x10) / 2; var y00 = (y11 + y10) / 2; var dx = x10 - x11; var dy = y10 - y11; var d2 = dx * dx + dy * dy; var r = r1 - rc; var D = x11 * y10 - x10 * y11; var d = (dy < 0 ? -1 : 1) * sqrt(max$1(0, r * r * d2 - D * D)); var cx0 = (D * dy - dx * d) / d2; var cy0 = (-D * dx - dy * d) / d2; var cx1 = (D * dy + dx * d) / d2; var cy1 = (-D * dx + dy * d) / d2; var dx0 = cx0 - x00; var dy0 = cy0 - y00; var dx1 = cx1 - x00; var 
dy1 = cy1 - y00;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {cx0 = cx1, cy0 = cy1;}
    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1),
    };
  }
  function arc() {
    let innerRadius = arcInnerRadius; var outerRadius = arcOuterRadius; var cornerRadius = constant$1(0); var padRadius = null; var startAngle = arcStartAngle; var endAngle = arcEndAngle; var padAngle = arcPadAngle; var 
context = null;
    function arc2() {
      let buffer; var r; var r0 = +innerRadius.apply(this, arguments); var r1 = +outerRadius.apply(this, arguments); var a0 = startAngle.apply(this, arguments) - halfPi; var a1 = endAngle.apply(this, arguments) - halfPi; var da = abs(a1 - a0); var 
cw = a1 > a0;
      if (!context) {context = buffer = path();}
      if (r1 < r0) {r = r1, r1 = r0, r0 = r;}
      if (!(r1 > epsilon$1)) {context.moveTo(0, 0);}
      else if (da > tau - epsilon$1) {
        context.moveTo(r1 * cos(a0), r1 * sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$1) {
          context.moveTo(r0 * cos(a1), r0 * sin(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      } else {
        let a01 = a0; var a11 = a1; var a00 = a0; var a10 = a1; var da0 = da; var da1 = da; var ap = padAngle.apply(this, arguments) / 2; var rp = ap > epsilon$1 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)); var rc = min$1(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)); var rc0 = rc; var rc1 = rc; var t0; var 
t1;
        if (rp > epsilon$1) {
          let p0 = asin(rp / r0 * sin(ap)); var 
p1 = asin(rp / r1 * sin(ap));
          if ((da0 -= p0 * 2) > epsilon$1) {p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;}
          else {da0 = 0, a00 = a10 = (a0 + a1) / 2;}
          if ((da1 -= p1 * 2) > epsilon$1) {p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;}
          else {da1 = 0, a01 = a11 = (a0 + a1) / 2;}
        }
        let x01 = r1 * cos(a01); var y01 = r1 * sin(a01); var x10 = r0 * cos(a10); var 
y10 = r0 * sin(a10);
        if (rc > epsilon$1) {
          var x11 = r1 * cos(a11); var y11 = r1 * sin(a11); var x00 = r0 * cos(a00); var y00 = r0 * sin(a00); var 
oc;
          if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
            let ax = x01 - oc[0]; var ay = y01 - oc[1]; var bx = x11 - oc[0]; var by = y11 - oc[1]; var kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2); var 
lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min$1(rc, (r0 - lc) / (kc - 1));
            rc1 = min$1(rc, (r1 - lc) / (kc + 1));
          }
        }
        if (!(da1 > epsilon$1)) {context.moveTo(x01, y01);}
        else if (rc1 > epsilon$1) {
          t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
          t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
          context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
          if (rc1 < rc) {context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);}
          else {
            context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
            context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
            context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
          }
        } else {context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);}
        if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) {context.lineTo(x10, y10);}
        else if (rc0 > epsilon$1) {
          t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
          t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
          context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
          if (rc0 < rc) {context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);}
          else {
            context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
            context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
            context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
          }
        } else {context.arc(0, 0, r0, a10, a00, cw);}
      }
      context.closePath();
      if (buffer) {return context = null, buffer + "" || null;}
    }
    arc2.centroid = function () {
      let r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2; var 
a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
      return [cos(a2) * r, sin(a2) * r];
    };
    arc2.innerRadius = function (_) {
      return arguments.length ? (innerRadius = typeof _ === 'function' ? _ : constant$1(+_), arc2) : innerRadius;
    };
    arc2.outerRadius = function (_) {
      return arguments.length ? (outerRadius = typeof _ === 'function' ? _ : constant$1(+_), arc2) : outerRadius;
    };
    arc2.cornerRadius = function (_) {
      return arguments.length ? (cornerRadius = typeof _ === 'function' ? _ : constant$1(+_), arc2) : cornerRadius;
    };
    arc2.padRadius = function (_) {
      return arguments.length ? (padRadius = _ == null ? null : typeof _ === 'function' ? _ : constant$1(+_), arc2) : padRadius;
    };
    arc2.startAngle = function (_) {
      return arguments.length ? (startAngle = typeof _ === 'function' ? _ : constant$1(+_), arc2) : startAngle;
    };
    arc2.endAngle = function (_) {
      return arguments.length ? (endAngle = typeof _ === 'function' ? _ : constant$1(+_), arc2) : endAngle;
    };
    arc2.padAngle = function (_) {
      return arguments.length ? (padAngle = typeof _ === 'function' ? _ : constant$1(+_), arc2) : padAngle;
    };
    arc2.context = function (_) {
      return arguments.length ? (context = _ == null ? null : _, arc2) : context;
    };
    return arc2;
  }
  function Linear(context) {
    this._context = context;
  }
  Linear.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._point = 0;
    },
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(x2, y2);
          break;
      }
    }
  };
  function curveLinear(context) {
    return new Linear(context);
  }
  function x(p) {
    return p[0];
  }
  function y(p) {
    return p[1];
  }
  function line() {
    let x$1 = x; var y$1 = y; var defined = constant$1(true); var context = null; var curve = curveLinear; var 
output = null;
    function line2(data) {
      let i; var n = data.length; var d; var defined0 = false; var 
buffer;
      if (context == null) {output = curve(buffer = path());}
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) {output.lineStart();}
          else {output.lineEnd();}
        }
        if (defined0) {output.point(+x$1(d, i, data), +y$1(d, i, data));}
      }
      if (buffer) {return output = null, buffer + "" || null;}
    }
    line2.x = function (_) {
      return arguments.length ? (x$1 = typeof _ === 'function' ? _ : constant$1(+_), line2) : x$1;
    };
    line2.y = function (_) {
      return arguments.length ? (y$1 = typeof _ === 'function' ? _ : constant$1(+_), line2) : y$1;
    };
    line2.defined = function (_) {
      return arguments.length ? (defined = typeof _ === 'function' ? _ : constant$1(!!_), line2) : defined;
    };
    line2.curve = function (_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
    };
    line2.context = function (_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
    };
    return line2;
  }
  function area$1() {
    let x0 = x; var x1 = null; var y0 = constant$1(0); var y1 = y; var defined = constant$1(true); var context = null; var curve = curveLinear; var 
output = null;
    function area2(data) {
      let i; var j; var k2; var n = data.length; var d; var defined0 = false; var buffer; var x0z = new Array(n); var 
y0z = new Array(n);
      if (context == null) {output = curve(buffer = path());}
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) {
            j = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k2 = i - 1; k2 >= j; --k2) {
              output.point(x0z[k2], y0z[k2]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
          output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
        }
      }
      if (buffer) {return output = null, buffer + "" || null;}
    }
    function arealine() {
      return line().defined(defined).curve(curve).context(context);
    }
    area2.x = function (_) {
      return arguments.length ? (x0 = typeof _ === 'function' ? _ : constant$1(+_), x1 = null, area2) : x0;
    };
    area2.x0 = function (_) {
      return arguments.length ? (x0 = typeof _ === 'function' ? _ : constant$1(+_), area2) : x0;
    };
    area2.x1 = function (_) {
      return arguments.length ? (x1 = _ == null ? null : typeof _ === 'function' ? _ : constant$1(+_), area2) : x1;
    };
    area2.y = function (_) {
      return arguments.length ? (y0 = typeof _ === 'function' ? _ : constant$1(+_), y1 = null, area2) : y0;
    };
    area2.y0 = function (_) {
      return arguments.length ? (y0 = typeof _ === 'function' ? _ : constant$1(+_), area2) : y0;
    };
    area2.y1 = function (_) {
      return arguments.length ? (y1 = _ == null ? null : typeof _ === 'function' ? _ : constant$1(+_), area2) : y1;
    };
    area2.lineX0 = area2.lineY0 = function () {
      return arealine().x(x0).y(y0);
    };
    area2.lineY1 = function () {
      return arealine().x(x0).y(y1);
    };
    area2.lineX1 = function () {
      return arealine().x(x1).y(y0);
    };
    area2.defined = function (_) {
      return arguments.length ? (defined = typeof _ === 'function' ? _ : constant$1(!!_), area2) : defined;
    };
    area2.curve = function (_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
    };
    area2.context = function (_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
    };
    return area2;
  }
  function descending$2(a2, b) {
    return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
  }
  function identity$1(d) {
    return d;
  }
  function pie$1() {
    let value2 = identity$1; var sortValues = descending$2; var sort2 = null; var startAngle = constant$1(0); var endAngle = constant$1(tau); var 
padAngle = constant$1(0);
    function pie2(data) {
      let i; var n = data.length; var j; var k2; var sum2 = 0; var index2 = new Array(n); var arcs = new Array(n); var a0 = +startAngle.apply(this, arguments); var da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)); var a1; var p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)); var pa = p * (da < 0 ? -1 : 1); var 
v;
      for (i = 0; i < n; ++i) {
        if ((v = arcs[index2[i] = i] = +value2(data[i], i, data)) > 0) {
          sum2 += v;
        }
      }
      if (sortValues != null) {index2.sort(function(i2, j2) {
          return sortValues(arcs[i2], arcs[j2]);
        });}
      else if (sort2 != null) {index2.sort(function(i2, j2) {
          return sort2(data[i2], data[j2]);
        });}
      for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
        j = index2[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
          data: data[j],
          index: i,
          value: v,
          startAngle: a0,
          endAngle: a1,
          padAngle: p,
        };
      }
      return arcs;
    }
    pie2.value = function (_) {
      return arguments.length ? (value2 = typeof _ === 'function' ? _ : constant$1(+_), pie2) : value2;
    };
    pie2.sortValues = function (_) {
      return arguments.length ? (sortValues = _, sort2 = null, pie2) : sortValues;
    };
    pie2.sort = function (_) {
      return arguments.length ? (sort2 = _, sortValues = null, pie2) : sort2;
    };
    pie2.startAngle = function (_) {
      return arguments.length ? (startAngle = typeof _ === 'function' ? _ : constant$1(+_), pie2) : startAngle;
    };
    pie2.endAngle = function (_) {
      return arguments.length ? (endAngle = typeof _ === 'function' ? _ : constant$1(+_), pie2) : endAngle;
    };
    pie2.padAngle = function (_) {
      return arguments.length ? (padAngle = typeof _ === 'function' ? _ : constant$1(+_), pie2) : padAngle;
    };
    return pie2;
  }
  let curveRadialLinear = curveRadial$1(curveLinear);
  function Radial(curve) {
    this._curve = curve;
  }
  Radial.prototype = {
    areaStart() {
      this._curve.areaStart();
    },
    areaEnd() {
      this._curve.areaEnd();
    },
    lineStart() {
      this._curve.lineStart();
    },
    lineEnd() {
      this._curve.lineEnd();
    },
    point(a2, r) {
      this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
    }
  };
  function curveRadial$1(curve) {
    function radial(context) {
      return new Radial(curve(context));
    }
    radial._curve = curve;
    return radial;
  }
  function lineRadial(l) {
    let c2 = l.curve;
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    l.curve = function (_) {
      return arguments.length ? c2(curveRadial$1(_)) : c2()._curve;
    };
    return l;
  }
  function lineRadial$1() {
    return lineRadial(line().curve(curveRadialLinear));
  }
  function areaRadial() {
    let a2 = area$1().curve(curveRadialLinear); var c2 = a2.curve; var x0 = a2.lineX0; var x1 = a2.lineX1; var y0 = a2.lineY0; var 
y1 = a2.lineY1;
    a2.angle = a2.x, delete a2.x;
    a2.startAngle = a2.x0, delete a2.x0;
    a2.endAngle = a2.x1, delete a2.x1;
    a2.radius = a2.y, delete a2.y;
    a2.innerRadius = a2.y0, delete a2.y0;
    a2.outerRadius = a2.y1, delete a2.y1;
    a2.lineStartAngle = function () {
      return lineRadial(x0());
    }, delete a2.lineX0;
    a2.lineEndAngle = function () {
      return lineRadial(x1());
    }, delete a2.lineX1;
    a2.lineInnerRadius = function () {
      return lineRadial(y0());
    }, delete a2.lineY0;
    a2.lineOuterRadius = function () {
      return lineRadial(y1());
    }, delete a2.lineY1;
    a2.curve = function (_) {
      return arguments.length ? c2(curveRadial$1(_)) : c2()._curve;
    };
    return a2;
  }
  function pointRadial(x2, y2) {
    return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
  }
  let slice$1 = Array.prototype.slice;
  function linkSource(d) {
    return d.source;
  }
  function linkTarget(d) {
    return d.target;
  }
  function link(curve) {
    let source = linkSource; var target = linkTarget; var x$1 = x; var y$1 = y; var 
context = null;
    function link2() {
      let buffer; var argv = slice$1.call(arguments); var s2 = source.apply(this, argv); var 
t = target.apply(this, argv);
      if (!context) {context = buffer = path();}
      curve(context, +x$1.apply(this, (argv[0] = s2, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
      if (buffer) {return context = null, buffer + "" || null;}
    }
    link2.source = function (_) {
      return arguments.length ? (source = _, link2) : source;
    };
    link2.target = function (_) {
      return arguments.length ? (target = _, link2) : target;
    };
    link2.x = function (_) {
      return arguments.length ? (x$1 = typeof _ === 'function' ? _ : constant$1(+_), link2) : x$1;
    };
    link2.y = function (_) {
      return arguments.length ? (y$1 = typeof _ === 'function' ? _ : constant$1(+_), link2) : y$1;
    };
    link2.context = function (_) {
      return arguments.length ? (context = _ == null ? null : _, link2) : context;
    };
    return link2;
  }
  function curveHorizontal(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
  }
  function curveVertical(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
  }
  function curveRadial(context, x0, y0, x1, y1) {
    let p0 = pointRadial(x0, y0); var p1 = pointRadial(x0, y0 = (y0 + y1) / 2); var p2 = pointRadial(x1, y0); var 
p3 = pointRadial(x1, y1);
    context.moveTo(p0[0], p0[1]);
    context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
  }
  function linkHorizontal() {
    return link(curveHorizontal);
  }
  function linkVertical() {
    return link(curveVertical);
  }
  function linkRadial() {
    let l = link(curveRadial);
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    return l;
  }
  const circle = {
    draw(context, size) {
      var r = Math.sqrt(size / pi);
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, tau);
    }
  };
  const cross$3 = {
    draw(context, size) {
      var r = Math.sqrt(size / 5) / 2;
      context.moveTo(-3 * r, -r);
      context.lineTo(-r, -r);
      context.lineTo(-r, -3 * r);
      context.lineTo(r, -3 * r);
      context.lineTo(r, -r);
      context.lineTo(3 * r, -r);
      context.lineTo(3 * r, r);
      context.lineTo(r, r);
      context.lineTo(r, 3 * r);
      context.lineTo(-r, 3 * r);
      context.lineTo(-r, r);
      context.lineTo(-3 * r, r);
      context.closePath();
    }
  };
  let tan30 = Math.sqrt(1 / 3); var 
tan30_2 = tan30 * 2;
  const diamond = {
    draw(context, size) {
      var y2 = Math.sqrt(size / tan30_2), x2 = y2 * tan30;
      context.moveTo(0, -y2);
      context.lineTo(x2, 0);
      context.lineTo(0, y2);
      context.lineTo(-x2, 0);
      context.closePath();
    }
  };
  let ka = 0.8908130915292852; var kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10); var kx = Math.sin(tau / 10) * kr; var 
ky = -Math.cos(tau / 10) * kr;
  const star = {
    draw(context, size) {
      var r = Math.sqrt(size * ka), x2 = kx * r, y2 = ky * r;
      context.moveTo(0, -r);
      context.lineTo(x2, y2);
      for (var i = 1; i < 5; ++i) {
        var a2 = tau * i / 5, c2 = Math.cos(a2), s2 = Math.sin(a2);
        context.lineTo(s2 * r, -c2 * r);
        context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
      }
      context.closePath();
    }
  };
  const square = {
    draw(context, size) {
      var w = Math.sqrt(size), x2 = -w / 2;
      context.rect(x2, x2, w, w);
    }
  };
  let sqrt3 = Math.sqrt(3);
  const triangle = {
    draw(context, size) {
      var y2 = -Math.sqrt(size / (sqrt3 * 3));
      context.moveTo(0, y2 * 2);
      context.lineTo(-sqrt3 * y2, -y2);
      context.lineTo(sqrt3 * y2, -y2);
      context.closePath();
    }
  };
  let c = -0.5; var s = Math.sqrt(3) / 2; var k = 1 / Math.sqrt(12); var 
a = (k / 2 + 1) * 3;
  const wye = {
    draw(context, size) {
      var r = Math.sqrt(size / a), x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
      context.lineTo(x2, y2);
      context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
      context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
      context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
      context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
      context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
      context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
      context.closePath();
    }
  };
  let symbols = [
    circle,
    cross$3,
    diamond,
    square,
    star,
    triangle,
    wye,
  ];
  function symbol() {
    let type = constant$1(circle); var size = constant$1(64); var 
context = null;
    function symbol2() {
      let buffer;
      if (!context) {context = buffer = path();}
      type.apply(this, arguments).draw(context, +size.apply(this, arguments));
      if (buffer) {return context = null, buffer + "" || null;}
    }
    symbol2.type = function (_) {
      return arguments.length ? (type = typeof _ === 'function' ? _ : constant$1(_), symbol2) : type;
    };
    symbol2.size = function (_) {
      return arguments.length ? (size = typeof _ === 'function' ? _ : constant$1(+_), symbol2) : size;
    };
    symbol2.context = function (_) {
      return arguments.length ? (context = _ == null ? null : _, symbol2) : context;
    };
    return symbol2;
  }
  function noop$1() {
  }
  function point$3(that, x2, y2) {
    that._context.bezierCurveTo(
      (2 * that._x0 + that._x1) / 3,
      (2 * that._y0 + that._y1) / 3,
      (that._x0 + 2 * that._x1) / 3,
      (that._y0 + 2 * that._y1) / 3,
      (that._x0 + 4 * that._x1 + x2) / 6,
      (that._y0 + 4 * that._y1 + y2) / 6
    );
  }
  function Basis(context) {
    this._context = context;
  }
  Basis.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd() {
      switch (this._point) {
        case 3:
          point$3(this, this._x1, this._y1);
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function basis(context) {
    return new Basis(context);
  }
  function BasisClosed(context) {
    this._context = context;
  }
  BasisClosed.prototype = {
    areaStart: noop$1,
    areaEnd: noop$1,
    lineStart() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
      this._point = 0;
    },
    lineEnd() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x2 = x2, this._y2 = y2;
          break;
        case 1:
          this._point = 2;
          this._x3 = x2, this._y3 = y2;
          break;
        case 2:
          this._point = 3;
          this._x4 = x2, this._y4 = y2;
          this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
          break;
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function basisClosed(context) {
    return new BasisClosed(context);
  }
  function BasisOpen(context) {
    this._context = context;
  }
  BasisOpen.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 3)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
          this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
          break;
        case 3:
          this._point = 4;
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function basisOpen(context) {
    return new BasisOpen(context);
  }
  function Bundle(context, beta) {
    this._basis = new Basis(context);
    this._beta = beta;
  }
  Bundle.prototype = {
    lineStart() {
      this._x = [];
      this._y = [];
      this._basis.lineStart();
    },
    lineEnd() {
      var x2 = this._x, y2 = this._y, j = x2.length - 1;
      if (j > 0) {
        var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
        while (++i <= j) {
          t = i / j;
          this._basis.point(
            this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
            this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
          );
        }
      }
      this._x = this._y = null;
      this._basis.lineEnd();
    },
    point(x2, y2) {
      this._x.push(+x2);
      this._y.push(+y2);
    }
  };
  const bundle = (function custom(beta) {
    function bundle2(context) {
      return beta === 1 ? new Basis(context) : new Bundle(context, beta);
    }
    bundle2.beta = function(beta2) {
      return custom(+beta2);
    };
    return bundle2;
  }(0.85));
  function point$2(that, x2, y2) {
    that._context.bezierCurveTo(
      that._x1 + that._k * (that._x2 - that._x0),
      that._y1 + that._k * (that._y2 - that._y0),
      that._x2 + that._k * (that._x1 - x2),
      that._y2 + that._k * (that._y1 - y2),
      that._x2,
      that._y2
    );
  }
  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  Cardinal.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          point$2(this, this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          this._x1 = x2, this._y1 = y2;
          break;
        case 2:
          this._point = 3;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinal = (function custom(tension) {
    function cardinal2(context) {
      return new Cardinal(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0));
  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalClosed.prototype = {
    areaStart: noop$1,
    areaEnd: noop$1,
    lineStart() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x2, this._y3 = y2;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x2, this._y4 = y2);
          break;
        case 2:
          this._point = 3;
          this._x5 = x2, this._y5 = y2;
          break;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinalClosed = (function custom(tension) {
    function cardinal2(context) {
      return new CardinalClosed(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0));
  function CardinalOpen(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalOpen.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 3)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinalOpen = (function custom(tension) {
    function cardinal2(context) {
      return new CardinalOpen(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0));
  function point$1(that, x2, y2) {
    let x1 = that._x1; var y1 = that._y1; var x22 = that._x2; var 
y22 = that._y2;
    if (that._l01_a > epsilon$1) {
      let a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a; var 
n = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
      y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
    }
    if (that._l23_a > epsilon$1) {
      let b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a; var 
m = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
      y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
    }
    that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
  }
  function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRom.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        default:
          point$1(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRom = (function custom(alpha) {
    function catmullRom2(context) {
      return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
    }
    catmullRom2.alpha = function(alpha2) {
      return custom(+alpha2);
    };
    return catmullRom2;
  }(0.5));
  function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomClosed.prototype = {
    areaStart: noop$1,
    areaEnd: noop$1,
    lineStart() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x2, this._y3 = y2;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x2, this._y4 = y2);
          break;
        case 2:
          this._point = 3;
          this._x5 = x2, this._y5 = y2;
          break;
        default:
          point$1(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRomClosed = (function custom(alpha) {
    function catmullRom2(context) {
      return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
    }
    catmullRom2.alpha = function(alpha2) {
      return custom(+alpha2);
    };
    return catmullRom2;
  }(0.5));
  function CatmullRomOpen(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomOpen.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 3)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          point$1(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRomOpen = (function custom(alpha) {
    function catmullRom2(context) {
      return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
    }
    catmullRom2.alpha = function(alpha2) {
      return custom(+alpha2);
    };
    return catmullRom2;
  }(0.5));
  function LinearClosed(context) {
    this._context = context;
  }
  LinearClosed.prototype = {
    areaStart: noop$1,
    areaEnd: noop$1,
    lineStart() {
      this._point = 0;
    },
    lineEnd() {
      if (this._point)
        this._context.closePath();
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point)
        this._context.lineTo(x2, y2);
      else
        this._point = 1, this._context.moveTo(x2, y2);
    }
  };
  function linearClosed(context) {
    return new LinearClosed(context);
  }
  function sign(x2) {
    return x2 < 0 ? -1 : 1;
  }
  function slope3(that, x2, y2) {
    let h0 = that._x1 - that._x0; var h1 = x2 - that._x1; var s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0); var s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0); var 
p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }
  function slope2(that, t) {
    let h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }
  function point(that, t0, t1) {
    let x0 = that._x0; var y0 = that._y0; var x1 = that._x1; var y1 = that._y1; var 
dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
  }
  function MonotoneX(context) {
    this._context = context;
  }
  MonotoneX.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
      this._point = 0;
    },
    lineEnd() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          point(this, this._t0, slope2(this, this._t0));
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point(x2, y2) {
      var t1 = NaN;
      x2 = +x2, y2 = +y2;
      if (x2 === this._x1 && y2 === this._y1)
        return;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          point(this, slope2(this, t1 = slope3(this, x2, y2)), t1);
          break;
        default:
          point(this, this._t0, t1 = slope3(this, x2, y2));
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
      this._t0 = t1;
    }
  };
  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }
  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x2, y2) {
    MonotoneX.prototype.point.call(this, y2, x2);
  };
  function ReflectContext(context) {
    this._context = context;
  }
  ReflectContext.prototype = {
    moveTo(x2, y2) {
      this._context.moveTo(y2, x2);
    },
    closePath() {
      this._context.closePath();
    },
    lineTo(x2, y2) {
      this._context.lineTo(y2, x2);
    },
    bezierCurveTo(x1, y1, x2, y2, x3, y3) {
      this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
    }
  };
  function monotoneX(context) {
    return new MonotoneX(context);
  }
  function monotoneY(context) {
    return new MonotoneY(context);
  }
  function Natural(context) {
    this._context = context;
  }
  Natural.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x = [];
      this._y = [];
    },
    lineEnd() {
      var x2 = this._x, y2 = this._y, n = x2.length;
      if (n) {
        this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
        if (n === 2) {
          this._context.lineTo(x2[1], y2[1]);
        } else {
          var px = controlPoints(x2), py = controlPoints(y2);
          for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
            this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
          }
        }
      }
      if (this._line || this._line !== 0 && n === 1)
        this._context.closePath();
      this._line = 1 - this._line;
      this._x = this._y = null;
    },
    point(x2, y2) {
      this._x.push(+x2);
      this._y.push(+y2);
    }
  };
  function controlPoints(x2) {
    let i; var n = x2.length - 1; var m; var a2 = new Array(n); var b = new Array(n); var 
r = new Array(n);
    a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
    for (i = 1; i < n - 1; ++i) {a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];}
    a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
    for (i = 1; i < n; ++i) {m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];}
    a2[n - 1] = r[n - 1] / b[n - 1];
    for (i = n - 2; i >= 0; --i) {a2[i] = (r[i] - a2[i + 1]) / b[i];}
    b[n - 1] = (x2[n] + a2[n - 1]) / 2;
    for (i = 0; i < n - 1; ++i) {b[i] = 2 * x2[i + 1] - a2[i + 1];}
    return [a2, b];
  }
  function natural(context) {
    return new Natural(context);
  }
  function Step(context, t) {
    this._context = context;
    this._t = t;
  }
  Step.prototype = {
    areaStart() {
      this._line = 0;
    },
    areaEnd() {
      this._line = NaN;
    },
    lineStart() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd() {
      if (0 < this._t && this._t < 1 && this._point === 2)
        this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      if (this._line >= 0)
        this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y2);
            this._context.lineTo(x2, y2);
          } else {
            var x1 = this._x * (1 - this._t) + x2 * this._t;
            this._context.lineTo(x1, this._y);
            this._context.lineTo(x1, y2);
          }
          break;
        }
      }
      this._x = x2, this._y = y2;
    }
  };
  function step(context) {
    return new Step(context, 0.5);
  }
  function stepBefore(context) {
    return new Step(context, 0);
  }
  function stepAfter(context) {
    return new Step(context, 1);
  }
  function none$1(series, order) {
    if (!((n = series.length) > 1)) {return;}
    for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order[i]];
      for (j = 0; j < m; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  }
  function none(series) {
    let n = series.length; var 
o = new Array(n);
    while (--n >= 0) {o[n] = n;}
    return o;
  }
  function stackValue(d, key) {
    return d[key];
  }
  function stack() {
    let keys = constant$1([]); var order = none; var offset = none$1; var 
value2 = stackValue;
    function stack2(data) {
      let kz = keys.apply(this, arguments); var i; var m = data.length; var n = kz.length; var sz = new Array(n); var 
oz;
      for (i = 0; i < n; ++i) {
        for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
          si[j] = sij = [0, +value2(data[j], ki, j, data)];
          sij.data = data[j];
        }
        si.key = ki;
      }
      for (i = 0, oz = order(sz); i < n; ++i) {
        sz[oz[i]].index = i;
      }
      offset(sz, oz);
      return sz;
    }
    stack2.keys = function (_) {
      return arguments.length ? (keys = typeof _ === 'function' ? _ : constant$1(slice$1.call(_)), stack2) : keys;
    };
    stack2.value = function (_) {
      return arguments.length ? (value2 = typeof _ === 'function' ? _ : constant$1(+_), stack2) : value2;
    };
    stack2.order = function (_) {
      return arguments.length ? (order = _ == null ? none : typeof _ === 'function' ? _ : constant$1(slice$1.call(_)), stack2) : order;
    };
    stack2.offset = function (_) {
      return arguments.length ? (offset = _ == null ? none$1 : _, stack2) : offset;
    };
    return stack2;
  }
  function expand(series, order) {
    if (!((n = series.length) > 0)) {return;}
    for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
      for (y2 = i = 0; i < n; ++i) {y2 += series[i][j][1] || 0;}
      if (y2) {for (i = 0; i < n; ++i)
          series[i][j][1] /= y2;}
    }
    none$1(series, order);
  }
  function diverging(series, order) {
    if (!((n = series.length) > 0)) {return;}
    for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
      for (yp = yn = 0, i = 0; i < n; ++i) {
        if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
          d[0] = yp, d[1] = yp += dy;
        } else if (dy < 0) {
          d[1] = yn, d[0] = yn += dy;
        } else {
          d[0] = 0, d[1] = dy;
        }
      }
    }
  }
  function silhouette(series, order) {
    if (!((n = series.length) > 0)) {return;}
    for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
      for (var i = 0, y2 = 0; i < n; ++i) {y2 += series[i][j][1] || 0;}
      s0[j][1] += s0[j][0] = -y2 / 2;
    }
    none$1(series, order);
  }
  function wiggle(series, order) {
    if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) {return;}
    for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
      for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
        let si = series[order[i]]; var sij0 = si[j][1] || 0; var sij1 = si[j - 1][1] || 0; var 
s3 = (sij0 - sij1) / 2;
        for (let k2 = 0; k2 < i; ++k2) {
          let sk = series[order[k2]]; var skj0 = sk[j][1] || 0; var 
skj1 = sk[j - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j - 1][1] += s0[j - 1][0] = y2;
      if (s1) {y2 -= s2 / s1;}
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    none$1(series, order);
  }
  function appearance(series) {
    let peaks = series.map(peak);
    return none(series).sort((a2, b) => {
      return peaks[a2] - peaks[b];
    });
  }
  function peak(series) {
    let i = -1; var j = 0; var n = series.length; var vi; var 
vj = -Infinity;
    while (++i < n) {if ((vi = +series[i][1]) > vj)
        vj = vi, j = i;}
    return j;
  }
  function ascending$1(series) {
    let sums = series.map(sum$1);
    return none(series).sort((a2, b) => {
      return sums[a2] - sums[b];
    });
  }
  function sum$1(series) {
    let s2 = 0; var i = -1; var n = series.length; var 
v;
    while (++i < n) {if (v = +series[i][1])
        s2 += v;}
    return s2;
  }
  function descending$1(series) {
    return ascending$1(series).reverse();
  }
  function insideOut(series) {
    let n = series.length; var i; var j; var sums = series.map(sum$1); var order = appearance(series); var top = 0; var bottom = 0; var tops = []; var 
bottoms = [];
    for (i = 0; i < n; ++i) {
      j = order[i];
      if (top < bottom) {
        top += sums[j];
        tops.push(j);
      } else {
        bottom += sums[j];
        bottoms.push(j);
      }
    }
    return bottoms.reverse().concat(tops);
  }
  function reverse$1(series) {
    return none(series).reverse();
  }
  function horizontalSource(d) {
    return [d.source.x1, d.y0];
  }
  function horizontalTarget(d) {
    return [d.target.x0, d.y1];
  }
  function sankeyLinkHorizontal() {
    return linkHorizontal().source(horizontalSource).target(horizontalTarget);
  }
  function createSankeyDiagram(data, options, chartComponents) {
    const {
      width,
      height,
      nodeWidth,
      nodePadding,
    } = options;
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const { svg } = chartComponents;
    svg.append('g');
    const sankey = Sankey().nodeWidth(nodeWidth).nodePadding(nodePadding).extent([[1, 1], [width - 1, height - 5]]);
    const { nodes, links } = sankey(data);
    svg.append('g').selectAll('rect').data(nodes).join('rect')
.attr('x', (d) => d.x0)
.attr('y', (d) => d.y0)
.attr('height', (d) => d.y1 - d.y0)
.attr('width', (d) => d.x1 - d.x0)
.attr('fill', (d) => color(d.index))
.attr('stroke', `${options.strokeColor}`);
    svg.append('g').selectAll('text').data(nodes).join('text')
.attr('x', (d) => d.x0 - 6)
.attr('y', (d) => (d.y1 + d.y0) / 2)
.attr('dy', '0.35em')
.attr('text-anchor', `${options.textAnchor}`)
.text((d) => d.name)
.style('font-size', '12px')
.style('fill', '#000')
.filter((d) => d.x0 < width / 2)
.attr('x', (d) => d.x1 + 6)
.attr('text-anchor', 'start');
    svg.append('g').selectAll('path').data(links).join('path')
.attr('d', sankeyLinkHorizontal())
.attr('fill', 'none')
.attr('stroke', (d) => color(d.source.index))
.attr('stroke-opacity', 0.5)
.attr('stroke-width', (d) => Math.max(1, d.width));
  }
  function createD3ScatterPlot(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    svg.append('g').selectAll('circle').data(data).join('circle')
.attr('cx', (d) => x2(d.x))
.attr('cy', (d) => y2(d.y))
.attr('r', options.radius)
.attr('fill', `${options.color}`);
  }
  function createD3StackedBarChart(data, options, chartComponents) {
    const {
      x: x2,
      y: y2,
      svg,
    } = chartComponents;
    const color = d3.scaleOrdinal().domain(data[0].values.map((v) => v.group)).range(options.color);
    const stack2 = d3.stack().keys(data[0].values.map((v) => v.group)).value((d, key) => d.find((v) => v.group === key).value);
    const bars = svg.append('g').selectAll('g').data(stack2(data.map((d) => d.values))).join('g')
.attr('fill', (d) => color(d.key));
    bars.selectAll('rect').data((d) => d).join('rect').attr('x', (d, i) => x2(data[i].category))
.attr('y', (d) => y2(d[1]))
.attr('height', (d) => y2(d[0]) - y2(d[1]))
.attr('width', x2.bandwidth());
  }
  function createD3SunburstChart(data, options, chartComponents) {
    const color = d3.scaleOrdinal(options.colorScheme);
    const {
      width,
      height,
      margin,
      radius,
    } = options;
    const { svg } = chartComponents;
    const partition = (data2) => {
      const root = d3.hierarchy(data2).sum((d) => d.value).sort((a2, b) => b.value - a2.value);
      return d3.partition().size([2 * Math.PI, root.height + 1])(root);
    };
    const arc2 = d3.arc().startAngle((d) => d.x0).endAngle((d) => d.x1).padAngle((d) => Math.min((d.x1 - d.x0) / 2, 5e-3))
.padRadius(radius * 1.5)
.innerRadius((d) => d.y0 * radius)
.outerRadius((d) => Math.max(d.y0 * radius, d.y1 * radius - 1));
    const g = svg.append('g').attr('transform', `translate(${width / 2},${height / 2})`);
    const nodes = g.selectAll('path').data(partition(data).descendants()).enter().append('path')
.attr('fill', (d) => {
      while (d.depth > 1) {d = d.parent;}
      return color(d.data.name);
    })
.attr('fill-opacity', (d) => (d.children ? 0.6 : 0.4))
.attr('d', arc2)
.on('click', (event2, d) => {
    });
    g.selectAll('text').data(partition(data).descendants()).enter().append('text')
.attr('transform', (d) => {
      const x2 = (d.x0 + d.x1) / 2 * 180 / Math.PI;
      const y2 = (d.y0 + d.y1) / 2 * radius;
      return `rotate(${x2 - 90}) translate(${y2},0) rotate(${x2 < 180 ? 0 : 180})`;
    })
.attr('text-anchor', (d) => ((d.x0 + d.x1) / 2 * 180 / Math.PI < 180 ? "start" : "end"))
.attr('dy', '0.35em')
.attr('font-size', options.childTextSize)
.text((d) => d.data.name)
.attr('fill-opacity', (d) => +labelVisible(d))
.attr('display', (d) => (labelVisible(d) ? null : "none"));
    function labelVisible(d) {
      return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0 + 0.01;
    }
  }
  function createTreeDiagram(data, options, chartComponents) {
    const {
      width,
      height,
      color,
      radius,
      strokeColor,
    } = options;
    const { svg } = chartComponents;
    const tree = d3.tree().size([height - 10, width - 10]);
    const root = d3.hierarchy(data);
    tree(root);
    const link2 = svg.selectAll('.link').data(root.links()).join('path').attr('class', 'link')
.attr('fill', 'none')
.attr('stroke', strokeColor)
.attr('stroke-width', `${options.strokeWidth}` || 1.5)
.attr('stroke-opacity', options.opacity)
.attr('d', d3.linkHorizontal().x((d) => d.y).y((d) => d.x));
    const node = svg.selectAll('.node').data(root.descendants()).join('g').attr('class', 'node')
.attr('transform', (d) => `translate(${d.y}, ${d.x})`);
    node.append('circle').attr('r', radius).style('fill', color);
    node.append('text').attr('dy', '0.31em').attr('x', (d) => (d.children ? -radius : radius)).text((d) => d.data.name)
.style('font-size', `${options.childTextSize}`)
.style('fill', '#000');
  }
  function createD3TreeMap(data, options, chartComponents) {
    const width = options.width || 600;
    const height = options.height || 400;
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const { svg } = chartComponents;
    const treemap = d3.treemap().size([width, height]).padding(1).round(true);
    const root = d3.hierarchy(data).sum((d) => d.value).sort((a2, b) => b.value - a2.value);
    treemap(root);
    const leaf = svg.selectAll('g').data(root.leaves()).join('g').attr('transform', (d) => `translate(${d.x0},${d.y0})`);
    leaf.append('rect').attr('width', (d) => d.x1 - d.x0).attr('height', (d) => d.y1 - d.y0).attr('fill', (d) => color(d.parent.data.name));
    leaf.append('text').attr('x', 3).attr('y', 12).text((d) => d.data.name)
.style('font-size', `${options.childTextSize}`);
  }
  function d3PolygonArea(polygon) {
    let i = -1; var n = polygon.length; var a2; var b = polygon[n - 1]; var 
area2 = 0;
    while (++i < n) {
      a2 = b;
      b = polygon[i];
      area2 += a2[1] * b[0] - a2[0] * b[1];
    }
    return area2 / 2;
  }
  function d3PolygonCentroid(polygon) {
    let i = -1; var n = polygon.length; var x2 = 0; var y2 = 0; var a2; var b = polygon[n - 1]; var c2; var 
k2 = 0;
    while (++i < n) {
      a2 = b;
      b = polygon[i];
      k2 += c2 = a2[0] * b[1] - b[0] * a2[1];
      x2 += (a2[0] + b[0]) * c2;
      y2 += (a2[1] + b[1]) * c2;
    }
    return k2 *= 3, [x2 / k2, y2 / k2];
  }
  function cross$2(a2, b, c2) {
    return (b[0] - a2[0]) * (c2[1] - a2[1]) - (b[1] - a2[1]) * (c2[0] - a2[0]);
  }
  function lexicographicOrder$1(a2, b) {
    return a2[0] - b[0] || a2[1] - b[1];
  }
  function computeUpperHullIndexes$1(points) {
    const n = points.length; const 
indexes2 = [0, 1];
    let size = 2; let 
i;
    for (i = 2; i < n; ++i) {
      while (size > 1 && cross$2(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0) {--size;}
      indexes2[size++] = i;
    }
    return indexes2.slice(0, size);
  }
  function hull(points) {
    if ((n = points.length) < 3) {return null;}
    let i; var n; var sortedPoints = new Array(n); var 
flippedPoints = new Array(n);
    for (i = 0; i < n; ++i) {sortedPoints[i] = [+points[i][0], +points[i][1], i];}
    sortedPoints.sort(lexicographicOrder$1);
    for (i = 0; i < n; ++i) {flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];}
    let upperIndexes = computeUpperHullIndexes$1(sortedPoints); var 
lowerIndexes = computeUpperHullIndexes$1(flippedPoints);
    let skipLeft = lowerIndexes[0] === upperIndexes[0]; var skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1]; var 
hull2 = [];
    for (i = upperIndexes.length - 1; i >= 0; --i) {hull2.push(points[sortedPoints[upperIndexes[i]][2]]);}
    for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) {hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);}
    return hull2;
  }
  function d3PolygonContains(polygon, point2) {
    let n = polygon.length; var p = polygon[n - 1]; var x2 = point2[0]; var y2 = point2[1]; var x0 = p[0]; var y0 = p[1]; var x1; var y1; var 
inside = false;
    for (let i = 0; i < n; ++i) {
      p = polygon[i], x1 = p[0], y1 = p[1];
      if (y1 > y2 !== y0 > y2 && x2 < (x0 - x1) * (y2 - y1) / (y0 - y1) + x1) {inside = !inside;}
      x0 = x1, y0 = y1;
    }
    return inside;
  }
  function length$2(polygon) {
    let i = -1; var n = polygon.length; var b = polygon[n - 1]; var xa; var ya; var xb = b[0]; var yb = b[1]; var 
perimeter = 0;
    while (++i < n) {
      xa = xb;
      ya = yb;
      b = polygon[i];
      xb = b[0];
      yb = b[1];
      xa -= xb;
      ya -= yb;
      perimeter += Math.hypot(xa, ya);
    }
    return perimeter;
  }
  let frame = 0; var timeout$1 = 0; var interval$1 = 0; var pokeDelay = 1e3; var taskHead; var taskTail; var clockLast = 0; var clockNow = 0; var clockSkew = 0; var clock = typeof performance === "object" && performance.now ? performance : Date; var 
setFrame = typeof window === 'object' && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    let t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    let t = taskHead; var 
e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) {t._call.call(null, e);}
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout$1 = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    let now2 = clock.now(); var 
delay = now2 - clockLast;
    if (delay > pokeDelay) {clockSkew -= delay, clockLast = now2;}
  }
  function nap() {
    let t0; var t1 = taskHead; var t2; var 
time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) {time = t1._time;}
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame) {return;}
    if (timeout$1) {timeout$1 = clearTimeout(timeout$1);}
    let delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) {timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);}
      if (interval$1) {interval$1 = clearInterval(interval$1);}
    } else {
      if (!interval$1) {clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);}
      frame = 1, setFrame(wake);
    }
  }
  function timeout(callback, delay, time) {
    let t = new Timer();
    delay = delay == null ? 0 : +delay;
    t.restart((elapsed) => {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }
  function interval(callback, delay, time) {
    let t = new Timer(); var 
total = delay;
    if (delay == null) {return t.restart(callback, delay, time), t;}
    t._restart = t.restart;
    t.restart = function (callback2, delay2, time2) {
      delay2 = +delay2, time2 = time2 == null ? now() : +time2;
      t._restart(function tick(elapsed) {
        elapsed += total;
        t._restart(tick, total += delay2, time2);
        callback2(elapsed);
      }, delay2, time2);
    };
    t.restart(callback, delay, time);
    return t;
  }
  let noop = {
 value: () => {
  } 
};
  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = `${arguments[i]  }`) || t in _ || /[\s.]/.test(t)) {throw new Error("illegal type: " + t);}
      _[t] = [];
    }
    return new Dispatch(_);
  }
  function Dispatch(_) {
    this._ = _;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map((t) => {
      let name = ''; var 
i = t.indexOf('.');
      if (i >= 0) {name = t.slice(i + 1), t = t.slice(0, i);}
      if (t && !types.hasOwnProperty(t)) {throw new Error("unknown type: " + t);}
      return { type: t, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on(typename, callback) {
      var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i < n)
          if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
            return t;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type)
          _[t] = set$1(_[t], typename.name, callback);
        else if (callback == null)
          for (t in _)
            _[t] = set$1(_[t], typename.name, null);
      }
      return this;
    },
    copy() {
      var copy = {}, _ = this._;
      for (var t in _)
        copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call(type, that) {
      if ((n = arguments.length - 2) > 0)
        for (var args = new Array(n), i = 0, n, t; i < n; ++i)
          args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    },
    apply(type, that, args) {
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    }
  };
  function get(type, name) {
    for (var i = 0, n = type.length, c2; i < n; ++i) {
      if ((c2 = type[i]).name === name) {
        return c2.value;
      }
    }
  }
  function set$1(type, name, callback) {
    for (let i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) {type.push({ name, value: callback });}
    return type;
  }
  function ascending(a2, b) {
    return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  }
  function bisector(f) {
    let delta = f;
    let compare = f;
    if (f.length === 1) {
      delta = (d, x2) => f(d) - x2;
      compare = ascendingComparator(f);
    }
    function left2(a2, x2, lo, hi) {
      if (lo == null) {lo = 0;}
      if (hi == null) {hi = a2.length;}
      while (lo < hi) {
        const mid = lo + hi >>> 1;
        if (compare(a2[mid], x2) < 0) {lo = mid + 1;}
        else {hi = mid;}
      }
      return lo;
    }
    function right2(a2, x2, lo, hi) {
      if (lo == null) {lo = 0;}
      if (hi == null) {hi = a2.length;}
      while (lo < hi) {
        const mid = lo + hi >>> 1;
        if (compare(a2[mid], x2) > 0) {hi = mid;}
        else {lo = mid + 1;}
      }
      return lo;
    }
    function center2(a2, x2, lo, hi) {
      if (lo == null) {lo = 0;}
      if (hi == null) {hi = a2.length;}
      const i = left2(a2, x2, lo, hi - 1);
      return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function ascendingComparator(f) {
    return (d, x2) => ascending(f(d), x2);
  }
  function number(x2) {
    return x2 === null ? NaN : +x2;
  }
  function* numbers(values, valueof) {
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          yield value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
          yield value2;
        }
      }
    }
  }
  const ascendingBisect = bisector(ascending);
  const bisectRight = ascendingBisect.right;
  const bisectLeft = ascendingBisect.left;
  const bisectCenter = bisector(number).center;
  function count(values, valueof) {
    let count2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          ++count2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
          ++count2;
        }
      }
    }
    return count2;
  }
  function length$1(array2) {
    return array2.length | 0;
  }
  function empty(length2) {
    return !(length2 > 0);
  }
  function arrayify(values) {
    return typeof values !== 'object' || 'length' in values ? values : Array.from(values);
  }
  function reducer(reduce2) {
    return (values) => reduce2(...values);
  }
  function cross$1(...values) {
    const reduce2 = typeof values[values.length - 1] === 'function' && reducer(values.pop());
    values = values.map(arrayify);
    const lengths = values.map(length$1);
    const j = values.length - 1;
    const index2 = new Array(j + 1).fill(0);
    const product = [];
    if (j < 0 || lengths.some(empty)) {return product;}
    while (true) {
      product.push(index2.map((j2, i2) => values[i2][j2]));
      let i = j;
      while (++index2[i] === lengths[i]) {
        if (i === 0) {return reduce2 ? product.map(reduce2) : product;}
        index2[i--] = 0;
      }
    }
  }
  function cumsum(values, valueof) {
    let sum2 = 0; var 
index2 = 0;
    return Float64Array.from(values, valueof === void 0 ? (v) => sum2 += +v || 0 : (v) => sum2 += +valueof(v, index2++, values) || 0);
  }
  function descending(a2, b) {
    return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
  }
  function variance(values, valueof) {
    let count2 = 0;
    let delta;
    let mean2 = 0;
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          delta = value2 - mean2;
          mean2 += delta / ++count2;
          sum2 += delta * (value2 - mean2);
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
          delta = value2 - mean2;
          mean2 += delta / ++count2;
          sum2 += delta * (value2 - mean2);
        }
      }
    }
    if (count2 > 1) {return sum2 / (count2 - 1);}
  }
  function deviation(values, valueof) {
    const v = variance(values, valueof);
    return v ? Math.sqrt(v) : v;
  }
  function d3Extent(values, valueof) {
    let min2;
    let max2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null) {
          if (min2 === void 0) {
            if (value2 >= value2) {min2 = max2 = value2;}
          } else {
            if (min2 > value2) {min2 = value2;}
            if (max2 < value2) {max2 = value2;}
          }
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null) {
          if (min2 === void 0) {
            if (value2 >= value2) {min2 = max2 = value2;}
          } else {
            if (min2 > value2) {min2 = value2;}
            if (max2 < value2) {max2 = value2;}
          }
        }
      }
    }
    return [min2, max2];
  }
  class Adder {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }

    add(x2) {
      const p = this._partials;
      let i = 0;
      for (let j = 0; j < this._n && j < 32; j++) {
        const y2 = p[j]; const hi = x2 + y2; const 
lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
        if (lo) {p[i++] = lo;}
        x2 = hi;
      }
      p[i] = x2;
      this._n = i + 1;
      return this;
    }

    valueOf() {
      const p = this._partials;
      let n = this._n; let x2; let y2; let lo; let 
hi = 0;
      if (n > 0) {
        hi = p[--n];
        while (n > 0) {
          x2 = hi;
          y2 = p[--n];
          hi = x2 + y2;
          lo = y2 - (hi - x2);
          if (lo) {break;}
        }
        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
          y2 = lo * 2;
          x2 = hi + y2;
          if (y2 == x2 - hi) {hi = x2;}
        }
      }
      return hi;
    }
  }
  function fsum(values, valueof) {
    const adder = new Adder();
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 = +value2) {
          adder.add(value2);
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if (value2 = +valueof(value2, ++index2, values)) {
          adder.add(value2);
        }
      }
    }
    return +adder;
  }
  function fcumsum(values, valueof) {
    const adder = new Adder();
    let index2 = -1;
    return Float64Array.from(
      values,
      valueof === void 0 ? (v) => adder.add(+v || 0) : (v) => adder.add(+valueof(v, ++index2, values) || 0)
    );
  }
  class InternMap extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) {for (const [key2, value2] of entries)
          this.set(key2, value2);}
    }

    get(key) {
      return super.get(intern_get(this, key));
    }

    has(key) {
      return super.has(intern_get(this, key));
    }

    set(key, value2) {
      return super.set(intern_set(this, key), value2);
    }

    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  }
  class InternSet extends Set {
    constructor(values, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (values != null) {for (const value2 of values)
          this.add(value2);}
    }

    has(value2) {
      return super.has(intern_get(this, value2));
    }

    add(value2) {
      return super.add(intern_set(this, value2));
    }

    delete(value2) {
      return super.delete(intern_delete(this, value2));
    }
  }
  function intern_get({ _intern, _key }, value2) {
    const key = _key(value2);
    return _intern.has(key) ? _intern.get(key) : value2;
  }
  function intern_set({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) {return _intern.get(key);}
    _intern.set(key, value2);
    return value2;
  }
  function intern_delete({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) {
      value2 = _intern.get(value2);
      _intern.delete(key);
    }
    return value2;
  }
  function keyof(value2) {
    return value2 !== null && typeof value2 === 'object' ? value2.valueOf() : value2;
  }
  function identity(x2) {
    return x2;
  }
  function group(values, ...keys) {
    return nest(values, identity, identity, keys);
  }
  function groups(values, ...keys) {
    return nest(values, Array.from, identity, keys);
  }
  function rollup(values, reduce2, ...keys) {
    return nest(values, identity, reduce2, keys);
  }
  function rollups(values, reduce2, ...keys) {
    return nest(values, Array.from, reduce2, keys);
  }
  function index(values, ...keys) {
    return nest(values, identity, unique, keys);
  }
  function indexes(values, ...keys) {
    return nest(values, Array.from, unique, keys);
  }
  function unique(values) {
    if (values.length !== 1) {throw new Error("duplicate key");}
    return values[0];
  }
  function nest(values, map2, reduce2, keys) {
    return (function regroup(values2, i) {
      if (i >= keys.length)
        return reduce2(values2);
      const groups2 = new InternMap();
      const keyof2 = keys[i++];
      let index2 = -1;
      for (const value2 of values2) {
        const key = keyof2(value2, ++index2, values2);
        const group2 = groups2.get(key);
        if (group2)
          group2.push(value2);
        else
          groups2.set(key, [value2]);
      }
      for (const [key, values3] of groups2) {
        groups2.set(key, regroup(values3, i));
      }
      return map2(groups2);
    }(values, 0));
  }
  function permute(source, keys) {
    return Array.from(keys, (key) => source[key]);
  }
  function sort(values, ...F) {
    if (typeof values[Symbol.iterator] !== 'function') {throw new TypeError("values is not iterable");}
    values = Array.from(values);
    let [f = ascending] = F;
    if (f.length === 1 || F.length > 1) {
      const index2 = Uint32Array.from(values, (d, i) => i);
      if (F.length > 1) {
        F = F.map((f2) => values.map(f2));
        index2.sort((i, j) => {
          for (const f2 of F) {
            const c2 = ascending(f2[i], f2[j]);
            if (c2) {return c2;}
          }
        });
      } else {
        f = values.map(f);
        index2.sort((i, j) => ascending(f[i], f[j]));
      }
      return permute(values, index2);
    }
    return values.sort(f);
  }
  function groupSort(values, reduce2, key) {
    return (reduce2.length === 1 ? sort(rollup(values, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
  }
  let array = Array.prototype;
  let {slice} = array;
  let map$1 = array.map;
  function constant(x2) {
    return function () {
      return x2;
    };
  }
  let e10 = Math.sqrt(50); var e5 = Math.sqrt(10); var 
e2 = Math.sqrt(2);
  function ticks(start, stop, count2) {
    let reverse2; var i = -1; var n; var ticks2; var 
step2;
    stop = +stop, start = +start, count2 = +count2;
    if (start === stop && count2 > 0) {return [start];}
    if (reverse2 = stop < start) {n = start, start = stop, stop = n;}
    if ((step2 = tickIncrement(start, stop, count2)) === 0 || !isFinite(step2)) {return [];}
    if (step2 > 0) {
      let r0 = Math.round(start / step2); let 
r1 = Math.round(stop / step2);
      if (r0 * step2 < start) {++r0;}
      if (r1 * step2 > stop) {--r1;}
      ticks2 = new Array(n = r1 - r0 + 1);
      while (++i < n) {ticks2[i] = (r0 + i) * step2;}
    } else {
      step2 = -step2;
      let r0 = Math.round(start * step2); let 
r1 = Math.round(stop * step2);
      if (r0 / step2 < start) {++r0;}
      if (r1 / step2 > stop) {--r1;}
      ticks2 = new Array(n = r1 - r0 + 1);
      while (++i < n) {ticks2[i] = (r0 + i) / step2;}
    }
    if (reverse2) {ticks2.reverse();}
    return ticks2;
  }
  function tickIncrement(start, stop, count2) {
    let step2 = (stop - start) / Math.max(0, count2); var power = Math.floor(Math.log(step2) / Math.LN10); var 
error = step2 / 10**power;
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * 10**power : -(10**-power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }
  function tickStep(start, stop, count2) {
    let step0 = Math.abs(stop - start) / Math.max(0, count2); var step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)); var 
error = step0 / step1;
    if (error >= e10) {step1 *= 10;}
    else if (error >= e5) {step1 *= 5;}
    else if (error >= e2) {step1 *= 2;}
    return stop < start ? -step1 : step1;
  }
  function nice(start, stop, count2) {
    let prestep;
    while (true) {
      const step2 = tickIncrement(start, stop, count2);
      if (step2 === prestep || step2 === 0 || !isFinite(step2)) {
        return [start, stop];
      } if (step2 > 0) {
        start = Math.floor(start / step2) * step2;
        stop = Math.ceil(stop / step2) * step2;
      } else if (step2 < 0) {
        start = Math.ceil(start * step2) / step2;
        stop = Math.floor(stop * step2) / step2;
      }
      prestep = step2;
    }
  }
  function sturges(values) {
    return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
  }
  function bin() {
    let value2 = identity; var domain = d3Extent; var 
threshold = sturges;
    function histogram(data) {
      if (!Array.isArray(data)) {data = Array.from(data);}
      let i; var n = data.length; var x2; var 
values = new Array(n);
      for (i = 0; i < n; ++i) {
        values[i] = value2(data[i], i, data);
      }
      let xz = domain(values); var x0 = xz[0]; var x1 = xz[1]; var 
tz = threshold(values, x0, x1);
      if (!Array.isArray(tz)) {
        const max2 = x1; const 
tn = +tz;
        if (domain === d3Extent) {[x0, x1] = nice(x0, x1, tn);}
        tz = ticks(x0, x1, tn);
        if (tz[tz.length - 1] >= x1) {
          if (max2 >= x1 && domain === d3Extent) {
            const step2 = tickIncrement(x0, x1, tn);
            if (isFinite(step2)) {
              if (step2 > 0) {
                x1 = (Math.floor(x1 / step2) + 1) * step2;
              } else if (step2 < 0) {
                x1 = (Math.ceil(x1 * -step2) + 1) / -step2;
              }
            }
          } else {
            tz.pop();
          }
        }
      }
      let m = tz.length;
      while (tz[0] <= x0) {tz.shift(), --m;}
      while (tz[m - 1] > x1) {tz.pop(), --m;}
      let bins = new Array(m + 1); var 
bin2;
      for (i = 0; i <= m; ++i) {
        bin2 = bins[i] = [];
        bin2.x0 = i > 0 ? tz[i - 1] : x0;
        bin2.x1 = i < m ? tz[i] : x1;
      }
      for (i = 0; i < n; ++i) {
        x2 = values[i];
        if (x0 <= x2 && x2 <= x1) {
          bins[bisectRight(tz, x2, 0, m)].push(data[i]);
        }
      }
      return bins;
    }
    histogram.value = function (_) {
      return arguments.length ? (value2 = typeof _ === 'function' ? _ : constant(_), histogram) : value2;
    };
    histogram.domain = function (_) {
      return arguments.length ? (domain = typeof _ === 'function' ? _ : constant([_[0], _[1]]), histogram) : domain;
    };
    histogram.thresholds = function (_) {
      return arguments.length ? (threshold = typeof _ === 'function' ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
    };
    return histogram;
  }
  function max(values, valueof) {
    let max2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2;
        }
      }
    }
    return max2;
  }
  function min(values, valueof) {
    let min2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2;
        }
      }
    }
    return min2;
  }
  function quickselect(array2, k2, left2 = 0, right2 = array2.length - 1, compare = ascending) {
    while (right2 > left2) {
      if (right2 - left2 > 600) {
        const n = right2 - left2 + 1;
        const m = k2 - left2 + 1;
        const z = Math.log(n);
        const s2 = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left2, Math.floor(k2 - m * s2 / n + sd));
        const newRight = Math.min(right2, Math.floor(k2 + (n - m) * s2 / n + sd));
        quickselect(array2, k2, newLeft, newRight, compare);
      }
      const t = array2[k2];
      let i = left2;
      let j = right2;
      swap(array2, left2, k2);
      if (compare(array2[right2], t) > 0) {swap(array2, left2, right2);}
      while (i < j) {
        swap(array2, i, j), ++i, --j;
        while (compare(array2[i], t) < 0) {++i;}
        while (compare(array2[j], t) > 0) {--j;}
      }
      if (compare(array2[left2], t) === 0) {swap(array2, left2, j);}
      else {++j, swap(array2, j, right2);}
      if (j <= k2) {left2 = j + 1;}
      if (k2 <= j) {right2 = j - 1;}
    }
    return array2;
  }
  function swap(array2, i, j) {
    const t = array2[i];
    array2[i] = array2[j];
    array2[j] = t;
  }
  function quantile(values, p, valueof) {
    values = Float64Array.from(numbers(values, valueof));
    if (!(n = values.length)) {return;}
    if ((p = +p) <= 0 || n < 2) {return min(values);}
    if (p >= 1) {return max(values);}
    let n; var i = (n - 1) * p; var i0 = Math.floor(i); var value0 = max(quickselect(values, i0).subarray(0, i0 + 1)); var 
value1 = min(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileSorted(values, p, valueof = number) {
    if (!(n = values.length)) {return;}
    if ((p = +p) <= 0 || n < 2) {return +valueof(values[0], 0, values);}
    if (p >= 1) {return +valueof(values[n - 1], n - 1, values);}
    let n; var i = (n - 1) * p; var i0 = Math.floor(i); var value0 = +valueof(values[i0], i0, values); var 
value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  }
  function freedmanDiaconis(values, min2, max2) {
    return Math.ceil((max2 - min2) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * count(values)**(-1 / 3)));
  }
  function scott(values, min2, max2) {
    return Math.ceil((max2 - min2) / (3.5 * deviation(values) * count(values)**(-1 / 3)));
  }
  function maxIndex(values, valueof) {
    let max2;
    let maxIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value2 of values) {
        ++index2;
        if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2, maxIndex2 = index2;
        }
      }
    } else {
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2, maxIndex2 = index2;
        }
      }
    }
    return maxIndex2;
  }
  function mean(values, valueof) {
    let count2 = 0;
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          ++count2, sum2 += value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
          ++count2, sum2 += value2;
        }
      }
    }
    if (count2) {return sum2 / count2;}
  }
  function median(values, valueof) {
    return quantile(values, 0.5, valueof);
  }
  function* flatten(arrays) {
    for (const array2 of arrays) {
      yield* array2;
    }
  }
  function merge(arrays) {
    return Array.from(flatten(arrays));
  }
  function minIndex(values, valueof) {
    let min2;
    let minIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value2 of values) {
        ++index2;
        if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2, minIndex2 = index2;
        }
      }
    } else {
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index2, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2, minIndex2 = index2;
        }
      }
    }
    return minIndex2;
  }
  function pairs(values, pairof = pair) {
    const pairs2 = [];
    let previous;
    let first = false;
    for (const value2 of values) {
      if (first) {pairs2.push(pairof(previous, value2));}
      previous = value2;
      first = true;
    }
    return pairs2;
  }
  function pair(a2, b) {
    return [a2, b];
  }
  function range(start, stop, step2) {
    start = +start, stop = +stop, step2 = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step2;
    var i = -1; var n = Math.max(0, Math.ceil((stop - start) / step2)) | 0; var 
range2 = new Array(n);
    while (++i < n) {
      range2[i] = start + i * step2;
    }
    return range2;
  }
  function least(values, compare = ascending) {
    let min2;
    let defined = false;
    if (compare.length === 1) {
      let minValue;
      for (const element of values) {
        const value2 = compare(element);
        if (defined ? ascending(value2, minValue) < 0 : ascending(value2, value2) === 0) {
          min2 = element;
          minValue = value2;
          defined = true;
        }
      }
    } else {
      for (const value2 of values) {
        if (defined ? compare(value2, min2) < 0 : compare(value2, value2) === 0) {
          min2 = value2;
          defined = true;
        }
      }
    }
    return min2;
  }
  function leastIndex(values, compare = ascending) {
    if (compare.length === 1) {return minIndex(values, compare);}
    let minValue;
    let min2 = -1;
    let index2 = -1;
    for (const value2 of values) {
      ++index2;
      if (min2 < 0 ? compare(value2, value2) === 0 : compare(value2, minValue) < 0) {
        minValue = value2;
        min2 = index2;
      }
    }
    return min2;
  }
  function greatest(values, compare = ascending) {
    let max2;
    let defined = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element of values) {
        const value2 = compare(element);
        if (defined ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
          max2 = element;
          maxValue = value2;
          defined = true;
        }
      }
    } else {
      for (const value2 of values) {
        if (defined ? compare(value2, max2) > 0 : compare(value2, value2) === 0) {
          max2 = value2;
          defined = true;
        }
      }
    }
    return max2;
  }
  function greatestIndex(values, compare = ascending) {
    if (compare.length === 1) {return maxIndex(values, compare);}
    let maxValue;
    let max2 = -1;
    let index2 = -1;
    for (const value2 of values) {
      ++index2;
      if (max2 < 0 ? compare(value2, value2) === 0 : compare(value2, maxValue) > 0) {
        maxValue = value2;
        max2 = index2;
      }
    }
    return max2;
  }
  function scan(values, compare) {
    const index2 = leastIndex(values, compare);
    return index2 < 0 ? void 0 : index2;
  }
  const shuffle = shuffler(Math.random);
  function shuffler(random) {
    return function shuffle2(array2, i0 = 0, i1 = array2.length) {
      let m = i1 - (i0 = +i0);
      while (m) {
        const i = random() * m-- | 0; const 
t = array2[m + i0];
        array2[m + i0] = array2[i + i0];
        array2[i + i0] = t;
      }
      return array2;
    };
  }
  function sum(values, valueof) {
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 = +value2) {
          sum2 += value2;
        }
      }
    } else {
      let index2 = -1;
      for (let value2 of values) {
        if (value2 = +valueof(value2, ++index2, values)) {
          sum2 += value2;
        }
      }
    }
    return sum2;
  }
  function transpose(matrix) {
    if (!(n = matrix.length)) {return [];}
    for (var i = -1, m = min(matrix, length), transpose2 = new Array(m); ++i < m;) {
      for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n;) {
        row[j] = matrix[j][i];
      }
    }
    return transpose2;
  }
  function length(d) {
    return d.length;
  }
  function zip() {
    return transpose(arguments);
  }
  function every(values, test) {
    if (typeof test !== 'function') {throw new TypeError("test is not a function");}
    let index2 = -1;
    for (const value2 of values) {
      if (!test(value2, ++index2, values)) {
        return false;
      }
    }
    return true;
  }
  function some(values, test) {
    if (typeof test !== 'function') {throw new TypeError("test is not a function");}
    let index2 = -1;
    for (const value2 of values) {
      if (test(value2, ++index2, values)) {
        return true;
      }
    }
    return false;
  }
  function filter(values, test) {
    if (typeof test !== 'function') {throw new TypeError("test is not a function");}
    const array2 = [];
    let index2 = -1;
    for (const value2 of values) {
      if (test(value2, ++index2, values)) {
        array2.push(value2);
      }
    }
    return array2;
  }
  function map(values, mapper) {
    if (typeof values[Symbol.iterator] !== 'function') {throw new TypeError("values is not iterable");}
    if (typeof mapper !== 'function') {throw new TypeError("mapper is not a function");}
    return Array.from(values, (value2, index2) => mapper(value2, index2, values));
  }
  function reduce(values, reducer2, value2) {
    if (typeof reducer2 !== 'function') {throw new TypeError("reducer is not a function");}
    const iterator = values[Symbol.iterator]();
    let done; let next; let 
index2 = -1;
    if (arguments.length < 3) {
      ({ done, value: value2 } = iterator.next());
      if (done) {return;}
      ++index2;
    }
    while ({ done, value: next } = iterator.next(), !done) {
      value2 = reducer2(value2, next, ++index2, values);
    }
    return value2;
  }
  function reverse(values) {
    if (typeof values[Symbol.iterator] !== 'function') {throw new TypeError("values is not iterable");}
    return Array.from(values).reverse();
  }
  function difference(values, ...others) {
    values = new Set(values);
    for (const other of others) {
      for (const value2 of other) {
        values.delete(value2);
      }
    }
    return values;
  }
  function disjoint(values, other) {
    const iterator = other[Symbol.iterator](); const 
set2 = /* @__PURE__ */ new Set();
    for (const v of values) {
      if (set2.has(v)) {return false;}
      let value2; let 
done;
      while ({ value: value2, done } = iterator.next()) {
        if (done) {break;}
        if (Object.is(v, value2)) {return false;}
        set2.add(value2);
      }
    }
    return true;
  }
  function set(values) {
    return values instanceof Set ? values : new Set(values);
  }
  function intersection(values, ...others) {
    values = new Set(values);
    others = others.map(set);
    out:
    for (const value2 of values) {
      for (const other of others) {
        if (!other.has(value2)) {
          values.delete(value2);
          continue out;
        }
      }
    }
    return values;
  }
  function superset(values, other) {
    const iterator = values[Symbol.iterator](); const 
set2 = /* @__PURE__ */ new Set();
    for (const o of other) {
      if (set2.has(o)) {continue;}
      let value2; let 
done;
      while ({ value: value2, done } = iterator.next()) {
        if (done) {return false;}
        set2.add(value2);
        if (Object.is(o, value2)) {break;}
      }
    }
    return true;
  }
  function subset(values, other) {
    return superset(other, values);
  }
  function union(...others) {
    const set2 = /* @__PURE__ */ new Set();
    for (const other of others) {
      for (const o of other) {
        set2.add(o);
      }
    }
    return set2;
  }
  function area(polygon) {
    let i = -1; var n = polygon.length; var a2; var b = polygon[n - 1]; var 
area2 = 0;
    while (++i < n) {
      a2 = b;
      b = polygon[i];
      area2 += a2[1] * b[0] - a2[0] * b[1];
    }
    return area2 / 2;
  }
  function centroid(polygon) {
    let i = -1; var n = polygon.length; var x2 = 0; var y2 = 0; var a2; var b = polygon[n - 1]; var c2; var 
k2 = 0;
    while (++i < n) {
      a2 = b;
      b = polygon[i];
      k2 += c2 = a2[0] * b[1] - b[0] * a2[1];
      x2 += (a2[0] + b[0]) * c2;
      y2 += (a2[1] + b[1]) * c2;
    }
    return k2 *= 3, [x2 / k2, y2 / k2];
  }
  function cross(a2, b, c2) {
    return (b[0] - a2[0]) * (c2[1] - a2[1]) - (b[1] - a2[1]) * (c2[0] - a2[0]);
  }
  function lexicographicOrder(a2, b) {
    return a2[0] - b[0] || a2[1] - b[1];
  }
  function computeUpperHullIndexes(points) {
    const n = points.length; const 
indexes2 = [0, 1];
    let size = 2; let 
i;
    for (i = 2; i < n; ++i) {
      while (size > 1 && cross(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0) {--size;}
      indexes2[size++] = i;
    }
    return indexes2.slice(0, size);
  }
  function d3PolygonHull(points) {
    if ((n = points.length) < 3) {return null;}
    let i; var n; var sortedPoints = new Array(n); var 
flippedPoints = new Array(n);
    for (i = 0; i < n; ++i) {sortedPoints[i] = [+points[i][0], +points[i][1], i];}
    sortedPoints.sort(lexicographicOrder);
    for (i = 0; i < n; ++i) {flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];}
    let upperIndexes = computeUpperHullIndexes(sortedPoints); var 
lowerIndexes = computeUpperHullIndexes(flippedPoints);
    let skipLeft = lowerIndexes[0] === upperIndexes[0]; var skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1]; var 
hull2 = [];
    for (i = upperIndexes.length - 1; i >= 0; --i) {hull2.push(points[sortedPoints[upperIndexes[i]][2]]);}
    for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) {hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);}
    return hull2;
  }
  function contains(polygon, point2) {
    let n = polygon.length; var p = polygon[n - 1]; var x2 = point2[0]; var y2 = point2[1]; var x0 = p[0]; var y0 = p[1]; var x1; var y1; var 
inside = false;
    for (let i = 0; i < n; ++i) {
      p = polygon[i], x1 = p[0], y1 = p[1];
      if (y1 > y2 !== y0 > y2 && x2 < (x0 - x1) * (y2 - y1) / (y0 - y1) + x1) {inside = !inside;}
      x0 = x1, y0 = y1;
    }
    return inside;
  }
  function polygonLength(polygon) {
    let i = -1; var n = polygon.length; var b = polygon[n - 1]; var xa; var ya; var xb = b[0]; var yb = b[1]; var 
perimeter = 0;
    while (++i < n) {
      xa = xb;
      ya = yb;
      b = polygon[i];
      xb = b[0];
      yb = b[1];
      xa -= xb;
      ya -= yb;
      perimeter += Math.hypot(xa, ya);
    }
    return perimeter;
  }
  let epsilon = 1e-10;
  function epsilonesque(n) {
    return n <= epsilon && n >= -epsilon;
  }
  function dot(v0, v1) {
    return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;
  }
  function linearDependent(v0, v1) {
    return epsilonesque(v0.x * v1.y - v0.y * v1.x) && epsilonesque(v0.y * v1.z - v0.z * v1.y) && epsilonesque(v0.z * v1.x - v0.x * v1.z);
  }
  function polygonDirection(polygon) {
    let sign2; var crossproduct; var p0; var p1; var p2; var v0; var v1; var 
i;
    p0 = polygon[polygon.length - 2];
    p1 = polygon[polygon.length - 1];
    p2 = polygon[0];
    v0 = vect(p0, p1);
    v1 = vect(p1, p2);
    crossproduct = calculateCrossproduct(v0, v1);
    sign2 = Math.sign(crossproduct);
    p0 = p1;
    p1 = p2;
    p2 = polygon[1];
    v0 = v1;
    v1 = vect(p1, p2);
    crossproduct = calculateCrossproduct(v0, v1);
    if (Math.sign(crossproduct) !== sign2) {
      return void 0;
    }
    for (i = 2; i < polygon.length - 1; i++) {
      p0 = p1;
      p1 = p2;
      p2 = polygon[i];
      v0 = v1;
      v1 = vect(p1, p2);
      crossproduct = calculateCrossproduct(v0, v1);
      if (Math.sign(crossproduct) !== sign2) {
        return void 0;
      }
    }
    return sign2;
  }
  function vect(from, to) {
    return [to[0] - from[0], to[1] - from[1]];
  }
  function calculateCrossproduct(v0, v1) {
    return v0[0] * v1[1] - v0[1] * v1[0];
  }
  function ConflictListNode(face, vert) {
    this.face = face;
    this.vert = vert;
    this.nextf = null;
    this.prevf = null;
    this.nextv = null;
    this.prevv = null;
  }
  function ConflictList(forFace) {
    this.forFace = forFace;
    this.head = null;
  }
  ConflictList.prototype.add = function (cln) {
    if (this.head === null) {
      this.head = cln;
    } else if (this.forFace) {
        this.head.prevv = cln;
        cln.nextv = this.head;
        this.head = cln;
      } else {
        this.head.prevf = cln;
        cln.nextf = this.head;
        this.head = cln;
      }
  };
  ConflictList.prototype.isEmpty = function () {
    return this.head === null;
  };
  ConflictList.prototype.fill = function (visible) {
    if (this.forFace) {
      return;
    }
    let curr = this.head;
    do {
      visible.push(curr.face);
      curr.face.marked = true;
      curr = curr.nextf;
    } while (curr !== null);
  };
  ConflictList.prototype.removeAll = function () {
    if (this.forFace) {
      var curr = this.head;
      do {
        if (curr.prevf === null) {
          if (curr.nextf === null) {
            curr.vert.conflicts.head = null;
          } else {
            curr.nextf.prevf = null;
            curr.vert.conflicts.head = curr.nextf;
          }
        } else {
          if (curr.nextf != null) {
            curr.nextf.prevf = curr.prevf;
          }
          curr.prevf.nextf = curr.nextf;
        }
        curr = curr.nextv;
        if (curr != null) {
          curr.prevv = null;
        }
      } while (curr != null);
    } else {
      var curr = this.head;
      do {
        if (curr.prevv == null) {
          if (curr.nextv == null) {
            curr.face.conflicts.head = null;
          } else {
            curr.nextv.prevv = null;
            curr.face.conflicts.head = curr.nextv;
          }
        } else {
          if (curr.nextv != null) {
            curr.nextv.prevv = curr.prevv;
          }
          curr.prevv.nextv = curr.nextv;
        }
        curr = curr.nextf;
        if (curr != null) {curr.prevf = null;}
      } while (curr != null);
    }
  };
  ConflictList.prototype.getVertices = function () {
    let list = []; var 
curr = this.head;
    while (curr !== null) {
      list.push(curr.vert);
      curr = curr.nextv;
    }
    return list;
  };
  function Vertex(x2, y2, z, weight, orig, isDummy) {
    this.x = x2;
    this.y = y2;
    this.weight = epsilon;
    this.index = 0;
    this.conflicts = new ConflictList(false);
    this.neighbours = null;
    this.nonClippedPolygon = null;
    this.polygon = null;
    this.originalObject = null;
    this.isDummy = false;
    if (orig !== void 0) {
      this.originalObject = orig;
    }
    if (isDummy != void 0) {
      this.isDummy = isDummy;
    }
    if (weight != null) {
      this.weight = weight;
    }
    if (z != null) {
      this.z = z;
    } else {
      this.z = this.projectZ(this.x, this.y, this.weight);
    }
  }
  Vertex.prototype.projectZ = function (x2, y2, weight) {
    return x2 * x2 + y2 * y2 - weight;
  };
  Vertex.prototype.setWeight = function (weight) {
    this.weight = weight;
    this.z = this.projectZ(this.x, this.y, this.weight);
  };
  Vertex.prototype.subtract = function (v) {
    return new Vertex(v.x - this.x, v.y - this.y, v.z - this.z);
  };
  Vertex.prototype.crossproduct = function (v) {
    return new Vertex(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
  };
  Vertex.prototype.equals = function (v) {
    return this.x === v.x && this.y === v.y && this.z === v.z;
  };
  function Plane3D(face) {
    let p1 = face.verts[0];
    let p2 = face.verts[1];
    let p3 = face.verts[2];
    this.a = p1.y * (p2.z - p3.z) + p2.y * (p3.z - p1.z) + p3.y * (p1.z - p2.z);
    this.b = p1.z * (p2.x - p3.x) + p2.z * (p3.x - p1.x) + p3.z * (p1.x - p2.x);
    this.c = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);
    this.d = -1 * (p1.x * (p2.y * p3.z - p3.y * p2.z) + p2.x * (p3.y * p1.z - p1.y * p3.z) + p3.x * (p1.y * p2.z - p2.y * p1.z));
  }
  Plane3D.prototype.getNormZPlane = function () {
    return [
      -1 * (this.a / this.c),
      -1 * (this.b / this.c),
      -1 * (this.d / this.c),
    ];
  };
  Plane3D.prototype.getDualPointMappedToPlane = function () {
    let nplane = this.getNormZPlane();
    let dualPoint = new Point2D(nplane[0] / 2, nplane[1] / 2);
    return dualPoint;
  };
  function Point2D(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  function Vector(x2, y2, z) {
    this.x = x2;
    this.y = y2;
    this.z = z;
  }
  Vector.prototype.negate = function () {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
  };
  Vector.prototype.normalize = function () {
    let lenght = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    if (lenght > 0) {
      this.x /= lenght;
      this.y /= lenght;
      this.z /= lenght;
    }
  };
  function HEdge(orig, dest, face) {
    this.next = null;
    this.prev = null;
    this.twin = null;
    this.orig = orig;
    this.dest = dest;
    this.iFace = face;
  }
  HEdge.prototype.isHorizon = function () {
    return this.twin !== null && !this.iFace.marked && this.twin.iFace.marked;
  };
  HEdge.prototype.findHorizon = function(horizon) {
    if (this.isHorizon()) {
      if (horizon.length > 0 && this === horizon[0]) {
        
      } else {
        horizon.push(this);
        this.next.findHorizon(horizon);
      }
    } else {
      if (this.twin !== null) {
        this.twin.next.findHorizon(horizon);
      }
    }
  };
  HEdge.prototype.isEqual = function (origin, dest) {
    return this.orig.equals(origin) && this.dest.equals(dest) || this.orig.equals(dest) && this.dest.equals(origin);
  };
  function d3WeightedVoronoiError(message) {
    this.message = message;
    this.stack = new Error().stack;
  }
  d3WeightedVoronoiError.prototype.name = 'd3WeightedVoronoiError';
  d3WeightedVoronoiError.prototype = new Error();
  function Face(a2, b, c2, orient) {
    this.conflicts = new ConflictList(true);
    this.verts = [a2, b, c2];
    this.marked = false;
    let t = a2.subtract(b).crossproduct(b.subtract(c2));
    this.normal = new Vector(-t.x, -t.y, -t.z);
    this.normal.normalize();
    this.createEdges();
    this.dualPoint = null;
    if (orient != void 0) {
      this.orient(orient);
    }
  }
  Face.prototype.getDualPoint = function () {
    if (this.dualPoint == null) {
      let plane3d = new Plane3D(this);
      this.dualPoint = plane3d.getDualPointMappedToPlane();
    }
    return this.dualPoint;
  };
  Face.prototype.isVisibleFromBelow = function () {
    return this.normal.z < -14259414393190911e-25;
  };
  Face.prototype.createEdges = function () {
    this.edges = [];
    this.edges[0] = new HEdge(this.verts[0], this.verts[1], this);
    this.edges[1] = new HEdge(this.verts[1], this.verts[2], this);
    this.edges[2] = new HEdge(this.verts[2], this.verts[0], this);
    this.edges[0].next = this.edges[1];
    this.edges[0].prev = this.edges[2];
    this.edges[1].next = this.edges[2];
    this.edges[1].prev = this.edges[0];
    this.edges[2].next = this.edges[0];
    this.edges[2].prev = this.edges[1];
  };
  Face.prototype.orient = function (orient) {
    if (!(dot(this.normal, orient) < dot(this.normal, this.verts[0]))) {
      let temp = this.verts[1];
      this.verts[1] = this.verts[2];
      this.verts[2] = temp;
      this.normal.negate();
      this.createEdges();
    }
  };
  Face.prototype.getEdge = function (v0, v1) {
    for (let i = 0; i < 3; i++) {
      if (this.edges[i].isEqual(v0, v1)) {
        return this.edges[i];
      }
    }
    return null;
  };
  Face.prototype.link = function (face, v0, v1) {
    if (face instanceof Face) {
      var twin = face.getEdge(v0, v1);
      if (twin === null) {
        throw new d3WeightedVoronoiError('when linking, twin is null');
      }
      var edge = this.getEdge(v0, v1);
      if (edge === null) {
        throw new d3WeightedVoronoiError('when linking, twin is null');
      }
      twin.twin = edge;
      edge.twin = twin;
    } else {
      var twin = face;
      var edge = this.getEdge(twin.orig, twin.dest);
      twin.twin = edge;
      edge.twin = twin;
    }
  };
  Face.prototype.conflict = function (v) {
    return dot(this.normal, v) > dot(this.normal, this.verts[0]) + epsilon;
  };
  Face.prototype.getHorizon = function () {
    for (let i = 0; i < 3; i++) {
      if (this.edges[i].twin !== null && this.edges[i].twin.isHorizon()) {
        return this.edges[i];
      }
    }
    return null;
  };
  Face.prototype.removeConflict = function () {
    this.conflicts.removeAll();
  };
  function ConvexHull() {
    this.points = [];
    this.facets = [];
    this.created = [];
    this.horizon = [];
    this.visible = [];
    this.current = 0;
  }
  ConvexHull.prototype.init = function (boundingSites, sites) {
    this.points = [];
    for (let i = 0; i < sites.length; i++) {
      this.points[i] = new Vertex(sites[i].x, sites[i].y, sites[i].z, null, sites[i], false);
    }
    this.points = this.points.concat(boundingSites);
  };
  ConvexHull.prototype.permutate = function () {
    let pointSize = this.points.length;
    for (let i = pointSize - 1; i > 0; i--) {
      let ra = Math.floor(Math.random() * i);
      let temp = this.points[ra];
      temp.index = i;
      let currentItem = this.points[i];
      currentItem.index = ra;
      this.points.splice(ra, 1, currentItem);
      this.points.splice(i, 1, temp);
    }
  };
  ConvexHull.prototype.prep = function () {
    if (this.points.length <= 3) {
      throw new d3WeightedVoronoiError('Less than 4 points');
    }
    for (var i = 0; i < this.points.length; i++) {
      this.points[i].index = i;
    }
    let v0; var v1; var v2; var 
v3;
    let f1; var f2; var f3; var 
f0;
    v0 = this.points[0];
    v1 = this.points[1];
    v2 = v3 = null;
    for (var i = 2; i < this.points.length; i++) {
      if (!(linearDependent(v0, this.points[i]) && linearDependent(v1, this.points[i]))) {
        v2 = this.points[i];
        v2.index = 2;
        this.points[2].index = i;
        this.points.splice(i, 1, this.points[2]);
        this.points.splice(2, 1, v2);
        break;
      }
    }
    if (v2 === null) {
      throw new d3WeightedVoronoiError('Not enough non-planar Points (v2 is null)');
    }
    f0 = new Face(v0, v1, v2);
    for (var i = 3; i < this.points.length; i++) {
      if (!epsilonesque(dot(f0.normal, f0.verts[0]) - dot(f0.normal, this.points[i]))) {
        v3 = this.points[i];
        v3.index = 3;
        this.points[3].index = i;
        this.points.splice(i, 1, this.points[3]);
        this.points.splice(3, 1, v3);
        break;
      }
    }
    if (v3 === null) {
      throw new d3WeightedVoronoiError('Not enough non-planar Points (v3 is null)');
    }
    f0.orient(v3);
    f1 = new Face(v0, v2, v3, v1);
    f2 = new Face(v0, v1, v3, v2);
    f3 = new Face(v1, v2, v3, v0);
    this.addFacet(f0);
    this.addFacet(f1);
    this.addFacet(f2);
    this.addFacet(f3);
    f0.link(f1, v0, v2);
    f0.link(f2, v0, v1);
    f0.link(f3, v1, v2);
    f1.link(f2, v0, v3);
    f1.link(f3, v2, v3);
    f2.link(f3, v3, v1);
    this.current = 4;
    let v;
    for (var i = this.current; i < this.points.length; i++) {
      v = this.points[i];
      if (f0.conflict(v)) {
        this.addConflict(f0, v);
      }
      if (f1.conflict(v)) {
        this.addConflict(f1, v);
      }
      if (f2.conflict(v)) {
        this.addConflict(f2, v);
      }
      if (f3.conflict(v)) {
        this.addConflict(f3, v);
      }
    }
  }, // IN: Faces old1 old2 and fn
  ConvexHull.prototype.addConflicts = function (old1, old2, fn) {
    let l1 = old1.conflicts.getVertices();
    let l2 = old2.conflicts.getVertices();
    let nCL = [];
    let v1; var 
v2;
    var i; var 
l;
    i = l = 0;
    while (i < l1.length || l < l2.length) {
      if (i < l1.length && l < l2.length) {
        v1 = l1[i];
        v2 = l2[l];
        if (v1.index === v2.index) {
          nCL.push(v1);
          i++;
          l++;
        } else if (v1.index > v2.index) {
          nCL.push(v1);
          i++;
        } else {
          nCL.push(v2);
          l++;
        }
      } else if (i < l1.length) {
        nCL.push(l1[i++]);
      } else {
        nCL.push(l2[l++]);
      }
    }
    for (var i = nCL.length - 1; i >= 0; i--) {
      v1 = nCL[i];
      if (fn.conflict(v1)) {this.addConflict(fn, v1);}
    }
  };
  ConvexHull.prototype.addConflict = function (face, vert) {
    let e = new ConflictListNode(face, vert);
    face.conflicts.add(e);
    vert.conflicts.add(e);
  };
  ConvexHull.prototype.removeConflict = function (f) {
    f.removeConflict();
    let index2 = f.index;
    f.index = -1;
    if (index2 === this.facets.length - 1) {
      this.facets.splice(this.facets.length - 1, 1);
      return;
    }
    if (index2 >= this.facets.length || index2 < 0) {return;}
    let last = this.facets.splice(this.facets.length - 1, 1);
    last[0].index = index2;
    this.facets.splice(index2, 1, last[0]);
  };
  ConvexHull.prototype.addFacet = function (face) {
    face.index = this.facets.length;
    this.facets.push(face);
  };
  ConvexHull.prototype.compute = function () {
    this.prep();
    while (this.current < this.points.length) {
      let next = this.points[this.current];
      if (next.conflicts.isEmpty()) {
        this.current++;
        continue;
      }
      this.created = [];
      this.horizon = [];
      this.visible = [];
      next.conflicts.fill(this.visible);
      var e;
      for (let jF = 0; jF < this.visible.length; jF++) {
        e = this.visible[jF].getHorizon();
        if (e !== null) {
          e.findHorizon(this.horizon);
          break;
        }
      }
      let last = null; var 
first = null;
      for (let hEi = 0; hEi < this.horizon.length; hEi++) {
        let hE = this.horizon[hEi];
        let fn = new Face(next, hE.orig, hE.dest, hE.twin.next.dest);
        fn.conflicts = new ConflictList(true);
        this.addFacet(fn);
        this.created.push(fn);
        this.addConflicts(hE.iFace, hE.twin.iFace, fn);
        fn.link(hE);
        if (last !== null) {fn.link(last, next, hE.orig);}
        last = fn;
        if (first === null) {first = fn;}
      }
      if (first !== null && last !== null) {
        last.link(first, next, this.horizon[0].orig);
      }
      if (this.created.length != 0) {
        for (let f = 0; f < this.visible.length; f++) {
          this.removeConflict(this.visible[f]);
        }
        this.current++;
        this.created = [];
      }
    }
    return this.facets;
  };
  ConvexHull.prototype.clear = function () {
    this.points = [];
    this.facets = [];
    this.created = [];
    this.horizon = [];
    this.visible = [];
    this.current = 0;
  };
  function polygonClip(clip, subject) {
    let input; var closed = polygonClosed(subject); var i = -1; var n = clip.length - polygonClosed(clip); var j; var m; var a2 = clip[n - 1]; var b; var c2; var d; var 
intersection2;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = clip[i];
      c2 = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (polygonInside(d, a2, b)) {
          if (!polygonInside(c2, a2, b)) {
            intersection2 = polygonIntersect(c2, d, a2, b);
            if (isFinite(intersection2[0])) {
              subject.push(intersection2);
            }
          }
          subject.push(d);
        } else if (polygonInside(c2, a2, b)) {
          intersection2 = polygonIntersect(c2, d, a2, b);
          if (isFinite(intersection2[0])) {
            subject.push(intersection2);
          }
        }
        c2 = d;
      }
      if (closed) {subject.push(subject[0]);}
      a2 = b;
    }
    return subject;
  }
  function polygonInside(p, a2, b) {
    return (b[0] - a2[0]) * (p[1] - a2[1]) < (b[1] - a2[1]) * (p[0] - a2[0]);
  }
  function polygonIntersect(c2, d, a2, b) {
    let x1 = c2[0]; var x3 = a2[0]; var x21 = d[0] - x1; var x43 = b[0] - x3; var y1 = c2[1]; var y3 = a2[1]; var y21 = d[1] - y1; var y43 = b[1] - y3; var 
ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [x1 + ua * x21, y1 + ua * y21];
  }
  function polygonClosed(coordinates) {
    let a2 = coordinates[0]; var 
b = coordinates[coordinates.length - 1];
    return !(a2[0] - b[0] || a2[1] - b[1]);
  }
  function getFacesOfDestVertex(edge) {
    let faces = [];
    let previous = edge;
    let first = edge.dest;
    let site = first.originalObject;
    let neighbours = [];
    do {
      previous = previous.twin.prev;
      let siteOrigin = previous.orig.originalObject;
      if (!siteOrigin.isDummy) {
        neighbours.push(siteOrigin);
      }
      let {iFace} = previous;
      if (iFace.isVisibleFromBelow()) {
        faces.push(iFace);
      }
    } while (previous !== edge);
    site.neighbours = neighbours;
    return faces;
  }
  function computePowerDiagramIntegrated(sites, boundingSites, clippingPolygon) {
    let convexHull = new ConvexHull();
    convexHull.clear();
    convexHull.init(boundingSites, sites);
    let facets = convexHull.compute(sites);
    let polygons = [];
    let verticesVisited = [];
    let facetCount = facets.length;
    for (let i = 0; i < facetCount; i++) {
      let facet = facets[i];
      if (facet.isVisibleFromBelow()) {
        for (let e = 0; e < 3; e++) {
          let edge = facet.edges[e];
          let destVertex = edge.dest;
          let site = destVertex.originalObject;
          if (!verticesVisited[destVertex.index]) {
            verticesVisited[destVertex.index] = true;
            if (site.isDummy) {
              continue;
            }
            let faces = getFacesOfDestVertex(edge);
            let protopoly = [];
            let lastX = null;
            let lastY = null;
            let dx = 1;
            let dy = 1;
            for (let j = 0; j < faces.length; j++) {
              let point2 = faces[j].getDualPoint();
              let x1 = point2.x;
              let y1 = point2.y;
              if (lastX !== null) {
                dx = lastX - x1;
                dy = lastY - y1;
                if (dx < 0) {
                  dx = -dx;
                }
                if (dy < 0) {
                  dy = -dy;
                }
              }
              if (dx > epsilon || dy > epsilon) {
                protopoly.push([x1, y1]);
                lastX = x1;
                lastY = y1;
              }
            }
            site.nonClippedPolygon = protopoly.reverse();
            if (!site.isDummy && polygonLength(site.nonClippedPolygon) > 0) {
              let clippedPoly = polygonClip(clippingPolygon, site.nonClippedPolygon);
              site.polygon = clippedPoly;
              clippedPoly.site = site;
              if (clippedPoly.length > 0) {
                polygons.push(clippedPoly);
              }
            }
          }
        }
      }
    }
    return polygons;
  }
  function weightedVoronoi() {
    let x2 = function (d) {
      return d.x;
    };
    let y2 = function (d) {
      return d.y;
    };
    let weight = function (d) {
      return d.weight;
    };
    let clip = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
    ];
    let extent2 = [
      [0, 0],
      [1, 1],
    ];
    let size = [1, 1];
    function _weightedVoronoi(data) {
      let formatedSites;
      formatedSites = data.map((d) => {
        return new Vertex(x2(d), y2(d), null, weight(d), d, false);
      });
      return computePowerDiagramIntegrated(formatedSites, boundingSites(), clip);
    }
    _weightedVoronoi.x = function (_) {
      if (!arguments.length) {
        return x2;
      }
      x2 = _;
      return _weightedVoronoi;
    };
    _weightedVoronoi.y = function (_) {
      if (!arguments.length) {
        return y2;
      }
      y2 = _;
      return _weightedVoronoi;
    };
    _weightedVoronoi.weight = function (_) {
      if (!arguments.length) {
        return weight;
      }
      weight = _;
      return _weightedVoronoi;
    };
    _weightedVoronoi.clip = function (_) {
      let direction2; var xExtent; var 
yExtent;
      if (!arguments.length) {
        return clip;
      }
      xExtent = d3Extent(
        _.map((c2) => {
          return c2[0];
        })
      );
      yExtent = d3Extent(
        _.map((c2) => {
          return c2[1];
        })
      );
      direction2 = polygonDirection(_);
      if (direction2 === void 0) {
        clip = d3PolygonHull(_);
      } else if (direction2 === 1) {
        clip = _.reverse();
      } else {
        clip = _;
      }
      extent2 = [
        [xExtent[0], yExtent[0]],
        [xExtent[1], yExtent[1]],
      ];
      size = [xExtent[1] - xExtent[0], yExtent[1] - yExtent[0]];
      return _weightedVoronoi;
    };
    _weightedVoronoi.extent = function (_) {
      if (!arguments.length) {
        return extent2;
      }
      clip = [_[0], [_[0][0], _[1][1]], _[1], [_[1][0], _[0][1]]];
      extent2 = _;
      size = [_[1][0] - _[0][0], _[1][1] - _[0][1]];
      return _weightedVoronoi;
    };
    _weightedVoronoi.size = function (_) {
      if (!arguments.length) {
        return size;
      }
      clip = [
        [0, 0],
        [0, _[1]],
        [_[0], _[1]],
        [_[0], 0],
      ];
      extent2 = [[0, 0], _];
      size = _;
      return _weightedVoronoi;
    };
    function boundingSites() {
      let minX; var maxX; var minY; var maxY; var width; var height; var x0; var x1; var y0; var y1; var boundingData = []; var 
boundingSites2 = [];
      minX = extent2[0][0];
      maxX = extent2[1][0];
      minY = extent2[0][1];
      maxY = extent2[1][1];
      width = maxX - minX;
      height = maxY - minY;
      x0 = minX - width;
      x1 = maxX + width;
      y0 = minY - height;
      y1 = maxY + height;
      boundingData[0] = [x0, y0];
      boundingData[1] = [x0, y1];
      boundingData[2] = [x1, y1];
      boundingData[3] = [x1, y0];
      for (let i = 0; i < 4; i++) {
        boundingSites2.push(
          new Vertex(
            boundingData[i][0],
            boundingData[i][1],
            null,
            epsilon,
            new Vertex(boundingData[i][0], boundingData[i][1], null, epsilon, null, true),
            true
          )
        );
      }
      return boundingSites2;
    }
    return _weightedVoronoi;
  }
  function FlickeringMitigation() {
    this.growthChangesLength = DEFAULT_LENGTH;
    this.totalAvailableArea = NaN;
    this.lastAreaError = NaN;
    this.lastGrowth = NaN;
    this.growthChanges = [];
    this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
    this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
  }
  var DEFAULT_LENGTH = 10;
  function direction(h0, h1) {
    return h0 >= h1 ? 1 : -1;
  }
  function generateGrowthChangeWeights(length2) {
    let initialWeight = 3;
    let weightDecrement = 1;
    let minWeight = 1;
    let weightedCount = initialWeight;
    let growthChangeWeights = [];
    for (let i = 0; i < length2; i++) {
      growthChangeWeights.push(weightedCount);
      weightedCount -= weightDecrement;
      if (weightedCount < minWeight) {
        weightedCount = minWeight;
      }
    }
    return growthChangeWeights;
  }
  function computeGrowthChangeWeightsSum(growthChangeWeights) {
    let growthChangeWeightsSum = 0;
    for (let i = 0; i < growthChangeWeights.length; i++) {
      growthChangeWeightsSum += growthChangeWeights[i];
    }
    return growthChangeWeightsSum;
  }
  FlickeringMitigation.prototype.reset = function () {
    this.lastAreaError = NaN;
    this.lastGrowth = NaN;
    this.growthChanges = [];
    this.growthChangesLength = DEFAULT_LENGTH;
    this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
    this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
    this.totalAvailableArea = NaN;
    return this;
  };
  FlickeringMitigation.prototype.clear = function () {
    this.lastAreaError = NaN;
    this.lastGrowth = NaN;
    this.growthChanges = [];
    return this;
  };
  FlickeringMitigation.prototype.length = function (_) {
    if (!arguments.length) {
      return this.growthChangesLength;
    }
    if (parseInt(_) > 0) {
      this.growthChangesLength = Math.floor(parseInt(_));
      this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
      this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
    } else {
      console.warn('FlickeringMitigation.length() accepts only positive integers; unable to handle ' + _);
    }
    return this;
  };
  FlickeringMitigation.prototype.totalArea = function (_) {
    if (!arguments.length) {
      return this.totalAvailableArea;
    }
    if (parseFloat(_) > 0) {
      this.totalAvailableArea = parseFloat(_);
    } else {
      console.warn('FlickeringMitigation.totalArea() accepts only positive numbers; unable to handle ' + _);
    }
    return this;
  };
  FlickeringMitigation.prototype.add = function (areaError) {
    let secondToLastAreaError; var 
secondToLastGrowth;
    secondToLastAreaError = this.lastAreaError;
    this.lastAreaError = areaError;
    if (!isNaN(secondToLastAreaError)) {
      secondToLastGrowth = this.lastGrowth;
      this.lastGrowth = direction(this.lastAreaError, secondToLastAreaError);
    }
    if (!isNaN(secondToLastGrowth)) {
      this.growthChanges.unshift(this.lastGrowth != secondToLastGrowth);
    }
    if (this.growthChanges.length > this.growthChangesLength) {
      this.growthChanges.pop();
    }
    return this;
  };
  FlickeringMitigation.prototype.ratio = function () {
    let weightedChangeCount = 0;
    let ratio;
    if (this.growthChanges.length < this.growthChangesLength) {
      return 0;
    }
    if (this.lastAreaError > this.totalAvailableArea / 10) {
      return 0;
    }
    for (let i = 0; i < this.growthChangesLength; i++) {
      if (this.growthChanges[i]) {
        weightedChangeCount += this.growthChangeWeights[i];
      }
    }
    ratio = weightedChangeCount / this.growthChangeWeightsSum;
    return ratio;
  };
  function randomInitialPosition() {
    let clippingPolygon; var extent2; var minX; var maxX; var minY; var maxY; var dx; var 
dy;
    function _random(d, i, arr, voronoiMapSimulation2) {
      let shouldUpdateInternals = false;
      let x2; var 
y2;
      if (clippingPolygon !== voronoiMapSimulation2.clip()) {
        clippingPolygon = voronoiMapSimulation2.clip();
        extent2 = voronoiMapSimulation2.extent();
        shouldUpdateInternals = true;
      }
      if (shouldUpdateInternals) {
        updateInternals();
      }
      x2 = minX + dx * voronoiMapSimulation2.prng()();
      y2 = minY + dy * voronoiMapSimulation2.prng()();
      while (!d3PolygonContains(clippingPolygon, [x2, y2])) {
        x2 = minX + dx * voronoiMapSimulation2.prng()();
        y2 = minY + dy * voronoiMapSimulation2.prng()();
      }
      return [x2, y2];
    }
    
    function updateInternals() {
      minX = extent2[0][0];
      maxX = extent2[1][0];
      minY = extent2[0][1];
      maxY = extent2[1][1];
      dx = maxX - minX;
      dy = maxY - minY;
    }
    
    return _random;
  }
  
  function pie() {
    let startAngle = 0;
    let clippingPolygon; var dataArray; var dataArrayLength; var clippingPolygonCentroid; var halfIncircleRadius; var 
angleBetweenData;
    function _pie(d, i, arr, voronoiMapSimulation2) {
      let shouldUpdateInternals = false;
      if (clippingPolygon !== voronoiMapSimulation2.clip()) {
        clippingPolygon = voronoiMapSimulation2.clip();
        shouldUpdateInternals |= true;
      }
      if (dataArray !== arr) {
        dataArray = arr;
        shouldUpdateInternals |= true;
      }
      if (shouldUpdateInternals) {
        updateInternals();
      }
      return [
        clippingPolygonCentroid[0] + Math.cos(startAngle + i * angleBetweenData) * halfIncircleRadius + (voronoiMapSimulation2.prng()() - 0.5) * 1e-3,
        clippingPolygonCentroid[1] + Math.sin(startAngle + i * angleBetweenData) * halfIncircleRadius + (voronoiMapSimulation2.prng()() - 0.5) * 1e-3,
      ];
    }
    
    _pie.startAngle = function (_) {
      if (!arguments.length) {
        return startAngle;
      }
      startAngle = _;
      return _pie;
    };
    function updateInternals() {
      clippingPolygonCentroid = d3PolygonCentroid(clippingPolygon);
      halfIncircleRadius = computeMinDistFromEdges(clippingPolygonCentroid, clippingPolygon) / 2;
      dataArrayLength = dataArray.length;
      angleBetweenData = 2 * Math.PI / dataArrayLength;
    }
    
    function computeMinDistFromEdges(vertex, clippingPolygon2) {
      let minDistFromEdges = Infinity; var edgeIndex = 0; var edgeVertex0 = clippingPolygon2[clippingPolygon2.length - 1]; var 
edgeVertex1 = clippingPolygon2[edgeIndex];
      let distFromCurrentEdge;
      while (edgeIndex < clippingPolygon2.length) {
        distFromCurrentEdge = vDistance(vertex, edgeVertex0, edgeVertex1);
        if (distFromCurrentEdge < minDistFromEdges) {
          minDistFromEdges = distFromCurrentEdge;
        }
        edgeIndex++;
        edgeVertex0 = edgeVertex1;
        edgeVertex1 = clippingPolygon2[edgeIndex];
      }
      return minDistFromEdges;
    }
    function vDistance(vertex, edgeVertex0, edgeVertex1) {
      let x2 = vertex[0]; var y2 = vertex[1]; var x1 = edgeVertex0[0]; var y1 = edgeVertex0[1]; var x22 = edgeVertex1[0]; var 
y22 = edgeVertex1[1];
      let A = x2 - x1; var B = y2 - y1; var C = x22 - x1; var 
D = y22 - y1;
      let dot2 = A * C + B * D;
      let len_sq = C * C + D * D;
      let param = -1;
      if (len_sq != 0) {param = dot2 / len_sq;}
      let xx; var 
yy;
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x22;
        yy = y22;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      let dx = x2 - xx;
      let dy = y2 - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }
    return _pie;
  }
  function halfAverageAreaInitialWeight() {
    let clippingPolygon; var dataArray; var siteCount; var totalArea; var 
halfAverageArea;
    function _halfAverageArea(d, i, arr, voronoiMapSimulation2) {
      let shouldUpdateInternals = false;
      if (clippingPolygon !== voronoiMapSimulation2.clip()) {
        clippingPolygon = voronoiMapSimulation2.clip();
        shouldUpdateInternals |= true;
      }
      if (dataArray !== arr) {
        dataArray = arr;
        shouldUpdateInternals |= true;
      }
      if (shouldUpdateInternals) {
        updateInternals();
      }
      return halfAverageArea;
    }
    
    function updateInternals() {
      siteCount = dataArray.length;
      totalArea = d3PolygonArea(clippingPolygon);
      halfAverageArea = totalArea / siteCount / 2;
    }
    return _halfAverageArea;
  }
  
  function d3VoronoiMapError(message) {
    this.message = message;
    this.stack = new Error().stack;
  }
  d3VoronoiMapError.prototype.name = 'd3VoronoiMapError';
  d3VoronoiMapError.prototype = new Error();
  function voronoiMapSimulation(data) {
    let DEFAULT_CONVERGENCE_RATIO = 0.01;
    let DEFAULT_MAX_ITERATION_COUNT = 50;
    let DEFAULT_MIN_WEIGHT_RATIO = 0.01;
    let DEFAULT_PRNG = Math.random;
    let DEFAULT_INITIAL_POSITION = randomInitialPosition();
    let DEFAULT_INITIAL_WEIGHT = halfAverageAreaInitialWeight();
    let RANDOM_INITIAL_POSITION = randomInitialPosition();
    let epsilon2 = 1e-10;
    let weight = function (d) {
      return d.weight;
    };
    let convergenceRatio = DEFAULT_CONVERGENCE_RATIO;
    let maxIterationCount = DEFAULT_MAX_ITERATION_COUNT;
    let minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO;
    let prng = DEFAULT_PRNG;
    let initialPosition = DEFAULT_INITIAL_POSITION;
    let initialWeight = DEFAULT_INITIAL_WEIGHT;
    let weightedVoronoi$1 = weightedVoronoi(); var flickeringMitigation = new FlickeringMitigation(); var shouldInitialize = true; var siteCount; var totalArea; var areaErrorTreshold; var iterationCount; var polygons; var areaError; var converged; var 
ended;
    let simulation; var stepper = timer(step2); var 
event2 = dispatch('tick', 'end');
    const HANDLE_OVERWEIGHTED_VARIANT = 1;
    const HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT = 1e3;
    let handleOverweighted;
    function sqr(d) {
      return d**2;
    }
    function squaredDistance(s0, s1) {
      return sqr(s1.x - s0.x) + sqr(s1.y - s0.y);
    }
    simulation = {
      tick,
      restart() {
        stepper.restart(step2);
        return simulation;
      },
      stop() {
        stepper.stop();
        return simulation;
      },
      weight(_) {
        if (!arguments.length) {
          return weight;
        }
        weight = _;
        shouldInitialize = true;
        return simulation;
      },
      convergenceRatio(_) {
        if (!arguments.length) {
          return convergenceRatio;
        }
        convergenceRatio = _;
        shouldInitialize = true;
        return simulation;
      },
      maxIterationCount(_) {
        if (!arguments.length) {
          return maxIterationCount;
        }
        maxIterationCount = _;
        return simulation;
      },
      minWeightRatio(_) {
        if (!arguments.length) {
          return minWeightRatio;
        }
        minWeightRatio = _;
        shouldInitialize = true;
        return simulation;
      },
      clip(_) {
        if (!arguments.length) {
          return weightedVoronoi$1.clip();
        }
        weightedVoronoi$1.clip(_);
        shouldInitialize = true;
        return simulation;
      },
      extent(_) {
        if (!arguments.length) {
          return weightedVoronoi$1.extent();
        }
        weightedVoronoi$1.extent(_);
        shouldInitialize = true;
        return simulation;
      },
      size(_) {
        if (!arguments.length) {
          return weightedVoronoi$1.size();
        }
        weightedVoronoi$1.size(_);
        shouldInitialize = true;
        return simulation;
      },
      prng(_) {
        if (!arguments.length) {
          return prng;
        }
        prng = _;
        shouldInitialize = true;
        return simulation;
      },
      initialPosition(_) {
        if (!arguments.length) {
          return initialPosition;
        }
        initialPosition = _;
        shouldInitialize = true;
        return simulation;
      },
      initialWeight(_) {
        if (!arguments.length) {
          return initialWeight;
        }
        initialWeight = _;
        shouldInitialize = true;
        return simulation;
      },
      state() {
        if (shouldInitialize) {
          initializeSimulation();
        }
        return {
          ended,
          iterationCount,
          convergenceRatio: areaError / totalArea,
          polygons
        };
      },
      on(name, _) {
        if (arguments.length === 1) {
          return event2.on(name);
        }
        event2.on(name, _);
        return simulation;
      }
    };
    function step2() {
      tick();
      event2.call('tick', simulation);
      if (ended) {
        stepper.stop();
        event2.call('end', simulation);
      }
    }
    function tick() {
      if (!ended) {
        if (shouldInitialize) {
          initializeSimulation();
        }
        polygons = adapt(polygons, flickeringMitigation.ratio());
        iterationCount++;
        areaError = computeAreaError(polygons);
        flickeringMitigation.add(areaError);
        converged = areaError < areaErrorTreshold;
        ended = converged || iterationCount >= maxIterationCount;
      }
    }
    function initializeSimulation() {
      setHandleOverweighted();
      siteCount = data.length;
      totalArea = Math.abs(d3PolygonArea(weightedVoronoi$1.clip()));
      areaErrorTreshold = convergenceRatio * totalArea;
      flickeringMitigation.clear().totalArea(totalArea);
      iterationCount = 0;
      converged = false;
      polygons = initialize(data, simulation);
      ended = false;
      shouldInitialize = false;
    }
    function initialize(data2, simulation2) {
      let maxWeight = data2.reduce((max2, d) => {
          return Math.max(max2, weight(d));
        }, -Infinity); var 
minAllowedWeight = maxWeight * minWeightRatio;
      let weights; var 
mapPoints;
      weights = data2.map((d, i, arr) => {
        return {
          index: i,
          weight: Math.max(weight(d), minAllowedWeight),
          initialPosition: initialPosition(d, i, arr, simulation2),
          initialWeight: initialWeight(d, i, arr, simulation2),
          originalData: d,
        };
      });
      mapPoints = createMapPoints(weights, simulation2);
      handleOverweighted(mapPoints);
      return weightedVoronoi$1(mapPoints);
    }
    function createMapPoints(basePoints, simulation2) {
      let totalWeight = basePoints.reduce((acc, bp) => {
        return acc += bp.weight;
      }, 0);
      let initialPosition2;
      return basePoints.map((bp, i, bps) => {
        initialPosition2 = bp.initialPosition;
        if (!d3PolygonContains(weightedVoronoi$1.clip(), initialPosition2)) {
          initialPosition2 = DEFAULT_INITIAL_POSITION(bp, i, bps, simulation2);
        }
        return {
          index: bp.index,
          targetedArea: totalArea * bp.weight / totalWeight,
          data: bp,
          x: initialPosition2[0],
          y: initialPosition2[1],
          weight: bp.initialWeight,
          // ArlindNocaj/Voronoi-Treemap-Library uses an epsilonesque initial weight; using heavier initial weights allows faster weight adjustements, hence faster stabilization
        };
      });
    }
    function adapt(polygons2, flickeringMitigationRatio) {
      let adaptedMapPoints;
      adaptPositions(polygons2, flickeringMitigationRatio);
      adaptedMapPoints = polygons2.map((p) => {
        return p.site.originalObject;
      });
      polygons2 = weightedVoronoi$1(adaptedMapPoints);
      if (polygons2.length < siteCount) {
        throw new d3VoronoiMapError('at least 1 site has no area, which is not supposed to arise');
      }
      adaptWeights(polygons2, flickeringMitigationRatio);
      adaptedMapPoints = polygons2.map((p) => {
        return p.site.originalObject;
      });
      polygons2 = weightedVoronoi$1(adaptedMapPoints);
      if (polygons2.length < siteCount) {
        throw new d3VoronoiMapError('at least 1 site has no area, which is not supposed to arise');
      }
      return polygons2;
    }
    function adaptPositions(polygons2, flickeringMitigationRatio) {
      let newMapPoints = []; var 
flickeringInfluence = 0.5;
      let flickeringMitigation2; var d; var polygon; var mapPoint; var centroid2; var dx; var 
dy;
      flickeringMitigation2 = flickeringInfluence * flickeringMitigationRatio;
      d = 1 - flickeringMitigation2;
      for (let i = 0; i < siteCount; i++) {
        polygon = polygons2[i];
        mapPoint = polygon.site.originalObject;
        centroid2 = d3PolygonCentroid(polygon);
        dx = centroid2[0] - mapPoint.x;
        dy = centroid2[1] - mapPoint.y;
        dx *= d;
        dy *= d;
        mapPoint.x += dx;
        mapPoint.y += dy;
        newMapPoints.push(mapPoint);
      }
      handleOverweighted(newMapPoints);
    }
    function adaptWeights(polygons2, flickeringMitigationRatio) {
      let newMapPoints = []; var 
flickeringInfluence = 0.1;
      let flickeringMitigation2; var polygon; var mapPoint; var currentArea; var adaptRatio; var 
adaptedWeight;
      flickeringMitigation2 = flickeringInfluence * flickeringMitigationRatio;
      for (let i = 0; i < siteCount; i++) {
        polygon = polygons2[i];
        mapPoint = polygon.site.originalObject;
        currentArea = d3PolygonArea(polygon);
        adaptRatio = mapPoint.targetedArea / currentArea;
        adaptRatio = Math.max(adaptRatio, 1 - flickeringInfluence + flickeringMitigation2);
        adaptRatio = Math.min(adaptRatio, 1 + flickeringInfluence - flickeringMitigation2);
        adaptedWeight = mapPoint.weight * adaptRatio;
        adaptedWeight = Math.max(adaptedWeight, epsilon2);
        mapPoint.weight = adaptedWeight;
        newMapPoints.push(mapPoint);
      }
      handleOverweighted(newMapPoints);
    }
    function handleOverweighted0(mapPoints) {
      let fixCount = 0;
      let fixApplied; var tpi; var tpj; var weightest; var lightest; var sqrD; var 
adaptedWeight;
      do {
        if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {
          throw new d3VoronoiMapError('handleOverweighted0 is looping too much');
        }
        fixApplied = false;
        for (let i = 0; i < siteCount; i++) {
          tpi = mapPoints[i];
          for (let j = i + 1; j < siteCount; j++) {
            tpj = mapPoints[j];
            if (tpi.weight > tpj.weight) {
              weightest = tpi;
              lightest = tpj;
            } else {
              weightest = tpj;
              lightest = tpi;
            }
            sqrD = squaredDistance(tpi, tpj);
            if (sqrD < weightest.weight - lightest.weight) {
              adaptedWeight = sqrD + lightest.weight / 2;
              adaptedWeight = Math.max(adaptedWeight, epsilon2);
              weightest.weight = adaptedWeight;
              fixApplied = true;
              fixCount++;
              break;
            }
          }
          if (fixApplied) {
            break;
          }
        }
      } while (fixApplied);
    }
    function handleOverweighted1(mapPoints) {
      let fixCount = 0;
      let fixApplied; var tpi; var tpj; var weightest; var lightest; var sqrD; var 
overweight;
      do {
        if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {
          throw new d3VoronoiMapError('handleOverweighted1 is looping too much');
        }
        fixApplied = false;
        for (let i = 0; i < siteCount; i++) {
          tpi = mapPoints[i];
          for (let j = i + 1; j < siteCount; j++) {
            tpj = mapPoints[j];
            if (tpi.weight > tpj.weight) {
              weightest = tpi;
              lightest = tpj;
            } else {
              weightest = tpj;
              lightest = tpi;
            }
            sqrD = squaredDistance(tpi, tpj);
            if (sqrD < weightest.weight - lightest.weight) {
              overweight = weightest.weight - lightest.weight - sqrD;
              lightest.weight += overweight + epsilon2;
              fixApplied = true;
              fixCount++;
              break;
            }
          }
          if (fixApplied) {
            break;
          }
        }
      } while (fixApplied);
    }
    function computeAreaError(polygons2) {
      let areaErrorSum = 0;
      let polygon; var mapPoint; var 
currentArea;
      for (let i = 0; i < siteCount; i++) {
        polygon = polygons2[i];
        mapPoint = polygon.site.originalObject;
        currentArea = d3PolygonArea(polygon);
        areaErrorSum += Math.abs(mapPoint.targetedArea - currentArea);
      }
      return areaErrorSum;
    }
    function setHandleOverweighted() {
      switch (HANDLE_OVERWEIGHTED_VARIANT) {
        case 0:
          handleOverweighted = handleOverweighted0;
          break;
        case 1:
          handleOverweighted = handleOverweighted1;
          break;
        default:
          console.error("unknown 'handleOverweighted' variant; using variant #1");
          handleOverweighted = handleOverweighted0;
      }
    }
    return simulation;
  }
  function voronoiTreemap() {
    let DEFAULT_CONVERGENCE_RATIO = 0.01;
    let DEFAULT_MAX_ITERATION_COUNT = 50;
    let DEFAULT_MIN_WEIGHT_RATIO = 0.01;
    let DEFAULT_PRNG = Math.random;
    let clip = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
    ];
    let extent2 = [
      [0, 0],
      [1, 1],
    ];
    let size = [1, 1];
    let convergenceRatio = DEFAULT_CONVERGENCE_RATIO;
    let maxIterationCount = DEFAULT_MAX_ITERATION_COUNT;
    let minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO;
    let prng = DEFAULT_PRNG;
    let unrelevantButNeedeData = [
      {
        weight: 1,
      },
      {
        weight: 1,
      }
    ];
    let _convenientReusableVoronoiMapSimulation = voronoiMapSimulation(unrelevantButNeedeData).stop();
    function _voronoiTreemap(rootNode) {
      recurse(clip, rootNode);
    }
    _voronoiTreemap.convergenceRatio = function (_) {
      if (!arguments.length) {
        return convergenceRatio;
      }
      convergenceRatio = _;
      return _voronoiTreemap;
    };
    _voronoiTreemap.maxIterationCount = function (_) {
      if (!arguments.length) {
        return maxIterationCount;
      }
      maxIterationCount = _;
      return _voronoiTreemap;
    };
    _voronoiTreemap.minWeightRatio = function (_) {
      if (!arguments.length) {
        return minWeightRatio;
      }
      minWeightRatio = _;
      return _voronoiTreemap;
    };
    _voronoiTreemap.clip = function (_) {
      if (!arguments.length) {
        return clip;
      }
      _convenientReusableVoronoiMapSimulation.clip(_);
      clip = _convenientReusableVoronoiMapSimulation.clip();
      extent2 = _convenientReusableVoronoiMapSimulation.extent();
      size = _convenientReusableVoronoiMapSimulation.size();
      return _voronoiTreemap;
    };
    _voronoiTreemap.extent = function (_) {
      if (!arguments.length) {
        return extent2;
      }
      _convenientReusableVoronoiMapSimulation.extent(_);
      clip = _convenientReusableVoronoiMapSimulation.clip();
      extent2 = _convenientReusableVoronoiMapSimulation.extent();
      size = _convenientReusableVoronoiMapSimulation.size();
      return _voronoiTreemap;
    };
    _voronoiTreemap.size = function (_) {
      if (!arguments.length) {
        return size;
      }
      _convenientReusableVoronoiMapSimulation.size(_);
      clip = _convenientReusableVoronoiMapSimulation.clip();
      extent2 = _convenientReusableVoronoiMapSimulation.extent();
      size = _convenientReusableVoronoiMapSimulation.size();
      return _voronoiTreemap;
    };
    _voronoiTreemap.prng = function (_) {
      if (!arguments.length) {
        return prng;
      }
      prng = _;
      return _voronoiTreemap;
    };
    function recurse(clippingPolygon, node) {
      let simulation;
      node.polygon = clippingPolygon;
      if (node.height != 0) {
        simulation = voronoiMapSimulation(node.children).clip(clippingPolygon).weight((d) => {
          return d.value;
        }).convergenceRatio(convergenceRatio)
.maxIterationCount(maxIterationCount)
.minWeightRatio(minWeightRatio)
.prng(prng)
.stop();
        let state = simulation.state();
        while (!state.ended) {
          simulation.tick();
          state = simulation.state();
        }
        state.polygons.forEach((cp) => {
          recurse(cp, cp.site.originalObject.data.originalData);
        });
      }
    }
    return _voronoiTreemap;
  }
  function createVoronoiTreemap(data, options, chartComponents) {
    const { svg } = chartComponents;
    const layout = voronoiTreemap().size([options.width, options.height]);
    const root = d3.hierarchy(data).sum((d) => d.value);
    layout(root);
    const cells = root.descendants().filter((d) => d.depth);
    const categoryColor = d3.scaleOrdinal(d3.schemeCategory10);
    const groups2 = svg.selectAll('g').data(cells).enter().append('g')
.attr('fill', (d) => {
      if (d.depth === 1) {
        return categoryColor(d.data.name);
      }
      if (d.depth === 2) {
        const parentCategory = d.parent.data.name;
        const parentColor = categoryColor(parentCategory);
        const interpolator = d3.interpolateRgbBasis([parentColor, 'white']);
        return interpolator(d.data.value / d.parent.value);
      }
    })
.attr('stroke', `${options.strokeColor}`)
.attr('font-size', `${options.parentTextSize}`);
    groups2.append('path').attr('d', (d) => d3.line().curve(d3.curveLinearClosed)(d.polygon)).attr('opacity', 0.8).attr('stroke-width', `${options.strokeWidth}` || 1);
    groups2.append('text').attr('x', (d) => d3.polygonCentroid(d.polygon)[0]).attr('y', (d) => d3.polygonCentroid(d.polygon)[1]).attr('text-anchor', `${options.textAnchor}}`)
.attr('dy', '.35em')
.text((d) => d.data.name)
.style('font-size', `${options.childTextSize}`)
.style('fill', 'white');
  }
  function createD3WaterfallChart(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    svg.append('g').selectAll('rect').data(data).join('rect')
.attr('x', (d) => x2(d.category))
.attr('y', (d) => y2(d.start))
.attr('height', (d) => Math.abs(y2(d.end) - y2(d.start)))
.attr('width', x2.bandwidth())
.attr('fill', options.color);
  }
  function createWordCloud(data, options, chartComponents) {
    const { width, height, y2ForceStrength } = options;
    const fontSize = (d) => Math.sqrt(d.value) * 2;
    const { svg } = chartComponents;
    const radiusScale2 = d3.scaleSqrt().domain([0, d3.max(data, (d) => d.value)]).range([0, options.maxRadius]);
    const clusterStrengthVal = 5e-3;
    const simulation = d3.forceSimulation(data).force('charge', d3.forceManyBody().strength(options.chargeStrength)).force('center', d3.forceCenter(width / 2, height / 2)).force('collision', d3.forceCollide().radius((d) => radiusScale2(d.value) + 1))
.force('y2Force', y2Force(y2ForceStrength))
.force('clusterForce', clusterForce2(clusterStrengthVal, data))
.on('tick', ticked);
    const uniqueY2Values = Array.from(new Set(data.map((d) => d.y2)));
    const colorScales = {
      0.2: d3.interpolatePlasma,
      0.5: d3.interpolateViridis,
      0.8: d3.interpolateInferno,
    };
    if (options.bubble) {
      const nodes = svg.selectAll('circle').data(data).enter().append('circle')
.attr('r', (d) => radiusScale2(d.value))
.style('fill', (d) => {
        if (d.y2 !== void 0) {
          console.log('COLOR SCALES', colorScales[d.y2], 'VALUE', d.v);
          return colorScales[d.y2](d.value / 1e3);
        }
        return d3.schemeCategory10[d.value % 10];
      })
.style('opacity', options.bubbleOpacity);
    }
    const labels = svg.selectAll('text').data(data).enter().append('text')
.attr('dy', '.35em')
.style('text-anchor', 'middle')
.style('font-size', (d) => `${fontSize(d)}px`)
.style('fill', 'black')
.text((d) => d.name);
    function ticked() {
      if (options.bubble) {
        svg.selectAll('circle').attr('cx', (d) => Math.max(radiusScale2(d.value), Math.min(width - radiusScale2(d.value), d.x))).attr('cy', (d) => Math.max(radiusScale2(d.value), Math.min(height - radiusScale2(d.value), d.y)));
      }
      labels.attr('x', (d) => Math.max(fontSize(d) / 2, Math.min(width - fontSize(d) / 2, d.x))).attr('y', (d) => Math.max(fontSize(d) / 2, Math.min(height - fontSize(d) / 2, d.y)));
    }
    function y2Force(strength) {
      return (alpha) => {
        data.forEach((d) => {
          if (d.y2 !== void 0) {
            const targetY = height * d.y2;
            d.vy += (targetY - d.value) * strength * alpha;
          }
        });
      };
    }
    function clusterForce2(strength, data2) {
      return (alpha) => {
        data2.forEach((d) => {
          if (d.y2 !== void 0) {
            const targetBubbles = data2.filter((bubble) => bubble.y2 === d.y2);
            targetBubbles.forEach((target) => {
              if (target !== d) {
                const dx = d.x - target.x;
                const dy = d.y - target.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const desiredDistance = (radiusScale2(d.value) + radiusScale2(target.value)) * strength;
                if (distance < desiredDistance) {
                  const k2 = (distance - desiredDistance) / distance * alpha;
                  d.vx -= dx * k2;
                  d.vy -= dy * k2;
                  target.vx += dx * k2;
                  target.vy += dy * k2;
                }
              }
            });
          }
        });
      };
    }
  }
  function clusterForce(strength, data) {
    return (alpha) => {
      data.forEach((d) => {
        if (d.y2 !== void 0) {
          const targetBubbles = data.filter((bubble) => bubble.y2 === d.y2);
          targetBubbles.forEach((target) => {
            if (target !== d) {
              const dx = d.x - target.x;
              const dy = d.y - target.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const desiredDistance = (radiusScale(d.value) + radiusScale(target.value)) * strength;
              if (distance < desiredDistance) {
                const k2 = (distance - desiredDistance) / distance * alpha;
                d.vx -= dx * k2;
                d.vy -= dy * k2;
                target.vx += dx * k2;
                target.vy += dy * k2;
              }
            }
          });
        }
      });
    };
  }
  class D3ChartTypes {
    constructor() {
      const types = {
        adjacency: {
          _selfKey: 'adjacency',
          name: 'Adjacency',
          nameLong: 'Adjacency Matrix',
          render: createAdjacencyMatrix,
        },
        area: {
          _selfKey: 'area',
          chartClass: 'area-chart',
          name: 'Area',
          nameLong: 'Area Chart',
          render: createD3AreaChart,
        },
        bar: {
          _selfKey: 'bar',
          chartClass: 'bar-chart',
          name: 'Bar',
          nameLong: 'Bar Chart',
          render: createD3BarChart,
        },
        box: {
          _selfKey: 'box',
          chartClass: 'box-plot',
          name: 'Box',
          nameLong: 'Box Plot',
          render: createD3BoxPlot,
        },
        bubble: {
          _selfKey: 'bubble',
          chartClass: 'bubble-chart',
          name: 'Bubble',
          nameLong: 'Bubble Chart',
          render: createBubbleChart,
        },
        chord: {
          _selfKey: 'chord',
          name: 'Chord',
          nameLong: 'Chord Diagram',
          render: createChordDiagram,
        },
        cloud: {
          _selfKey: 'cloud',
          name: 'Cloud',
          nameLong: 'Cloud Diagram',
          render: createWordCloud,
        },
        cluster: {
          _selfKey: 'cluster',
          name: 'Cluster',
          nameLong: 'Cluster Diagram',
          render: createClusterDiagram,
        },
        dendrogram: {
          _selfKey: 'dendrogram',
          name: 'Dendrogram',
          nameLong: 'Dendrogram Chart',
          render: createDendrogram,
        },
        donut: {
          _selfKey: 'donut',
          chartClass: 'donut-chart',
          name: 'Donut',
          nameLong: 'Donut Chart',
          render: createD3DonutChart,
        },
        funnel: {
          _selfKey: 'funnel',
          chartClass: 'funnel-chart',
          name: 'Funnel',
          nameLong: 'Funnel Chart',
          render: createD3FunnelChart,
        },
        gauge: {
          _selfKey: 'gauge',
          chartClass: 'gauge-chart',
          name: 'Gauge',
          nameLong: 'Gauge Chart',
          render: createD3GaugeChart,
        },
        heat: {
          // TODO note: was previously 'heat-map', verify if is now type-safe to use 'heat'
          _selfKey: 'heat',
          chartClass: 'heat-map',
          name: 'Heat',
          nameLong: 'Heat Map',
          render: createD3Heatmap,
        },
        icicle: {
          _selfKey: 'icicle',
          name: 'Icicle',
          nameLong: 'Icicle Plot',
          render: createIcicleChart,
        },
        line: {
          _selfKey: 'line',
          chartClass: 'line-graph',
          name: 'Line',
          nameLong: 'Line Graph',
          render: createD3LineGraph,
        },
        marimekko: {
          _selfKey: 'marimekko',
          name: 'Marimekko',
          nameLong: 'Marimekko Diagram',
          render: createMarimekkoChart,
        },
        pie: {
          _selfKey: 'pie',
          chartClass: 'pie-chart',
          name: 'Pie',
          nameLong: 'Pie Chart',
          render: createD3PieChart,
        },
        polar: {
          _selfKey: 'polar',
          chartClass: 'polar-chart',
          name: 'Polar',
          nameLong: 'Polar Chart',
          render: createD3PolarChart,
        },
        radar: {
          _selfKey: 'radar',
          chartClass: 'radar-chart',
          name: 'Radar',
          nameLong: 'Radar Chart',
          render: createD3RadarChart,
        },
        radialTree: {
          _selfKey: 'radialTree',
          name: 'Radial Tree',
          nameLong: 'Radial Tree Diagram',
          render: createRadialTree,
        },
        sankey: {
          _selfKey: 'sankey',
          name: 'Sankey',
          nameLong: 'Sankey Diagram',
          render: createSankeyDiagram,
        },
        scatter: {
          _selfKey: 'scatter',
          chartClass: 'scatter-plot',
          name: 'Scatter',
          nameLong: 'Scatter Plot',
          render: createD3ScatterPlot,
        },
        stackedbar: {
          _selfKey: 'stackedbar',
          chartClass: 'stacked-bar-chart-plot',
          // TODO match more closely with key
          name: 'Stacked Bar',
          nameLong: 'Stacked Bar Chart',
          render: createD3StackedBarChart,
        },
        sun: {
          _selfKey: 'sun',
          name: 'Sun Burst',
          nameLong: 'Sun Burst Diagram',
          render: createD3SunburstChart,
        },
        treeDiagram: {
          _selfKey: 'treeDiagram',
          name: 'Tree Diagram',
          nameLong: 'Tree Diagram',
          render: createTreeDiagram,
        },
        treeMap: {
          _selfKey: 'treeMap',
          name: 'Tree Map',
          nameLong: 'Tree Map',
          render: createD3TreeMap,
        },
        voronoi: {
          _selfKey: 'voronoi',
          name: 'Voronoi',
          nameLong: 'Voronoi Diagram',
          render: createVoronoiTreemap,
        },
        waterfall: {
          _selfKey: 'waterfall',
          chartClass: 'waterfall-chart',
          name: 'Waterfall',
          nameLong: 'Waterfall Chart',
          render: createD3WaterfallChart,
        }
      };
      Object.assign(this, types);
    }
  }
  const d3OptionShape = {
    _selfKey: 'string',
    barWidth: 'number',
    color: 'string',
    height: 'number',
    margin: {
      bottom: 'number',
      left: 'number',
      right: 'number',
      top: 'number'
    },
    // negativeColor: 'string', // WIP
    overlay: 'boolean',
    // positiveColor: 'string', // WIP
    width: 'number',
    xAxisColor: 'string',
    xAxisPosition: 'number',
    // xDomain: 'object', // WIP
    xLabelOffsetX: 'number',
    xLabelOffsetY: 'number',
    xLabelRotation: 'number',
    xTickExtension: 'number',
    xTickFrequency: 'number',
    xTickLength: 'number',
    xTickOpacity: 'number',
    yAxisColor: 'string',
    yAxisPosition: 'number',
    // yDomain: 'object', // WIP
    yLabelOffsetX: 'number',
    yLabelOffsetY: 'number',
    yLabelRotation: 'number',
    yTickExtension: 'number',
    yTickFrequency: 'number',
    yTickLength: 'number',
    yTickOpacity: 'number'
  };
  const validOptionShapeTypes = ['string', 'number', 'boolean'];
  function validateOptionShape(shape, input) {
    Object.keys(shape).forEach((key) => {
      if (typeof shape[key] === 'object') {
        validateOptionShape(shape[key], input[key]);
      } else {
        if (!validOptionShapeTypes.includes(shape[key])) {
          throw new Error(`Invalid type specified for ${key}`);
        }
        if (typeof input[key] !== shape[key]) {
          throw new Error(`${key} must be a ${shape[key]}`);
        }
      }
    });
  }
  function validateOptions(data, selector, options) {
    if (typeof selector !== 'string' || !selector) {
      throw new Error('Invalid selector. Selector should be a non-empty string.');
    }
    if (typeof options !== 'object' || !options) {
      throw new Error('Invalid options. Options should be a non-null object.');
    }
    const { width, height, margin } = options;
    if (typeof width !== 'number' || width <= 0) {
      throw new Error('Invalid width. Width should be a positive number.');
    }
    if (typeof height !== 'number' || height <= 0) {
      throw new Error('Invalid height. Height should be a positive number.');
    }
    if (typeof margin !== 'object' || !margin) {
      throw new Error('Invalid margin. Margin should be a non-null object.');
    }
    if (!['top', 'right', 'bottom', 'left'].every((prop) => typeof margin[prop] === 'number')) {
      throw new Error('Invalid margin. Margin should have "top", "right", "bottom", and "left" properties with numeric values.');
    }
  }
  const d3ChartTypes$1 = new D3ChartTypes();
  class D3Visualizer {
    constructor(chartArray, data, options, selector = '#chart') {
      this.chartArray = chartArray;
      this.data = data;
      this.options = options;
      this.selector = selector;
      validateOptionShape(d3OptionShape, this.options[0]);
      this.processCharts();
    }

    // addCharts(type) { // This method probably needs to be refactored
    //   this.chartArray.push(...type);
    //   for (let i = 0; i < type.length; i++) {
    //     this.createChart[type[i]](this.data, this.options, this.chartComponents);
    //     appendAxes(this.chartArray[i], this.options, this.chartComponents);
    //   }
    // }
    processCharts() {
      for (let i = 0; i < this.chartArray.length; i++) {
        this.options[i].chartClass = d3ChartTypes$1[this.chartArray[i]].chartClass;
        this.options[i].chartNumber = i;
        if (shouldCreateChartComponents.call(this, i) || this.options[0].isUpdating) {
          this.chartComponents = createChartComponents.call(this, i);
        }
        if (!this.options[0].isUpdating) {
          const { render } = d3ChartTypes$1[this.chartArray[i]];
          render(this.data[i], this.options[i], this.chartComponents);
        }
        applyOptions.call(this, i);
        applyActions.call(this, i);
      }
    }

    removeChart() {
      d3.select(this.selector).selectAll(`svg.${this.options[0].chartClass}`).remove();
      console.log('removed', this.options.chartClass);
    }

    updateInput(data, options, selector = '#chart') {
      this.options = options;
      if (options[0].animate) {
        this.options[0].isUpdating = true;
      }
      this.data = data;
      this.selector = selector;
      this.processCharts();
    }
  }
  function applyActions(i) {
    const options = this.options[i];
    if (!this.options[0].isUpdating) {
      const axisBBox = appendAxes(this.chartArray[i], options, this.chartComponents);
      this.chartComponents.xAxisBBox = axisBBox.xAxisBBox ? axisBBox.xAxisBBox : null;
      this.chartComponents.yAxisBBox = axisBBox.yAxisBBox ? axisBBox.yAxisBBox : null;
    }
    if (options.gradient) {
      addGradient(
        this.selector,
        this.chartArray[i],
        this.chartComponents,
        this.data[i],
        options
      );
    }
    if (options.onHover) {
      onHover(this.selector, this.options);
    }
    if (options.relativeNodeSize) {
      adjustNodeSize(this.selector, this.data[i], options);
    }
    if (options.animate && this.options[0].isUpdating) {
      addAnimation(
        this.selector,
        this.data[i],
        options,
        this.chartComponents,
        options.duration
      );
    }
  }
  function applyOptions(i) {
    const options = this.options[i];
    const { isUpdating } = this.options[0];
    const allElements = d3.selectAll(`svg.${options.chartClass} circle, arc, rect, path, line, polygon, node`);
    const excludedElements = d3.selectAll('.y-axis, .x-axis, .shape-label, .shape-pointer, .y-axis * , .x-axis *');
    const elements = allElements.filter(function () {
      const currentElement = d3.select(this);
      return !excludedElements.nodes().includes(currentElement.node());
    });
    elements.each(function () {
      const element = d3.select(this);
      const { classList } = this;
      if (classList.length === 0) {
        element.classed(`${options.chartClass}${i}`, true);
      }
      if (options.opacity && classList[0] === `${options.chartClass}${i}`) {
        element.style('opacity', options.opacity);
      }
      if (options.boxShadow) {
        element.style('filter', 'drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5))');
      }
      if (isUpdating) {
        elements.attr('fill', `${options.color}`);
        elements.attr('data-initialFill', `${options.color}`);
        console.log(options.color, i);
      }
    });
  }
  function createChartComponents(i) {
    const chartComponents = createAxes(this.data[i], this.chartArray[i], this.options[i]);
    if (!this.options[0].isUpdating) {
      chartComponents.svg = createSVG(this.selector, this.chartArray[i], this.options[i]);
    }
    return chartComponents;
  }
  function shouldCreateChartComponents(i) {
    const isFirstStackedChart = this.options[i].stack && i === 0;
    const isNotUpdating = !this.options[0].isUpdating;
    const isNotStackedChart = !this.options[i].stack;
    return isFirstStackedChart && isNotUpdating || isNotStackedChart && isNotUpdating;
  }
  class OomphInterface {
    constructor(interfaceType) {
      this.interface = interfaceType;
    }

    render() {
      console.log(`Rendering interface (placeholder): ${this.interface}`);
    }
  }
  const chartTypes$2 = new D3ChartTypes();
  const optionTypes = new D3OptionTypes();
  function createChartToOptionAssociations() {
    try {
      const associations = {
        [chartTypes$2.area._selfKey]: [
          optionTypes.options2._selfKey,
        ],
        [chartTypes$2.bar._selfKey]: [
          optionTypes.options5._selfKey,
        ],
        [chartTypes$2.box._selfKey]: [
          optionTypes.options3._selfKey,
        ],
        [chartTypes$2.bubble._selfKey]: [
          optionTypes.options10._selfKey,
        ],
        [chartTypes$2.donut._selfKey]: [
          optionTypes.options4._selfKey,
        ],
        [chartTypes$2.funnel._selfKey]: [
          optionTypes.funnelChart._selfKey,
        ],
        [chartTypes$2.gauge._selfKey]: [
          optionTypes.gauge._selfKey,
        ],
        [chartTypes$2.heat._selfKey]: [
          // TODO note: was previously 'heat-map', verify now type-safe to use 'heat'
          optionTypes.options3._selfKey,
        ],
        [chartTypes$2.line._selfKey]: [
          optionTypes.options9._selfKey,
        ],
        [chartTypes$2.pie._selfKey]: [
          optionTypes.options6._selfKey,
        ],
        [chartTypes$2.polar._selfKey]: [
          optionTypes.polarChart._selfKey,
        ],
        [chartTypes$2.radar._selfKey]: [
          optionTypes.radarChart._selfKey,
        ],
        [chartTypes$2.scatter._selfKey]: [
          optionTypes.options3._selfKey,
        ],
        [chartTypes$2.stackedbar._selfKey]: [
          optionTypes.options7._selfKey,
        ],
        [chartTypes$2.waterfall._selfKey]: [
          optionTypes.waterfall._selfKey,
        ]
      };
      return associations;
    } catch (error) {
      console.error(`Possible reference to non-existent chart or option type: ${error.message}`);
      return {};
    }
  }
  const chartToOptionAssociations = createChartToOptionAssociations();
  function getChartToOptionAssociations(charts) {
    if (!charts || charts.length === 0) {
      console.error('No charts provided.');
      return [];
    }
    try {
      const associations = /* @__PURE__ */ new Set();
      const associationsBuilder = [];
      const chartTypes2 = new D3ChartTypes();
      charts.forEach((chartType) => {
        if (!chartTypes2[chartType]) {throw new Error(`Invalid chart type: ${chartType}`);}
        if (!chartToOptionAssociations[chartType]) {throw new Error(`No chart-to-options associations found for: ${chartType}`);}
        associationsBuilder.push(...chartToOptionAssociations[chartType]);
      });
      associationsBuilder.forEach((association) => {
        associations.add(association);
      });
      return associationsBuilder[0] ? associationsBuilder[0] : '';
    } catch (error) {
      console.error(error.message);
      return /* @__PURE__ */ new Set();
    }
  }
  const d3ChartTypes = new D3ChartTypes();
  const d3OptionsTypes = new D3OptionTypes();
  class VisualizerTypes {
    constructor() {
      const types = {
        d3: {
          _selfKey: 'd3',
          name: 'D3',
          nameLong: 'D3 Visualizer',
          chartTypes: d3ChartTypes,
          optionTypes: d3OptionsTypes,
        }
      };
      Object.assign(this, types);
    }
  }
  const visualizerTypes$2 = new VisualizerTypes();
  function getCompatibleChartTypes(charts, visualizer) {
    const compatibleChartTypes = /* @__PURE__ */ new Set();
    charts.forEach((chart) => {
      if (visualizerTypes$2[visualizer].chartTypes[chart]) {compatibleChartTypes.add(chart);}
    });
    return compatibleChartTypes;
  }
  class InputTypes {
    constructor() {
      const types = {
        number_number: {
          _selfKey: 'number_number',
          name: 'Number Number',
          nameLong: 'Number Number Input',
          dataFormat: ['number', 'number'],
        },
        string_number: {
          _selfKey: 'string_number',
          name: 'String Number',
          nameLong: 'String Number Input',
          dataFormat: ['string', 'number'],
        },
        string_number_string: {
          _selfKey: 'string_number_string',
          name: 'String Number String',
          nameLong: 'String Number String Input',
          dataFormat: ['string', 'number', 'string'],
        }
      };
      Object.assign(this, types);
    }
  }
  function validateArrayHelper(inputArray, expectedTypes) {
    if (!Array.isArray(inputArray) || inputArray.length !== expectedTypes.length) {
      return false;
    }
    for (let i = 0; i < inputArray.length; i++) {
      if (!validateTypeHelper(inputArray[i], expectedTypes[i])) {
        return false;
      }
    }
    return true;
  }
  function validateObjectHelper(inputObject, expectedStructure) {
    if (typeof inputObject !== 'object' || inputObject === null || Array.isArray(inputObject)) {
      return false;
    }
    const inputKeys = Object.keys(inputObject);
    const expectedKeys = Object.keys(expectedStructure);
    if (inputKeys.length !== expectedKeys.length) {
      return false;
    }
    for (let i = 0; i < inputKeys.length; i++) {
      const key = inputKeys[i];
      if (!expectedKeys.includes(key) || !validateTypeHelper(inputObject[key], expectedStructure[key])) {
        return false;
      }
    }
    return true;
  }
  function validateTypeHelper(input, expectedType) {
    if (expectedType === 'date') {
      return input instanceof Date;
    }
    if (Array.isArray(expectedType)) {
      return validateArrayHelper(input, expectedType);
    }
    if (expectedType === 'object') {
      return validateObjectHelper(input, expectedType);
    }
    return typeof input === expectedType;
  }
  function getCompatibleInputTypes(userInput) {
    if (!userInput || !Array.isArray(userInput) || userInput.length === 0) {return [];}
    const compatibleInputTypes = /* @__PURE__ */ new Set();
    const inputTypes2 = new InputTypes();
    Object.keys(inputTypes2).forEach((inputType) => {
      if (isValidInput(userInput, inputTypes2[inputType].dataFormat)) {
        compatibleInputTypes.add(inputType);
      }
    });
    if (compatibleInputTypes.length === 0) {console.error("No valid input was found.");}
    return compatibleInputTypes;
  }
  function isValidInput(input, dataFormat) {
    const inputExcerpt = [input[0].x, input[0].y];
    if (Array.isArray(inputExcerpt)) {return validateArrayHelper(inputExcerpt, dataFormat);}
    if (typeof inputData === 'object') {return validateObjectHelper(inputExcerpt, dataFormat);}
    return false;
  }
  class TagTypes {
    constructor() {
      const types = {
        basic: {
          _selfKey: 'basic',
          name: 'Basic',
          nameLong: 'Basic Tag'
        },
        geographic: {
          _selfKey: 'geographic',
          name: 'Geographic',
          nameLong: 'Geographic Tag'
        },
        hierarchic: {
          _selfKey: 'hierarchic',
          name: 'Hierarchic',
          nameLong: 'Hierarchic Tag'
        },
      };
      Object.assign(this, types);
    }
  }
  const inputTypes = new InputTypes();
  const tagTypes$1 = new TagTypes();
  function createInputToTagAssociations() {
    try {
      const associations = {
        [inputTypes.number_number._selfKey]: [
          tagTypes$1.hierarchic._selfKey,
        ],
        [inputTypes.string_number._selfKey]: [
          tagTypes$1.basic._selfKey,
        ],
        [inputTypes.string_number_string._selfKey]: [
          tagTypes$1.hierarchic._selfKey,
        ]
      };
      return associations;
    } catch (error) {
      console.error(`Possible reference to non-existent input or tag type: ${error.message}`);
      return {};
    }
  }
  const inputToTagAssociations = createInputToTagAssociations();
  function getInputToTagAssociations(inputs) {
    if (!inputs || inputs.length === 0) {
      console.error('No inputs provided.');
    }
    try {
      const associations = /* @__PURE__ */ new Set();
      const associationsBuilder = [];
      const inputTypes2 = new InputTypes();
      inputs.forEach((inputType) => {
        if (!inputTypes2[inputType]) {throw new Error(`Invalid input type: ${inputType}`);}
        if (!inputToTagAssociations[inputType]) {throw new Error(`No input-to-tag associations found for: ${inputType}`);}
        associationsBuilder.push(...inputToTagAssociations[inputType]);
      });
      associationsBuilder.forEach((association) => {
        associations.add(association);
      });
      return associations;
    } catch (error) {
      console.error(error.message);
      return /* @__PURE__ */ new Set();
    }
  }
  const chartTypes$1 = new ChartTypes();
  const tagTypes = new TagTypes();
  function createTagToChartAssociations() {
    try {
      const associations = {
        [tagTypes.basic._selfKey]: [
          chartTypes$1.area._selfKey,
          chartTypes$1.bar._selfKey,
          chartTypes$1.box._selfKey,
          chartTypes$1.donut._selfKey,
          chartTypes$1.funnel._selfKey,
          chartTypes$1.gauge._selfKey,
          chartTypes$1.heat._selfKey,
          chartTypes$1.line._selfKey,
          chartTypes$1.pie._selfKey,
          chartTypes$1.polar._selfKey,
          chartTypes$1.radar._selfKey,
          chartTypes$1.scatter._selfKey,
          chartTypes$1.stackedBar._selfKey,
          chartTypes$1.waterfall._selfKey,
        ],
        [tagTypes.hierarchic._selfKey]: [
          chartTypes$1.adjacency._selfKey,
          chartTypes$1.chord._selfKey,
          chartTypes$1.cloud._selfKey,
          chartTypes$1.cluster._selfKey,
          chartTypes$1.dendrogram._selfKey,
          chartTypes$1.icicle._selfKey,
          chartTypes$1.marimekko._selfKey,
          chartTypes$1.radialTree._selfKey,
          chartTypes$1.sankey._selfKey,
          chartTypes$1.sun._selfKey,
          chartTypes$1.treeDiagram._selfKey,
          chartTypes$1.treeMap._selfKey,
          chartTypes$1.voronoi._selfKey,
        ]
      };
      return associations;
    } catch (error) {
      console.error(`Possible reference to non-existent tag or chart type: ${error.message}`);
      return {};
    }
  }
  const tagToChartAssociations = createTagToChartAssociations();
  function getTagToChartAssociations(tags) {
    if (!tags || tags.length === 0) {
      console.error('No tags provided.');
      return [];
    }
    try {
      const associations = /* @__PURE__ */ new Set();
      const associationsBuilder = [];
      const tagTypes2 = new TagTypes();
      tags.forEach((tagType) => {
        if (!tagTypes2[tagType]) {throw new Error(`Invalid tag type: ${tagType}`);}
        if (!tagToChartAssociations[tagType]) {throw new Error(`No tag-to-chart associations found for: ${tagType}`);}
        associationsBuilder.push(...tagToChartAssociations[tagType]);
      });
      associationsBuilder.forEach((association) => {
        associations.add(association);
      });
      return associations;
    } catch (error) {
      console.error(error.message);
      return /* @__PURE__ */ new Set();
    }
  }
  const chartTypes = new ChartTypes();
  const visualizerTypes$1 = new VisualizerTypes();
  function hasValidRenderVisualizerArguments(obj, chartType) {
    if (!chartType || chartType.length === 0 || !chartTypes[chartType]) {
      console.error('Invalid chart type provided.');
      return false;
    }
    if (!obj.charts.has(chartType)) {
      console.error(`${visualizerTypes$1[obj.visualizer].name} visualizer does not support '${chartType}' chart type.`);
      return false;
    }
    if (!obj.chartsEligible.has(chartType)) {
      console.error(`Instantiated object does not support '${chartType}' chart type.`);
      return false;
    }
    if (!obj.visualizer || obj.visualizer.length === 0 || !visualizerTypes$1[obj.visualizer]) {
      console.error('Invalid visualizer provided.');
      return false;
    }
    if (!obj.data) {
      console.error('Invalid data detected.');
      return false;
    }
    if (obj.data.length === 0) {
      console.warn('There are no data points to draw.');
    }
    console.log(`Drawing a ${chartTypes[chartType].nameLong} with ${obj.data.length} data point(s) using ${visualizerTypes$1[obj.visualizer].name}.`);
    return true;
  }
  class InterfaceTypes {
    constructor() {
      const types = {
        default: {
          _selfKey: 'default',
          name: 'Default',
          nameLong: 'Default Interface'
        },
      };
      Object.assign(this, types);
    }
  }
  const interfaceTypes = new InterfaceTypes();
  function verifyInterface(iface) {
    if (!iface || iface.length === 0 || !interfaceTypes[iface]) {
      console.error(`Unsupported interface: ${iface}`);
      return '';
    }
    return interfaceTypes[iface]._selfKey;
  }
  const visualizerTypes = new VisualizerTypes();
  function verifyVisualizer(visualizer) {
    if (!visualizer || visualizer.length === 0 || !visualizerTypes[visualizer]) {
      console.error(`Unsupported visualizer: ${visualizer}`);
      return '';
    }
    return visualizerTypes[visualizer]._selfKey;
  }
  class OomphChart {
    constructor(inputData2 = null, visualizer = 'd3', iface = 'default') {
      this.data = inputData2;
      this.inputs = getCompatibleInputTypes(this.data);
      this.tags = getInputToTagAssociations(this.inputs);
      this.chartsEligible = getTagToChartAssociations(this.tags);
      this.visualizer = verifyVisualizer(visualizer);
      this.charts = getCompatibleChartTypes(this.chartsEligible, this.visualizer);
      this.interface = verifyInterface(iface);
    }

    render(chartType, interfaceType = this.interface) {
      this.renderInterface(interfaceType);
      this.renderVisualizer(chartType);
    }

    renderInterface() {
      const oomphInterface = new OomphInterface(this.interface);
      oomphInterface.render();
    }

    renderVisualizer(chartType) {
      if (hasValidRenderVisualizerArguments(this, chartType)) {
        const chartTypes2 = new ChartTypes();
        const optionTypes2 = new D3OptionTypes();
        const tempSingleOption = getChartToOptionAssociations([chartType]);
        const charts = chartTypes2[chartType]._selfKey;
        const options = optionTypes2[tempSingleOption];
        const d3Visualizer = new D3Visualizer([charts], [this.data], [options]);
      } else {console.error("Could not render visualizer due to invalid arguments.");}
    }
  }
    myExport.OomphChart = OomphChart;
    myExport.ChartTypes = ChartTypes;
    myExport.D3OptionTypes = D3OptionTypes;
    myExport.VisualizerTypes = VisualizerTypes;
    return myExport;
  
}
