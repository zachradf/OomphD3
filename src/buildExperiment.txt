define(['d3'],function(d3){
  'use strict';

  class ChartTypes {
    constructor() {
      const types = {
        adjacency: {
          _selfKey: 'adjacency',
          name: 'Adjacency',
          nameLong: 'Adjacency Matrix'
        },
        area: {
          _selfKey: 'area',
          name: 'Area',
          nameLong: 'Area Chart'
        },
        bar: {
          _selfKey: 'bar',
          name: 'Bar',
          nameLong: 'Bar Chart'
        },
        box: {
          _selfKey: 'box',
          name: 'Box',
          nameLong: 'Box Plot'
        },
        bubble: {
          _selfKey: 'bubble',
          name: 'Bubble',
          nameLong: 'Bubble Chart'
        },
        chord: {
          _selfKey: 'chord',
          name: 'Chord',
          nameLong: 'Chord Diagram'
        },
        cloud: {
          _selfKey: 'cloud',
          name: 'Cloud',
          nameLong: 'Cloud Diagram'
        },
        cluster: {
          _selfKey: 'cluster',
          name: 'Cluster',
          nameLong: 'Cluster Diagram'
        },
        dendrogram: {
          _selfKey: 'dendrogram',
          name: 'Dendrogram',
          nameLong: 'Dendrogram Chart'
        },
        donut: {
          _selfKey: 'donut',
          name: 'Donut',
          nameLong: 'Donut Chart'
        },
        funnel: {
          _selfKey: 'funnel',
          name: 'Funnel',
          nameLong: 'Funnel Chart'
        },
        gauge: {
          _selfKey: 'gauge',
          name: 'Gauge',
          nameLong: 'Gauge Chart'
        },
        heat: {
          _selfKey: 'heat',
          name: 'Heat',
          nameLong: 'Heat Map'
        },
        icicle: {
          _selfKey: 'icicle',
          name: 'Icicle',
          nameLong: 'Icicle Plot'
        },
        line: {
          _selfKey: 'line',
          name: 'Line',
          nameLong: 'Line Graph'
        },
        marimekko: {
          _selfKey: 'marimekko',
          name: 'Marimekko',
          nameLong: 'Marimekko Diagram'
        },
        pie: {
          _selfKey: 'pie',
          name: 'Pie',
          nameLong: 'Pie Chart'
        },
        polar: {
          _selfKey: 'polar',
          name: 'Polar',
          nameLong: 'Polar Chart'
        },
        radar: {
          _selfKey: 'radar',
          name: 'Radar',
          nameLong: 'Radar Chart'
        },
        radialTree: {
          _selfKey: 'radialTree',
          name: 'Radial Tree',
          nameLong: 'Radial Tree Diagram'
        },
        sankey: {
          _selfKey: 'sankey',
          name: 'Sankey',
          nameLong: 'Sankey Diagram'
        },
        scatter: {
          _selfKey: 'scatter',
          name: 'Scatter',
          nameLong: 'Scatter Plot'
        },
        stackedBar: {
          _selfKey: 'stackedBar',
          name: 'Stacked Bar',
          nameLong: 'Stacked Bar Chart'
        },
        sun: {
          _selfKey: 'sun',
          name: 'Sun Burst',
          nameLong: 'Sun Burst Diagram'
        },
        treeDiagram: {
          _selfKey: 'treeDiagram',
          name: 'Tree Diagram',
          nameLong: 'Tree Diagram'
        },
        treeMap: {
          _selfKey: 'treeMap',
          name: 'Tree Map',
          nameLong: 'Tree Map'
        },
        voronoi: {
          _selfKey: 'voronoi',
          name: 'Voronoi',
          nameLong: 'Voronoi Diagram'
        },
        waterfall: {
          _selfKey: 'waterfall',
          name: 'Waterfall',
          nameLong: 'Waterfall Chart'
        },
      };
      Object.assign(this, types);
    }
  }
  class D3OptionTypes {
    constructor() {
      const types = {
        funnelChart: {
          _selfKey: 'funnelChart',
          barWidth: 10,
          colors: ['steelblue', 'grey'],
          height: 400,
          margin: {
            bottom: 30,
            left: 100,
            right: 20,
            top: 20,
          },
          nodePadding: 1,
          nodeWidth: 10,
          onHover: false,
          overlay: false,
          padding: 2,
          radius: 10,
          strokeColor: '#000000',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLine: true,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLine: true,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
        },
        gauge: {
          _selfKey: 'gauge',
          height: 300,
          interval: 2e3,
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          minorTickColor: 'black',
          minorTicks: 4,
          overlay: false,
          pointerColor: 'red',
          pointerWidth: 10,
          startAngle: -Math.PI / 1.25,
          endAngle: Math.PI / 1.25,
          width: 300,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          barWidth: 10,
        },
        options0: {
          _selfKey: 'options0',
          barWidth: 10,
          childTextSize: 10,
          color: d3.scaleOrdinal(d3.schemeCategory10),
          diameter: 600,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          height: 800,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          maxValue: 100,
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: false,
          opacity: 0.75,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yLabel: 'yLabel',
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
        },
        options1: {
          _selfKey: 'options1',
          barWidth: -30,
          childTextSize: 10,
          color: 'red',
          colorScale: 'red',
          diameter: 600,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          gradient: true,
          gradientAxis: 'x',
          gradientColor: ['red', 'yellow'],
          height: 600,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: false,
          opacity: 1,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: true,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xLabelColor: 'red',
          xLabelFontSize: 10,
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'normal',
          xLabelOffsetX: 10,
          xLabelOffsetY: 10,
          xLabelRotation: 0,
          xLine: true,
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 0.21,
          xAxisColor: 'red',
          xAxisPosition: -1,
          yLabel: 'yLabel',
          yLabelColor: 'blue',
          yLabelFontSize: 10,
          yLabelFontFamily: 'sans-serif',
          yLabelFontWeight: 'normal',
          yLabelOffsetX: 10,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.1,
          yAxisColor: 'blue',
          yAxisPosition: 880,
        },
        options2: {
          _selfKey: 'options2',
          barWidth: 10,
          childTextSize: 5,
          color: 'red',
          diameter: 400,
          fillColor: ['red', 'blue', 'green', 'yellow', 'orange', 'purple'],
          fontColor: 'blue',
          height: 600,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          opacity: 0.61,
          overlay: true,
          parentTextSize: 10,
          radius: 10.5,
          showCategories: true,
          sortBy: 'y asc',
          stack: false,
          textAnchor: 'middle',
          width: 800,
          xLine: false,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: 10,
          xLabelRotation: 90,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabel: 'yLabel',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: false,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
        },
        options3: {
          _selfKey: 'options3',
          childTextSize: 10,
          color: 'red',
          colorScale: 'red',
          diameter: 600,
          duration: 500,
          endAngle: Math.PI / 1.25,
          fillColor: 'red',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          gradient: false,
          gradientAxis: 'x',
          gradientColor: ['red', 'yellow'],
          height: 600,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: true,
          opacity: 0.75,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          relativeNode: true,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xAxisPosition: -1,
          xLabel: 'xLabel',
          xLine: true,
          yAxisPosition: 880,
          barWidth: -30,
          yLabel: 'yLabel',
          yLine: false,
          xTickFrequency: 30,
          yTickFrequency: 30,
          xTickLength: 600,
          yTickLength: 900,
          xTickExtension: -580,
          yTickExtension: 880,
          xTickOpacity: 1,
          yTickOpacity: 1,
          xAxisColor: 'red',
          yAxisColor: 'blue',
          yLabelOffsetX: 0,
          yLabelOffsetY: 0,
          xLabelOffsetX: 0,
          xLabelOffsetY: 0,
          xLabelColor: 'red',
          yLabelColor: 'blue',
          xLabelFontSize: 10,
          yLabelFontSize: 10,
          xLabelFontWeight: 'normal',
          yLabelFontWeight: 'normal',
          xLabelFontFamily: 'sans-serif',
          yLabelFontFamily: 'sans-serif',
          xLabelRotation: 0,
          yLabelRotation: 0,
        },
        options4: {
          _selfKey: 'options4',
          barWidth: 10,
          childTextSize: 10,
          color: 'green',
          colorScale: 'red',
          diameter: 600,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          height: 800,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: false,
          opacity: 0.75,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          yLabel: 'yLabel',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
        },
        options5: {
          _selfKey: 'options5',
          animate: true,
          barWidth: 10,
          childTextSize: 10,
          color: 'green',
          colorScale: 'red',
          colorScheme: ['red', 'blue', 'green', 'yellow', 'orange', 'purple'],
          diameter: 400,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          gradient: false,
          gradientAxis: 'y',
          gradientColor: ['red', 'yellow'],
          height: 600,
          hoverColor: 'blue',
          innerRadius: 80,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          menu: 'rectangular',
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: true,
          opacity: 1,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 10,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          strokeWidth: 10,
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xLine: false,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yLine: false,
          yLabel: 'yLabel',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yTickExtension: 10,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
        },
        options6: {
          _selfKey: 'options6',
          barWidth: 10,
          childTextSize: 10,
          color: 'green',
          colorScale: 'red',
          diameter: 400,
          endAngle: Math.PI / 1.25,
          fillColor: 'blue',
          fontFamily: 'sans-seriff',
          fontWeight: 'normal',
          height: 600,
          hoverColor: 'blue',
          innerRadius: 180,
          interval: 2e3,
          levels: 5,
          // maybe should be calculated from data
          linkColor: 'black',
          majorTickColor: 'black',
          majorTicks: 5,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          maxColor: 'red',
          // maybe should be d3 color scale
          maxValue: 100,
          // maybe should be calculated from data
          minColor: 'blue',
          minorTickColor: 'black',
          minorTicks: 4,
          nodeRadius: 15,
          onHover: true,
          opacity: 0.75,
          outerRadius: 200,
          overlay: true,
          padding: 0.1,
          parentTextSize: 12,
          pointerColor: 'red',
          pointerWidth: 10,
          radius: 250,
          relativeNodeSize: false,
          showCategories: true,
          showLabels: true,
          sortBy: 'value',
          stack: false,
          startAngle: -Math.PI / 1.25,
          strokeColor: 'blue',
          textAnchor: 'middle',
          textColor: 'white',
          width: 900,
          xLabel: 'xLabel',
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yLabel: 'yLabel',
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
        },
        options7: {
          _selfKey: 'options7',
          barWidth: 10,
          color: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
          // color scheme for the bars
          colorScale: 'red',
          diameter: 6,
          fillColor: 'red',
          height: 800,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          onHover: false,
          opacity: 0.75,
          overlay: false,
          radius: 200,
          showLabels: true,
          stack: false,
          strokeColor: 'blue',
          width: 900,
          xLabel: 'xLabel',
          xFontColor: 'red',
          xFontFamily: 'gothic',
          xFontOpacity: 1,
          xFontSize: 10,
          xFontStyle: 'italic',
          xFontWeight: 'bold',
          xLabelFontColor: 'blue',
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'bold',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xLine: true,
          xAxisColor: 'red',
          xAxisOpacity: 1,
          xAxisPosition: -1,
          xTextAnchor: 'start',
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          yFontColor: 'blue',
          yFontFamily: 'sans-serif',
          yFontOpacity: 1,
          yFontSize: 10,
          yFontStyle: 'italic',
          yFontWeight: 'bold',
          yLabel: 'yLabel',
          yLabelFontColor: 'red',
          yLabelFontFamily: 'gothic',
          yLabelFontWeight: 'bold',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yAxisColor: 'purple',
          yAxisOpacity: 1,
          yAxisPosition: 880,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 1,
        },
        options8: {
          _selfKey: 'options8',
          animate: true,
          barWidth: 10,
          boxShadow: true,
          color: 'green',
          diameter: 100,
          fillColor: ['red', 'blue', 'green', 'yellow', 'orange', 'purple'],
          height: 900,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          onHover: false,
          opacity: 1,
          overlay: true,
          radius: 50.5,
          showCategories: true,
          stack: false,
          textAnchor: 'middle',
          textColor: 'white',
          width: 1600,
          xLabel: 'xLabel',
          xFontColor: 'red',
          xFontFamily: 'gothic',
          xFontOpacity: 1,
          xFontSize: 10,
          xFontStyle: 'italic',
          xFontWeight: 'bold',
          xLabelFontColor: 'blue',
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'bold',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xLine: true,
          xAxisColor: 'red',
          xAxisOpacity: 1,
          xAxisPosition: -1,
          xTextAnchor: 'start',
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          yFontColor: 'blue',
          yFontFamily: 'sans-serif',
          yFontOpacity: 1,
          yFontSize: 10,
          yFontStyle: 'italic',
          yFontWeight: 'bold',
          yLabel: 'yLabel',
          yLabelFontColor: 'red',
          yLabelFontFamily: 'gothic',
          yLabelFontWeight: 'bold',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yAxisColor: 'purple',
          yAxisOpacity: 1,
          yAxisPosition: 420,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 1,
        },
        options9: {
          _selfKey: 'options9',
          barWidth: 10,
          color: d3.scaleOrdinal(d3.schemeCategory10),
          diameter: 100,
          fillColor: ['red', 'blue', 'green', 'yellow', 'orange', 'purple'],
          height: 900,
          margin: {
            bottom: 30,
            left: 40,
            right: 20,
            top: 20,
          },
          onHover: false,
          opacity: 1,
          overlay: true,
          radius: 50.5,
          showCategories: true,
          stack: false,
          textAnchor: 'middle',
          textColor: 'white',
          width: 1600,
          xLabel: 'xLabel',
          xFontColor: 'red',
          xFontFamily: 'gothic',
          xFontOpacity: 1,
          xFontSize: 10,
          xFontStyle: 'italic',
          xFontWeight: 'bold',
          xLabelFontColor: 'blue',
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'bold',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xLine: true,
          xAxisColor: 'red',
          xAxisOpacity: 1,
          xAxisPosition: -1,
          xTextAnchor: 'start',
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          yFontColor: 'blue',
          yFontFamily: 'sans-serif',
          yFontOpacity: 1,
          yFontSize: 10,
          yFontStyle: 'italic',
          yFontWeight: 'bold',
          yLabel: 'yLabel',
          yLabelFontColor: 'red',
          yLabelFontFamily: 'gothic',
          yLabelFontWeight: 'bold',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yAxisColor: 'purple',
          yAxisOpacity: 1,
          yAxisPosition: 880,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 1,
        },
        options10: {
          _selfKey: 'options10',
          barWidth: 10,
          bubble: true,
          bubbleOpacity: 0.7,
          chargeStrength: 0.01,
          fontSize: (d) => Math.sqrt(d.value) * 2,
          height: 2600,
          maxRadius: 100,
          menu: 'dropdown',
          width: 2800,
          xLabel: 'xLabel',
          xFontColor: 'red',
          xFontFamily: 'gothic',
          xFontOpacity: 1,
          xFontSize: 10,
          xFontStyle: 'italic',
          xFontWeight: 'bold',
          xLabelFontColor: 'blue',
          xLabelFontFamily: 'sans-serif',
          xLabelFontWeight: 'bold',
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xLine: true,
          xAxisColor: 'red',
          xAxisOpacity: 1,
          xAxisPosition: -1,
          xTextAnchor: 'start',
          xTickExtension: 1,
          xTickFrequency: 10,
          xTickLength: 10,
          yFontColor: 'blue',
          yFontFamily: 'sans-serif',
          yFontOpacity: 1,
          yFontSize: 10,
          yFontStyle: 'italic',
          yFontWeight: 'bold',
          yLabel: 'yLabel',
          yLabelFontColor: 'red',
          yLabelFontFamily: 'gothic',
          yLabelFontWeight: 'bold',
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yLine: true,
          yAxisColor: 'purple',
          yAxisOpacity: 1,
          yAxisPosition: 880,
          yTickExtension: 1,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 1,
        },
        optionsForceDirected: {
          _selfKey: 'optionsForceDirected',
          chargeStrength: -200,
          height: 600,
          linkDistance: 50,
          width: 600,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          barWidth: 10,
        },
        polarChart: {
          _selfKey: 'polarChart',
          barWidth: 10,
          colors: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'],
          height: 600,
          innerRadius: 50,
          margin: {
            bottom: 20,
            left: 20,
            right: 20,
            top: 20,
          },
          outerRadius: 250,
          overlay: false,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          width: 600,
        },
        radarChart: {
          _selfKey: 'radarChart',
          barWidth: 10,
          colors: ['#1f77b4', '#2ca02c'],
          height: 500,
          levels: 5,
          // maybe should be calculated from data
          margin: {
            bottom: 50,
            left: 50,
            right: 50,
            top: 50,
          },
          maxValue: 100,
          // maybe should be calculated from data
          overlay: false,
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yAxisColor: 'blue',
          yAxisPosition: 880,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
          width: 600,
        },
        waterfall: {
          _selfKey: 'waterfall',
          barWidth: 10,
          color: 'steelblue',
          height: 400,
          margin: {
            bottom: 30,
            left: 50,
            right: 20,
            top: 20,
          },
          negativeColor: 'red',
          overlay: false,
          positiveColor: 'green',
          width: 600,
          xAxisColor: 'red',
          xAxisPosition: -1,
          xDomain: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'],
          xLabelOffsetX: 0,
          xLabelOffsetY: -50,
          xLabelRotation: 90,
          xTickExtension: 0,
          xTickFrequency: 10,
          xTickLength: 10,
          xTickOpacity: 1,
          yAxisColor: 'purple',
          yAxisPosition: 0,
          yDomain: [0, 100],
          yLabelOffsetX: 0,
          yLabelOffsetY: 50,
          yLabelRotation: 0,
          yTickExtension: 100,
          yTickFrequency: 10,
          yTickLength: 10,
          yTickOpacity: 0.55,
        }
      };
      Object.assign(this, types);
    }
  }
  function appendAxes(chart, options, chartComponents) {
    const { width } = options;
    const { height } = options;
    const { margin } = options;
    const { svg } = chartComponents;
    const { xAxis } = chartComponents;
    const { yAxis } = chartComponents;
    let xAxisBBox;
    let yAxisBBox;
    if (chart === 'polar' || chart === 'radar' || chart === 'pie' || chart === 'donut' || chart === 'heatmap' || chart === 'bubble') {return { xAxisBBox, yAxisBBox };}
    if (!options.isUpdating) {
      const xAxisG = svg.append('g').classed('x-axis', true).attr('transform', chart === 'stackedbar' ? `translate(0,${height - margin.bottom})` : '').call(xAxis);
      xAxisBBox = xAxisG.node().getBBox();
      xAxisG.selectAll('text').style('font-size', `${options.xTickFontSize}px`).style('fill', `${options.xFontColor}`).style('font-family', `${options.xFontFamily}`)
.style('font-weight', `${options.xFontWeight}`)
.style('opacity', `${options.xFontOpacity}`);
      xAxisG.append('text').classed('x-axis-label', true).attr('x', width - margin.right + options.xLabelOffsetX).attr('y', margin.bottom - 10 + options.xLabelOffsetY)
.attr('text-anchor', 'middle')
.attr('transform', `rotate(${options.xLabelRotation}, ${width - margin.right + options.xLabelOffsetX}, ${margin.bottom - 10 + options.xLabelOffsetY})`)
.text(options.xLabel)
.style('font-size', `${options.xLabelFontSize}px`)
.style('fill', `${options.xLabelFontColor}`)
.style('font-family', `${options.xLabelFontFamily}`)
.style('font-weight', `${options.xLabelFontWeight}`)
.style('opacity', `${options.xLabelFontOpacity}`);
      const yAxisG = svg.append('g').classed('y-axis', true).attr('transform', chart === 'stackedbar' ? `translate(${margin.left},0)` : '').call(yAxis);
      yAxisBBox = yAxisG.node().getBBox();
      yAxisG.selectAll('text').style('font-size', `${options.yTickFontSize}px`).style('fill', `${options.yFontColor}`).style('font-family', `${options.yFontFamily}`)
.style('font-weight', `${options.yFontWeight}`)
.style('opacity', `${options.yFontOpacity}`);
      yAxisG.append('text').classed('y-axis-label', true).attr('x', -margin.top + options.yLabelOffsetX).attr('y', margin.left - 10 + options.yLabelOffsetY)
.attr('text-anchor', 'end')
.attr('transform', `rotate(${options.yLabelRotation}, ${-margin.top + options.yLabelOffsetX}, ${margin.left - 10 + options.yLabelOffsetY})`)
.text(options.yLabel)
.style('font-size', `${options.yLabelFontSize}px`)
.style('fill', `${options.yLabelFontColor}`)
.style('font-family', `${options.yLabelFontFamily}`)
.style('font-weight', `${options.yLabelFontWeight}`)
.style('opacity', `${options.yLabelFontOpacity}`);
    }
    if (!options.yLine) {
      svg.select('.y-axis path').remove();
    }
    if (!options.xLine) {
      svg.select('.x-axis path').remove();
    }
    return { xAxisBBox, yAxisBBox };
  }
  function createYAxisLine(g, options, xAxisPosition) {
    if (!options.yLine || options.isUpdating) {return;}
    g.append('line').attr('stroke', options.yAxisColor).attr('stroke-opacity', options.yAxisOpacity).attr('stroke-width', `${options.yAxisWidth}`)
.attr('x1', 0)
.attr('x2', 0)
.attr('y1', options.margin.top - xAxisPosition)
.attr('y2', options.height - options.margin.bottom - xAxisPosition + options.height - options.margin.top - options.margin.bottom);
    g.select('.domain').remove();
  }
  function createXAxisLine(g, options) {
    if (!options.xLine || options.isUpdating) {return;}
    g.append('line').attr('stroke', options.xAxisColor).attr('stroke-opacity', options.xAxisOpacity).attr('stroke-width', `${options.xAxisWidth}`)
.attr('x1', options.margin.left)
.attr('x2', options.width - options.margin.right)
.attr('y1', 0)
.attr('y2', 0);
    g.select('.domain').remove();
  }
  function createAxes(data, chart, options) {
    const {
      margin,
      width,
      height,
      yDomain,
    } = options;
    const chartFunctions = {
      bar: (data2) => createBarBox(data2, options),
      box: (data2) => createBarBox(data2, options),
      funnel: (data2) => createFunnel(data2, options),
      waterfall: (data2) => createWaterfall(data2, options),
      stackedbar: (data2) => createStackedBar(data2, options),
      default: (data2) => createDefault(data2, options),
    };
    const x2 = (chartFunctions[chart] || chartFunctions.default)(data);
    const scaleFunctions = {
      bar: () => d3.scaleLinear().domain(yDomain || [0, d3.max(data, (d) => d.y)]).nice().range([height - margin.bottom, margin.top]),
      funnel: () => d3.scaleBand().domain(yDomain || data.map((d) => d.x)).range([margin.top, height - margin.bottom]).padding(0.1),
      stackedbar: () => d3.scaleLinear().domain(yDomain || [0, d3.max(data, (d) => d3.sum(d.values.map((v) => v.value)))]).nice().range([height - margin.bottom, margin.top]),
      waterfall: () => d3.scaleLinear().domain(yDomain || [d3.min(data, (d) => d.start), d3.max(data, (d) => d.end)]).nice().range([height - margin.bottom, margin.top]),
      default: () => d3.scaleLinear().domain(yDomain || d3.extent(data, (d) => d.y)).nice().range([height - margin.bottom, margin.top]),
    };
    const xAxisColor = options.xAxisColor || '#000';
    const xAxisPosition = options.xAxisPosition || height - margin.bottom;
    const xAxisWidth = options.xAxistWidth || 2;
    const xTickExtension = options.xTickExtension || 0;
    const xTickFrequency = options.xTickFrequency || width / 80;
    const xTickLength = options.xTickLength || width - margin.left - margin.right;
    const yAxisColor = options.yAxisColor || '#000';
    const yAxisPosition = options.yAxisPosition || margin.left;
    options.yAxistWidth || 2;
    const yTickExtension = options.yTickExtension || 0;
    const yTickFrequency = options.yTickFrequency || width / 80;
    const yTickLength = options.yTickLength || height - margin.top - margin.bottom;
    const y2 = (scaleFunctions[chart] || scaleFunctions.default)();
    let xAxisBBox;
    let yAxisBBox;
    const xAxis = (g) => {
      g.attr('transform', `translate(0,${xAxisPosition})`).call(d3.axisBottom(x2).ticks(xTickFrequency).tickSizeOuter(0).tickSize(0)).call((g2) => {
        g2.selectAll('.tick').each(function () {
          d3.select(this).append('line').attr('stroke', `${xAxisColor}`).attr('stroke-width', `${xAxisWidth}`)
.attr('y2', -xTickLength)
.attr('opacity', options.xTickOpacity || 1);
          d3.select(this).append('line').attr('stroke', `${xAxisColor}`).attr('y2', -xTickExtension)
.attr('opacity', options.xTickOpacity || 1);
        });
      });
      if (options.xLine) {createXAxisLine(g, options);}
      xAxisBBox = g.node().getBBox();
    };
    const yAxis = (g) => {
      g.attr('transform', `translate(${yAxisPosition},0)`).call(d3.axisLeft(y2).tickSize(0).ticks(chart === 'stackedbar' ? null : yTickFrequency)).call((g2) => {
        g2.selectAll('.tick').each(function () {
          d3.select(this).append('line').attr('stroke', `${yAxisColor}`).attr('x2', yTickLength)
.attr('class', 'tick-line')
.attr('opacity', options.yTickOpacity || 1);
          d3.select(this).append('line').attr('stroke', `${yAxisColor}`).attr('x2', -yTickExtension)
.attr('class', 'tick-line')
.attr('opacity', options.yTickOpacity || 1);
        });
        if (options.yLine) {
          createYAxisLine(g2, options, xAxisPosition);
        }
      });
      yAxisBBox = g.node().getBBox();
    };
    return {
      x: x2,
      y: y2,
      xAxis,
      yAxis,
      xAxisBBox,
      yAxisBBox,
    };
  }
  function createBarBox(data, options) {
    data.sort((a, b) => d3.ascending(a.x, b.x));
    if (typeof data[0].x === 'string') {
      return d3.scaleBand().domain(options.xDomain ? options.xDomain : data.map((d) => d.x)).range([options.margin.left, options.width - options.margin.right]).padding(0.1);
    }
    return d3.scaleLinear().domain(options.xDomain ? options.xDomain : d3.extent(data, (d) => d.x)).nice().range([options.margin.left, options.width - options.margin.right]);
  }
  function createFunnel(data, options) {
    const totalValue = data.reduce((acc, curr) => acc + curr.y, 0);
    return d3.scaleLinear().domain(options.xDomain ? options.xDomain : [0, totalValue]).range([options.margin.left, options.width - options.margin.right]);
  }
  function createWaterfall(data, options) {
    return d3.scaleBand().domain(options.xDomain ? options.xDomain : [data[0].category, ...data.map((d) => d.category), data[data.length - 1].category]).range([options.margin.left, options.width - options.margin.right]).padding(0.1);
  }
  function createStackedBar(data, options) {
    return d3.scaleBand().domain(options.xDomain ? options.xDomain : data.map((d) => d.category)).range([options.margin.left, options.width - options.margin.right]).padding(0.1);
  }
  function createDefault(data, options) {
    return d3.scaleLinear().domain(options.xDomain ? options.xDomain : d3.extent(data, (d) => d.x)).nice().range([options.margin.left, options.width - options.margin.right]);
  }
  function createSVG(selector, chart, options) {
    let svg;
    if (options.stack) {
      const container = d3.select(selector).append('div').style('position', 'relative').style('width', `${options.width}px`)
.style('height', `${options.height}px`);
      svg = container.append('svg').attr('width', options.width).attr('height', options.height);
      if (chart === 'pie' || chart === 'donut' || chart === 'gauge' || chart === 'polar' || chart === 'radar') {
        svg.classed(`${options.chartClass}`, true);
        const g = svg.append('g');
        if (chart === 'polar') {
          g.attr('transform', `translate(${options.width / 2}, ${options.height / 2})`);
        }
        svg = g;
      } else {
        const chartWrapper = d3.select('body').append('div').classed('chart-wrapper', true).style('position', 'absolute')
.style('top', '0')
.style('left', '0');
        svg = chartWrapper.append('svg').attr('width', options.width).attr('height', options.height).classed(`${options.chartClass}`, true);
      }
      return svg;
    }
    if (chart === 'pie' || chart === 'donut' || chart === 'gauge' || chart === 'polar' || chart === 'radar' || chart === 'chord' || chart === 'cluster') {
      svg = d3.select(selector).append('svg').classed(`${options.chartClass}`, true).attr('width', options.width)
.attr('height', options.height)
.append('g');
      if (chart !== 'pie') {
        svg.attr('transform', `translate(${options.width / 2}, ${options.height / 2})`);
      }
      if (chart === 'bubble') {
        svg = d3.select(selector).append('svg').classed('bubble-chart', true).attr('width', options.diameter)
.attr('height', options.diameter);
      }
    } else {
      svg = d3.select(selector).append('svg').classed(`${options.chartClass}`, true).attr('width', options.width)
.attr('height', options.height);
    }
    return svg;
  }
  function onHover(selector, options) {
    options.forEach((option, i) => {
      const elements = d3.selectAll(`circle.${option.chartClass}${i}, rect.${option.chartClass}${i}, .node.${option.chartClass}${i}, .leaf.${option.chartClass}${i}, .link.${option.chartClass}${i}, .box-rect, .arc, path.${option.chartClass}${i}, svg.pie-chart path`);
      const tooltip = d3.select('body').append('div').attr('class', 'tooltip').style('position', 'absolute')
.style('background', 'rgba(0,0,0,0.6)')
.style('color', '#fff')
.style('padding', '5px 15px')
.style('border', '1px solid black')
.style('border-radius', '5px')
.style('pointer-events', 'none')
.style('z-index', '10')
.style('display', 'none');
      elements.each(function () {
        if (option.onHover) {
          const el = d3.select(this);
          el.attr('data-initialFill', el.style('fill')).on('mouseover', () => {
            if (option.onHover) {
              console.log('hovering');
              el.attr('transform') || '';
              const initialFill = el.attr('data-initialFill');
              const fillColor = d3.color(initialFill);
              tooltip.html(`Data: ${JSON.stringify(el.datum())}`).style('left', `${event.pageX + 10}px`).style('top', `${event.pageY + 10}px`).style('display', 'block');
              el.style('fill', option.hoverColor || fillColor.darker(4));
            }
          }).on('mousemove', () => {
            tooltip.style('top', `${event.pageY - 10}px`).style('left', `${event.pageX + 10}px`);
          }).on('mouseout', function () {
            const initialFill = d3.select(this).attr('data-initialFill');
            const initialTransform = el.attr('data-initialTransform') || '';
            el.style('fill', initialFill).attr('transform', initialTransform);
            d3.select(this).style('fill', initialFill);
            tooltip.style('display', 'none');
          });
        }
      });
    });
  }
  function adjustNodeSize(selector, data, options) {
    function collectNodeValues(data2) {
      if (!data2.children) {
        return data2.map((d) => d.y);
      }
      return data2.children.flatMap(collectNodeValues);
    }
    const nodeValues = collectNodeValues(data);
    const minNodeSize = options.minNodeSize || 3;
    const maxNodeSize = options.maxNodeSize || 20;
    const nodeSizeScale = d3.scaleSqrt().domain([Math.min(...nodeValues), Math.max(...nodeValues)]).range([minNodeSize, maxNodeSize]);
    const nodes = d3.select(selector).selectAll('circle');
    console.log(nodes);
    nodes.each(function () {
      const el = d3.select(this);
      console.log('relative node', el);
      el.attr('r', (d) => {
        if (nodeSizeScale(d.y) <= 0) {
          return 1;
        }
        return nodeSizeScale(d.y);
      });
    });
  }
  function addGradient(selector, type, chartElements, data, options) {
    const { gradientAxis } = options;
    let xAxisBBox;
    let yAxisBBox;
    let xScale;
    let svg;
    if (type !== 'donut' && type !== 'pie' && type !== 'polar' && type !== 'radar') {
      xAxisBBox = chartElements.xAxisBBox ? chartElements.xAxisBBox : null;
      yAxisBBox = chartElements.yAxisBBox ? chartElements.yAxisBBox : null;
      xScale = chartElements.x ? chartElements.x : null;
    }
    const color1 = options.gradientColor[0];
    const color2 = options.gradientColor[1];
    if (!options.stack) {
      svg = d3.select(selector).select('svg');
    } else {
      svg = d3.select('.chart-wrapper').select('svg');
    }
    let minValue;
    let maxValue;
    if (type === 'bar') {
      maxValue = d3.max(data, (d) => d.y);
      minValue = d3.min(data, (d) => d.y);
    } else {
      minValue = d3.min(data, (d) => d[gradientAxis]);
      maxValue = d3.max(data, (d) => d[gradientAxis]);
    }
    const valueAccessor = (d) => d[gradientAxis];
    const gradient = svg.append('linearGradient').attr('id', 'gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0)
.attr('x2', 0)
.attr('y1', 0)
.attr('y2', 1);
    gradient.append('stop').attr('offset', '0%').attr('stop-color', color1);
    gradient.append('stop').attr('offset', '100%').attr('stop-color', color2);
    if (type === 'bar') {
      if (gradientAxis === 'y') {
        gradient.attr('y1', yAxisBBox.height).attr('y2', 0);
        svg.selectAll('rect').style('fill', 'url(#gradient)');
      } else if (gradientAxis === 'x') {
        const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
        const elements = d3.selectAll(`rect.${options.chartClass}${options.chartNumber}`);
        elements.style('fill', (d) => {
          colorScale(d.y);
        });
        d3.selectAll(`rect.${options.chartClass}${options.chartNumber}`).style('fill', (d) => colorScale(d.y));
      }
    } else if (type === 'scatter') {
      const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
      svg.selectAll('circle').style('fill', (d) => colorScale(valueAccessor(d)));
    } else if (type === 'pie' || type === 'polar') {
      const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
      console.log(colorScale);
      svg.selectAll('path').attr('fill', (d) => colorScale(d.data.y));
    } else if (type === 'donut') {
      const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
      svg.selectAll('path').attr('fill', (d) => colorScale(d.data.y));
    } else if (type === 'area' || type === 'line') {
      const elements = svg.selectAll(`path.${options.chartClass}${options.chartNumber}`);
      const colorScale = d3.scaleLinear().domain([minValue, maxValue]).range([color1, color2]);
      if (gradientAxis === 'x') {
        gradient.attr('x1', xAxisBBox.x).attr('x2', xAxisBBox.width).attr('y1', 0).attr('y2', 0);
      } else {
        console.log('YAXIS---------------------', yAxisBBox.height, 'xAXIS', xAxisBBox.width);
        gradient.attr('x1', 0).attr('x2', 0).attr('y1', yAxisBBox.height).attr('y2', 0);
      }
      if (type === 'area') {
        elements.style('fill', 'url(#gradient)');
      } else {
        const lineGradient = svg.append('linearGradient').attr('id', 'line-gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', gradientAxis === 'x' ? 0 : xAxisBBox.width)
.attr('x2', gradientAxis === 'x' ? xAxisBBox.width : 0)
.attr('y1', gradientAxis === 'y' ? 0 : yAxisBBox.height)
.attr('y2', gradientAxis === 'y' ? yAxisBBox.height : 0);
        data.forEach((d, i, arr) => {
          if (i === arr.length - 1) {
            return;
          }
          const color = colorScale(d[gradientAxis]);
          const relativePosition = (xScale(d.x) - xScale.range()[0]) / (xScale.range()[1] - xScale.range()[0]);
          lineGradient.append('stop').attr('offset', `${relativePosition * 100}%`).attr('stop-color', color);
        });
        elements.style('stroke', 'url(#line-gradient)');
      }
    } else {
      throw new Error(`Unsupported chart type ${type}`);
    }
  }
  function animateScatter(chartElements, data, chartComponents, duration) {
    const updateSelection = chartElements.data(data);
    const enterSelection = updateSelection.enter();
    const exitSelection = updateSelection.exit();
    enterSelection.append('circle').attr('class', 'scatter-plot0').attr('r', 5);
    updateSelection.merge(enterSelection).transition().duration(duration).attr('cx', (d) => chartComponents.x(d.x))
.attr('cy', (d) => chartComponents.y(d.y));
    exitSelection.remove();
  }
  function animateLine(chartElements, data, chartComponents, duration) {
    const line = d3.line().x((d) => chartComponents.x(d.x)).y((d) => chartComponents.y(d.y));
    const updateSelection = chartElements.data(data);
    const exitSelection = updateSelection.exit();
    const linePath = chartElements.filter('.line-graph0');
    linePath.data([data]).transition().duration(duration).attr('d', line);
    exitSelection.remove();
  }
  function animateArea(chart, sortedData, chartComponents, options, duration) {
    console.log('animateArea', chart, sortedData, chartComponents, options, duration);
    const { y: y2 } = chartComponents;
    const area = d3.area().x((d) => chartComponents.x(d.x)).y0((d) => (d.y >= 0 ? y2(0) : y2(-d.y))).y1((d) => chartComponents.y(d.y));
    chart.select('svg .area-chart0').datum(sortedData).transition().duration(duration)
.attr('d', area(sortedData));
  }
  function animateBar(selection, data, chartComponents, options, duration) {
    const { width, barWidth } = options;
    const { x: x2, y: y2 } = chartComponents;
    const isLinearScale = x2.domain()[1] !== void 0 && typeof x2.domain()[1] === 'number';
    const dynamicBarWidth = isLinearScale ? options.width / data.length + options.barWidth : x2.bandwidth() + options.barWidth;
    selection.transition().duration(duration).attr('x', (d) => (isLinearScale ? x2(d.x) - barWidth / 2 : x2(d.x))).attr('y', (d) => (d.y >= 0 ? y2(d.y) : y2(0)))
.attr('height', (d) => (d.y >= 0 ? y2(0) - y2(d.y) : y2(d.y) - y2(0)))
.attr('width', dynamicBarWidth);
  }
  function animatePie(chartComponents, data, duration, options) {
    const svg = d3.select('svg');
    console.log(svg);
    const chartGroup = svg.select('g').empty() ? svg.append('g').attr('transform', `translate(${options.width / 2}, ${options.height / 2})`) : svg.select('g');
    const color = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(d3.schemeCategory10);
    const pie = d3.pie().value((d) => d.y).sort(null);
    const arc = d3.arc().innerRadius(0).outerRadius(options.radius);
    const labelArc = d3.arc().innerRadius(options.radius * 0.6).outerRadius(options.radius * 0.6);
    const update = chartGroup.selectAll('path').data(pie(data));
    update.join(
      (enter) => enter.append('path').attr('fill', (d) => color(d.data.y)).attr('stroke', `${options.strokeColor}` || 'white').attr('stroke-width', `${options.strokeWidth}` || 2)
.attr('d', arc),
      (update2) => update2.transition().duration(duration).attr('d', arc),
      (exit) => exit.remove()
    );
    const labelUpdate = chartGroup.selectAll('text').data(pie(data));
    labelUpdate.join(
      (enter) => enter.append('text').attr('transform', (d) => `translate(${labelArc.centroid(d)})`).attr('text-anchor', `${options.textAnchor}`).attr('alignment-baseline', 'central')
.text((d) => d.data.x),
      (update2) => update2.transition().duration(duration).attr('transform', (d) => `translate(${labelArc.centroid(d)})`).text((d) => d.data.x),
      (exit) => exit.remove()
    );
  }
  function animateDonutChart(chartComponents, data, duration, options) {
    const svg = d3.select('svg');
    console.log(svg);
    const chartGroup = svg.select('g').empty() ? svg.append('g').attr('transform', `translate(${options.width / 2}, ${options.height / 2})`) : svg.select('g');
    const pie = d3.pie().value((d) => d.y).sort(null);
    const arc = d3.arc().innerRadius(options.radius * 0.5).outerRadius(options.radius * 0.8);
    const labelArc = d3.arc().innerRadius(options.radius * 0.6).outerRadius(options.radius * 0.6);
    const updateArcs = chartGroup.selectAll('.arc').data(pie(data));
    updateArcs.join(
      (enter) => {
        const arcs = enter.append('g').attr('class', 'arc');
        arcs.append('path').attr('fill', (d, i) => options.fillColor[i]).attr('stroke', `${options.strokeColor}` || 'white').style('stroke-width', `${options.strokeWidth}` || 2)
.attr('d', arc);
        return arcs;
      },
      (update) => update.select('path').transition().duration(duration).attr('d', arc),
      (exit) => exit.remove()
    );
    const labelUpdate = chartGroup.selectAll('text').data(pie(data));
    labelUpdate.join(
      (enter) => enter.append('text').attr('transform', (d) => `translate(${labelArc.centroid(d)})`).attr('text-anchor', `${options.textAnchor}`).style('fill', 'red')
.style('font-size', `${options.fontSize}`)
.style('font-weight', 'bold')
.text((d) => d.data.x),
      (update) => update.transition().duration(duration).attr('transform', (d) => `translate(${labelArc.centroid(d)})`).text((d) => d.data.x),
      (exit) => exit.remove()
    );
  }
  function updateD3FunnelChart(chartComponents, data, duration, options) {
    const { width } = options;
    const { colors } = options;
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const colorScale = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(colors);
    const svg = d3.select('svg');
    const rectsUpdate = svg.selectAll('rect.funnel-chart0').data(data, (d) => d.x);
    const rectHeight = options.height / data.length;
    rectsUpdate.join(
      (enter) => enter.append('rect').attr('class', 'funnel-chart0').attr('x', (d) => (width - x2(d.y) + x2(0)) / 2).attr('width', (d) => x2(d.y) - x2(0))
.attr('height', rectHeight)
.attr('fill', (d) => colorScale(d.x))
.attr('transform', (d, i) => `translate(0, ${y2(d.x)})`),
      (update) => update.transition().duration(duration).attr('x', (d) => (width - x2(d.y) + x2(0)) / 2).attr('width', (d) => x2(d.y) - x2(0))
.attr('height', y2.bandwidth())
.attr('fill', (d) => colorScale(d.x)),
      // .attr('transform', (d, i) => `translate(0, ${y(d.x)})`),
      (exit) => exit.remove()
    );
  }
  function createD3StackedBarChart$1(data, options, chartComponents) {
    const {
      x: x2,
      y: y2,
      svg,
    } = chartComponents;
    const color = d3.scaleOrdinal().domain(data[0].values.map((v) => v.group)).range(options.color);
    const stack = d3.stack().keys(data[0].values.map((v) => v.group)).value((d, key) => d.find((v) => v.group === key).value);
    const bars = svg.append('g').selectAll('g').data(stack(data.map((d) => d.values))).join('g')
.attr('fill', (d) => color(d.key));
    bars.selectAll('rect').data((d) => d).join(
      (enter) => enter.append('rect').attr('x', (d, i) => x2(data[i].category)).attr('y', y2(0)).attr('height', 0)
.attr('width', x2.bandwidth())
.call((enterSelection) => animateBar(enterSelection, data, chartComponents, options, options.duration)),
      (update) => update.call((updateSelection) => animateBar(updateSelection, data, chartComponents, options, options.duration))
    ).transition()
.duration(options.duration)
.attr('x', (d, i) => x2(data[i].category))
.attr('y', (d) => y2(d[1]))
.attr('height', (d) => y2(d[0]) - y2(d[1]))
.attr('width', x2.bandwidth());
    bars.exit().remove();
  }
  function addAnimation(selector, data, options, chartComponents, duration = 1e3) {
    setTimeout(() => {
      const chart = d3.select(selector);
      chart.select('.x-axis').transition().duration(duration).call(chartComponents.xAxis);
      chart.select('.y-axis').transition().duration(duration).call(chartComponents.yAxis);
      const elements = chart.selectAll('g rect, g circle, .line-graph0, .area-chart0, path');
      const excludedElements = d3.selectAll('.shape-label, .shape-pointer');
      let chartElements = elements.filter(function () {
        const currentElement = d3.select(this);
        return !excludedElements.nodes().includes(currentElement.node());
      });
      console.log('chartElements should exclude pointer', chartElements);
      const type = chartElements.nodes()[0].className.baseVal;
      const sortedData = data.slice().sort((a, b) => d3.ascending(a.x, b.x));
      if (type === 'area-chart0' || type === 'line-graph0') {
        if (type === 'area-chart0') {
          animateArea(chart, sortedData, chartComponents, options, duration);
          return;
        }
        animateLine(chartElements, sortedData, chartComponents, duration);
        return;
      }
      let numPlaceholders = data.length - chartElements.size();
      if (numPlaceholders > 0) {
        while (numPlaceholders > 0) {
          const selectedElement = chartElements.nodes()[0];
          const clonedElement = selectedElement.cloneNode(true);
          const g = chart.select('g');
          g.node().appendChild(clonedElement);
          numPlaceholders -= 1;
        }
      } else if (numPlaceholders < 0) {
        const nodes = chartElements.nodes();
        while (numPlaceholders < 0) {
          const selectedElement = nodes.pop();
          selectedElement.remove();
          numPlaceholders++;
        }
      }
      chartElements = chart.selectAll('g rect, g circle, .line-graph0, .area-chart0 path, path').data(data);
      console.log('TYPE', type, 'chartElements', chartElements);
      switch (type) {
        case 'bar-chart0':
          animateBar(chartElements, data, chartComponents, options, duration);
          break;
        case 'scatter-plot0':
          animateScatter(chartElements, data, chartComponents, duration);
          break;
        case 'pie-chart0':
          animatePie(chartComponents, data, duration, options);
          break;
        case 'donut-chart0':
          animateDonutChart(chartComponents, data, duration, options);
          break;
        case 'funnel-chart0':
          updateD3FunnelChart(chartComponents, data, duration, options);
          break;
        case 'stacked-bar-chart0':
          createD3StackedBarChart$1(chartComponents, data, duration);
          break;
        default:
          console.log('No animation for this chart type', type);
      }
      if (!options.yLine) {
        chart.select('.y-axis path').remove();
      }
      if (!options.xLine) {
        chart.select('.x-axis path').remove();
      }
      if (options.onHover) {
        onHover(selector, [options]);
      }
      if (options.relativeNode) {
        adjustNodeSize(selector, data, options);
      }
      if (options.gradient) {
        addGradient(selector, options.gradientColor[0], options.gradientColor[1], type, options.gradientAxis);
      }
    }, duration);
  }
  function createAdjacencyMatrix(data, options, chartComponents) {
    const { svg } = chartComponents;
    const g = svg.append('g').attr('transform', `translate(${options.margin.left}, ${options.margin.top})`);
    const x2 = d3.scaleBand().domain(data.nodes.map((d) => d.id)).range([0, options.width - options.margin.left - options.margin.right]).padding(0.1);
    const y2 = d3.scaleBand().domain(data.nodes.map((d) => d.id)).range([0, options.height - options.margin.top - options.margin.bottom]).padding(0.1);
    const colorScale = d3.scaleLinear().domain([0, d3.max(data.links.map((d) => d.value))]).range([options.minColor, options.maxColor]);
    g.selectAll('rect').data(data.links).enter().append('rect')
.attr('x', (d) => x2(d.source))
.attr('y', (d) => y2(d.target))
.attr('width', x2.bandwidth())
.attr('height', y2.bandwidth())
.attr('fill', (d) => colorScale(d.value));
    const xAxis = d3.axisBottom(x2);
    g.append('g').attr('transform', `translate(0, ${options.height - options.margin.top - options.margin.bottom})`).call(xAxis);
    const yAxis = d3.axisLeft(y2);
    g.append('g').call(yAxis);
  }
  function createD3AreaChart(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    const area = d3.area().x((d) => x2(d.x)).y0((d) => (d.y >= 0 ? y2(0) : y2(-d.y))).y1((d) => y2(d.y));
    const sortedData = data.sort((a, b) => a.x - b.x);
    svg.append('path').datum(sortedData).attr('fill', `${options.fillColor}`).attr('d', area);
  }
  function createD3BarChart(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    data.sort((a, b) => d3.ascending(a.x, b.x));
    const isLinearScale = x2.domain()[1] !== void 0 && typeof x2.domain()[1] === 'number';
    const barWidth = isLinearScale ? options.width / data.length + options.barWidth : x2.bandwidth();
    svg.append('g').selectAll('rect').data(data).join('rect')
.attr('x', (d) => (isLinearScale ? x2(d.x) - barWidth / 2 : x2(d.x)))
.attr('y', (d) => (d.y >= 0 ? y2(d.y) : y2(0)))
.attr('height', (d) => (d.y >= 0 ? y2(0) - y2(d.y) : y2(d.y) - y2(0)))
.attr('fill', options.color)
.attr('width', barWidth);
  }
  function createD3BoxPlot(data, options, chartComponents) {
    const fillColor = options.fillColor || 'steelblue';
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { xAxis } = chartComponents;
    const { yAxis } = chartComponents;
    const { svg } = chartComponents;
    function update(data2) {
      x2.domain(data2.map((d) => d.category));
      y2.domain([d3.min(data2, (d) => d.min), d3.max(data2, (d) => d.max)]).nice();
      svg.selectAll('.x-axis').call(xAxis);
      svg.selectAll('.y-axis').call(yAxis);
      const boxWidth = Math.min(x2.bandwidth(), 50);
      const box = svg.selectAll('.box').data(data2, (d) => d.category).join('g').attr('class', 'box')
.attr('transform', (d) => `translate(${x2(d.category)},0)`);
      box.selectAll('.min').data((d) => [d]).join('line').attr('class', 'min')
.attr('x1', boxWidth / 2)
.attr('x2', boxWidth / 2)
.attr('y1', (d) => y2(d.min))
.attr('y2', (d) => y2(d.q1))
.attr('stroke', `${options.strokeColor}` || 'black');
      box.selectAll('.max').data((d) => [d]).join('line').attr('class', 'max')
.attr('x1', boxWidth / 2)
.attr('x2', boxWidth / 2)
.attr('y1', (d) => y2(d.q3))
.attr('y2', (d) => y2(d.max))
.attr('stroke', `${options.strokeColor}` || 'black');
      box.selectAll('.box-rect').data((d) => [d]).join('rect').attr('class', 'box-rect')
.attr('x', 0)
.attr('width', boxWidth)
.attr('y', (d) => y2(d.q3))
.attr('height', (d) => y2(d.q1) - y2(d.q3))
.attr('fill', fillColor);
    }
    update(data);
    return { update };
  }
  function createBubbleChart(data, options, chartComponents) {
    const { diameter } = options;
    const { svg } = chartComponents;
    const colorScheme = options.colorScheme || d3.schemeCategory10;
    const root = d3.hierarchy({ children: data }).sum((d) => d.value).sort((a, b) => b.value - a.value);
    const bubbleLayout = d3.pack().size([diameter, diameter]).padding(options.padding);
    bubbleLayout(root);
    const nodes = svg.selectAll('g').data(root.descendants()).enter().append('g')
.attr('class', 'node')
.attr('transform', (d) => `translate(${d.x},${d.y})`);
    nodes.append('circle').attr('r', (d) => d.r).style('fill', (d) => colorScheme[d.depth]).style('opacity', (d) => (d.depth <= 1 ? 1 : options.opacity));
    nodes.append('text').attr('dy', '.3em').style('text-anchor', `${options.textAnchor}`).style('font-size', (d) => (d.depth === 1 ? `${options.parentTextSize}` : `${options.childTextSize}`))
.style('fill', `${options.fontColor}`)
.text((d) => {
      if (d.depth === 1) {
        return d.data.name;
      }
      if (d.depth === 2) {
        return d.data.name;
      }
      return null;
    })
.attr('x', 0)
.attr('y', (d) => (d.depth === 1 ? -options.height / 6 : 0));
    nodes.selectAll('text').filter((d) => d.depth === 1).attr('y', (d) => -d.r);
  }
  function createChordDiagram(data, options, chartComponents) {
    const {
      width,
      height,
      color,
      strokeColor,
      outerRadius,
      innerRadius,
    } = options;
    const labels = data.pop();
    const { svg } = chartComponents;
    const chord = d3.chord().padAngle(0.05).sortSubgroups(d3.descending);
    const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
    const ribbon = d3.ribbon().radius(innerRadius);
    const chords = chord(data);
    const group = svg.append('g').selectAll('g').data(chords.groups).join('g');
    group.append('path').attr('class', 'arc').attr('d', arc).attr('fill', (d) => color(d.index))
.attr('stroke', strokeColor);
    svg.append('g').attr('fill-opacity', 0.75).selectAll('path').data(chords)
.join('path')
.attr('class', 'ribbon')
.attr('d', ribbon)
.attr('fill', (d) => color(d.source.index))
.attr('stroke', strokeColor);
    group.append('text').each(function (d) {
      const centroid = arc.centroid(d);
      d3.select(this).attr('x', centroid[0]).attr('y', centroid[1]).attr('dy', '0.35em')
.attr('text-anchor', `${options.textAnchor}`)
.style('font-size', `${options.childTextSize}`)
.text(labels[d.index]);
    });
  }
  function createClusterDiagram(data, options, chartComponents) {
    const {
      width,
      height,
      color = d3.scaleOrdinal(d3.schemeCategory10),
      nodeRadius,
      strokeColor,
    } = options;
    const { svg } = chartComponents;
    const cluster = d3.cluster().size([360, height / 2 - 100]);
    const root = d3.hierarchy(data);
    cluster(root);
    svg.selectAll('.link').data(root.links()).join('line').attr('class', 'link')
.attr('stroke', strokeColor)
.attr('stroke-width', `${options.strokeWidth}` || 1.5)
.attr('x1', (d) => d.source.y * Math.cos((d.source.x - 90) * Math.PI / 180))
.attr('y1', (d) => d.source.y * Math.sin((d.source.x - 90) * Math.PI / 180))
.attr('x2', (d) => d.target.y * Math.cos((d.target.x - 90) * Math.PI / 180))
.attr('y2', (d) => d.target.y * Math.sin((d.target.x - 90) * Math.PI / 180));
    const node = svg.selectAll('.node').data(root.descendants()).join('g').attr('class', 'node')
.attr('transform', (d) => `translate(${d.y * Math.cos((d.x - 90) * Math.PI / 180)}, ${d.y * Math.sin((d.x - 90) * Math.PI / 180)})`);
    node.append('circle').attr('r', nodeRadius).style('fill', (d) => color(d.data.group));
    node.append('text').attr('dy', '0.31em').attr('x', (d) => (d.children ? -nodeRadius : nodeRadius)).style('text-anchor', (d) => (d.children ? "end" : "start"))
.style('font-size', `${options.childTextSize}`)
.style('fill', '#000')
.text((d) => d.data.name);
  }
  function createDendrogram(data, options, chartComponents) {
    const { svg } = chartComponents;
    const g = svg.append('g').attr('transform', `translate(${options.margin.left}, ${options.margin.top})`);
    const layout = d3.cluster().size([options.height - options.margin.top - options.margin.bottom, options.width - options.margin.left - options.margin.right]);
    const root = d3.hierarchy(data);
    layout(root);
    g.selectAll('.link').data(root.descendants().slice(1)).enter().append('path')
.attr('class', 'link')
.attr('d', (d) => `M${d.y},${d.x}V${(d.x + d.parent.x) / 2}H${d.parent.y}V${d.parent.x}`)
.style('stroke', options.linkColor)
.style('fill', 'none');
    const node = g.selectAll('.node').data(root.descendants()).enter().append('g')
.attr('class', (d) => `node${d.children ? ' node--internal' : ' node--leaf'}`)
.attr('transform', (d) => `translate(${d.y},${d.x})`);
    node.append('circle').attr('r', options.nodeRadius).style('fill', options.nodeColor);
    node.append('text').attr('dy', '.35em').attr('x', (d) => (d.children ? -options.nodeRadius - 2 : options.nodeRadius + 2)).style('text-anchor', (d) => (d.children ? "end" : "start"))
.text((d) => d.data.name)
.style('font-size', options.textSize)
.style('fill', options.textColor);
  }
  function createD3DonutChart(data, options, chartComponents) {
    const { svg } = chartComponents;
    const chartGroup = svg.append('g');
    const arc = d3.arc().innerRadius(options.innerRadius).outerRadius(options.outerRadius);
    const pie = d3.pie().sort(null).value((d) => d.y);
    const arcs = chartGroup.selectAll('.arc').data(pie(data)).enter().append('g')
.attr('class', 'arc');
    arcs.append('path').attr('d', arc).attr('fill', (d, i) => options.colorScheme[i]).attr('stroke', `${options.strokeColor}`)
.style('stroke-width', `${options.strokeWidth}` || 2);
    arcs.append('text').attr('transform', (d) => `translate(${arc.centroid(d)})`).attr('text-anchor', `${options.textAnchor}`).text((d) => d.data.x)
.style('fill', 'red')
.style('font-size', `${options.fontSize}`)
.style('font-weight', 'bold');
  }
  function createD3FunnelChart(data, options, chartComponents) {
    const { width } = options;
    const { colors } = options;
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    const colorScale = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(colors);
    const funnel = svg.selectAll('g').data(data).join('g').attr('transform', (d, i) => `translate(0, ${y2(d.x)})`);
    funnel.append('rect').attr('x', (d) => (width - x2(d.y) + x2(0)) / 2).attr('width', (d) => x2(d.y) - x2(0)).attr('height', y2.bandwidth())
.attr('fill', (d) => colorScale(d.x));
  }
  function createD3GaugeChart(sampleValues, options, chartComponents) {
    const width = options.width || 300;
    const height = options.height || 300;
    const radius = Math.min(width, height) / 2;
    const startAngle = options.startAngle || -Math.PI / 1.25;
    const endAngle = options.endAngle || Math.PI / 1.25;
    const majorTicks = options.majorTicks || 5;
    const minorTicks = options.minorTicks || 4;
    const majorTickColor = options.majorTickColor || 'black';
    const minorTickColor = options.minorTickColor || 'black';
    const pointerColor = options.pointerColor || 'red';
    options.arcColors || d3.schemeCategory10;
    const { svg } = chartComponents;
    let currentValue = 0;
    const arc = d3.arc().innerRadius(0.7 * radius).outerRadius(0.85 * radius).startAngle((d, i) => startAngle + i * (endAngle - startAngle) / majorTicks)
.endAngle((d, i) => startAngle + (i + 1) * (endAngle - startAngle) / majorTicks);
    const minorTickValue = (endAngle - startAngle) / (majorTicks * minorTicks);
    const minorTickAngle = minorTickValue;
    svg.selectAll('.majorTicks').data(d3.range(majorTicks)).enter().append('path')
.attr('class', 'majorTicks')
.attr('fill', majorTickColor)
.attr('d', arc);
    svg.selectAll('.minorTicks').data(d3.range(majorTicks * minorTicks)).enter().append('path')
.attr('class', 'minorTicks')
.attr('fill', minorTickColor)
.attr('d', arc.innerRadius(0.75 * radius).outerRadius(0.85 * radius));
    svg.selectAll('.minorTickValues').data(d3.range(majorTicks * minorTicks)).enter().append('text')
.attr('class', 'minorTickValues')
.attr('fill', minorTickColor)
.attr('text-anchor', `${options.textAnchor}`)
.attr('font-size', `${options.childTextSize}`)
.attr('x', (d, i) => {
      const tickValueAngle = startAngle + i * minorTickAngle;
      return 0.68 * radius * Math.cos(tickValueAngle - Math.PI / 2);
    })
.attr('y', (d, i) => {
      const tickValueAngle = startAngle + i * minorTickAngle;
      return 0.68 * radius * Math.sin(tickValueAngle - Math.PI / 2) + 4;
    })
.text((d, i) => Number.parseFloat(i * minorTickValue).toFixed(1));
    const pointer = svg.append('path').attr('class', 'pointer').attr('fill', pointerColor).attr('stroke', `${options.strokeColor}` || 'black')
.attr('stroke-width', `${options.strokeWidth}` || 1);
    function updateGauge(value2) {
      const angle = startAngle + (endAngle - startAngle) * value2 / (majorTicks * minorTicks);
      d3.arc().innerRadius(0.6 * radius).outerRadius(0.9 * radius).startAngle(angle - 0.05)
.endAngle(angle + 0.05);
      pointer.transition().duration(1e3).attrTween('d', () => {
        const currentAngle = startAngle + (endAngle - startAngle) * currentValue / (majorTicks * minorTicks);
        const interpolate = d3.interpolate(currentAngle, angle);
        return (t) => {
          const interpolatedAngle = interpolate(t);
          const updatedPointerPath = d3.arc().innerRadius(0.6 * radius).outerRadius(0.9 * radius).startAngle(interpolatedAngle - 0.05)
.endAngle(interpolatedAngle + 0.05);
          return updatedPointerPath();
        };
      });
      currentValue = value2;
    }
    if (Array.isArray(sampleValues)) {
      let index = 0;
      setInterval(() => {
        updateGauge(sampleValues[index]);
        index = (index + 1) % sampleValues.length;
      }, options.interval || 1e3);
    } else {
      updateGauge(sampleValues);
    }
  }
  function createD3Heatmap(data, options, chartComponents) {
    const {
      width,
      height,
      margin,
      colorScale,
      x: x2 = 'x',
      y: y2 = 'y'
    } = options;
    const { svg } = chartComponents;
    const xScale = d3.scaleBand().domain(data.map((d) => d[x2])).range([margin.left, width - margin.right]).padding(0.25);
    const yScale = d3.scaleBand().domain(data.map((d) => d[y2])).range([margin.top, height - margin.bottom]).padding(0.25);
    const color = d3.scaleSequential(colorScale).domain(d3.extent(data, (d) => d.y));
    svg.selectAll('.heatmap-cell').data(data).join('rect').classed('heatmap-cell', true)
.attr('x', (d) => xScale(d[x2]))
.attr('y', (d) => yScale(d[y2]))
.attr('width', xScale.bandwidth())
.attr('height', yScale.bandwidth())
.attr('fill', (d) => color(d.y));
    svg.append('g').classed('x-axis', true).attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(xScale).tickSizeOuter(0))
.append('text')
.classed('x-axis-label', true)
.attr('x', width - margin.right)
.attr('y', margin.bottom - 10)
.attr('text-anchor', `${options.textAnchor}`)
.text(x2);
    svg.append('g').classed('y-axis', true).attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(yScale).tickSizeOuter(0))
.append('text')
.classed('y-axis-label', true)
.attr('x', -margin.top)
.attr('y', margin.left - 10)
.attr('text-anchor', `${options.textAnchor}`)
.attr('transform', 'rotate(-90)')
.text(y2);
  }
  function createIcicleChart(data, options, chartComponents) {
    const width = options.width || 960;
    const height = options.height || 500;
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const { svg } = chartComponents;
    const partition = (data2) => {
      const root2 = d3.hierarchy(data2).sum((d) => d.value).sort((a, b) => b.height - a.height || b.value - a.value);
      return d3.partition().size([height, width]).padding(1)(root2);
    };
    const root = partition(data);
    const nodes = root.descendants();
    svg.selectAll('.node').data(nodes).enter().append('rect')
.attr('class', 'node')
.attr('x', (d) => d.x0)
.attr('y', (d) => d.y0)
.attr('width', (d) => d.x1 - d.x0)
.attr('height', (d) => d.y1 - d.y0)
.style('fill', (d) => color((d.children ? d : d.parent).data.name));
    svg.selectAll('.label').data(nodes.filter((d) => d.x1 - d.x0 > 6)).enter().append('text')
.attr('class', 'label')
.attr('dy', '.35em')
.attr('transform', (d) => `translate(${(d.x0 + d.x1) / 2},${(d.y0 + d.y1) / 2})rotate(90)`)
.text((d) => d.data.name)
.style('font-size', `${options.childTextSize}`);
  }
  function createD3LineGraph(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    if (typeof data[0].x === 'number') {
      data.sort((a, b) => d3.ascending(a.x, b.x));
    }
    const line = d3.line().x((d) => x2(d.x)).y((d) => y2(d.y));
    const sortedData = data.sort((a, b) => a.x - b.x);
    svg.append('path').datum(sortedData).attr('fill', 'none').attr('stroke', options.strokeColor || 'steelblue')
.attr('stroke-width', options.strokeWidth || 1.5)
.attr('d', line);
  }
  function createMarimekkoChart(data, options, chartComponents) {
    const { svg } = chartComponents;
    const g = svg.append('g').attr('transform', `translate(${options.margin.left}, ${options.margin.top})`);
    const x2 = d3.scaleBand().domain(data.map((d) => d.category)).range([0, options.width - options.margin.left - options.margin.right]).padding(0.1);
    const y2 = d3.scaleLinear().domain([0, 1]).range([options.height - options.margin.top - options.margin.bottom, 0]);
    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
    const parentRects = g.selectAll('.parent-rect').data(data).enter().append('g')
.attr('class', 'parent-rect')
.attr('transform', (d) => `translate(${x2(d.category)}, 0)`);
    parentRects.each(function (parentData) {
      const parentGroup = d3.select(this);
      let yOffset = 0;
      parentData.children.forEach((childData) => {
        parentGroup.append('rect').datum(childData).attr('x', 0).attr('y', (d) => {
          const yPos = yOffset;
          yOffset += y2(0) - y2(d.percentage);
          return yPos;
        })
.attr('width', x2.bandwidth())
.attr('height', (d) => y2(0) - y2(d.percentage))
.style('fill', (d) => colorScale(d.subCategory))
.attr('class', 'child-rect')
.text((d) => d.subCategory)
.attr('text-color', 'white');
        parentGroup.append('text').datum(childData).attr('x', x2.bandwidth() / 2).attr('y', yOffset - 30 / 2)
.attr('text-anchor', 'middle')
.attr('dominant-baseline', 'central')
.text((d) => d.subCategory)
.style('fill', 'white');
      });
    });
    g.append('g').attr('transform', `translate(0, ${options.height - options.margin.top - options.margin.bottom})`).call(d3.axisBottom(x2));
    g.append('g').call(d3.axisLeft(y2));
  }
  function createD3PieChart(data, options, chartComponents) {
    const { width } = options;
    const { height } = options;
    const { svg } = chartComponents;
    const radius = Math.min(width, height) / 2;
    const chartGroup = svg.append('g').attr('transform', `translate(${width / 2}, ${height / 2})`);
    const color = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(d3.schemeCategory10);
    const pie = d3.pie().value((d) => d.y).sort(null);
    const arc = d3.arc().innerRadius(0).outerRadius(radius);
    chartGroup.selectAll('path').data(pie(data)).enter().append('path')
.attr('fill', (d) => color(d.data.y))
.attr('d', arc)
.attr('stroke', `${options.strokeColor}` || 'white')
.attr('stroke-width', `${options.strokeWidth}px` || '2px');
    if (options.showCategories) {
      const categoryArc = d3.arc().innerRadius(radius * 0.6).outerRadius(radius * 0.6);
      chartGroup.selectAll('text').data(pie(data)).join('text').attr('transform', (d) => `translate(${categoryArc.centroid(d)})`)
.attr('text-anchor', `${options.textAnchor}`)
.attr('alignment-baseline', 'central')
.text((d) => d.data.x);
    }
  }
  function createD3PolarChart(data, options, chartComponents) {
    const {
      colorScheme,
      innerRadius,
      outerRadius,
    } = options;
    const { svg } = chartComponents;
    const x2 = d3.scaleBand().domain(data.map((d) => d.x)).range([0, 2 * Math.PI]).padding(0.1);
    const y2 = d3.scaleLinear().domain([0, d3.max(data, (d) => d.y)]).range([innerRadius, outerRadius]);
    console.log(data[0].x);
    const colorScale = d3.scaleOrdinal().domain(data.map((d) => d.x)).range(colorScheme);
    const arc = d3.arc().innerRadius(0).outerRadius((d) => y2(d.y)).startAngle((d) => x2(d.x))
.endAngle((d) => x2(d.x) + x2.bandwidth())
.padAngle(0.01)
.padRadius(innerRadius);
    svg.selectAll('path').data(data).join('path').attr('d', arc)
.attr('fill', (d) => colorScale(d.x));
    svg.selectAll('text').data(data).join('text').attr('x', (d) => (y2(d.y) + 10) * Math.cos(x2(d.x) + x2.bandwidth() / 2 - Math.PI / 2))
.attr('y', (d) => (y2(d.y) + 10) * Math.sin(x2(d.x) + x2.bandwidth() / 2 - Math.PI / 2))
.text((d) => d.x)
.attr('text-anchor', `${options.textAnchor}`)
.attr('font-size', `${options.childTextSize}`);
  }
  function createD3RadarChart(data, options, chartComponents) {
    const {
      width,
      height,
      colorScheme,
      maxValue,
      levels,
    } = options;
    const { svg } = chartComponents;
    const radius = Math.min(width, height) / 2;
    const angleSlice = 2 * Math.PI / data.length;
    const rScale = d3.scaleLinear().domain([0, maxValue]).range([0, radius]);
    const lineGenerator = d3.lineRadial().curve(d3.curveLinearClosed);
    svg.selectAll('.radar-chart-path').data([data]).join('path').attr('class', 'radar-chart-path')
.attr('d', lineGenerator.radius((d) => rScale(d.y)).angle((d, i) => i * angleSlice))
.attr('fill', colorScheme[0])
.attr('fill-opacity', 0.6)
.attr('stroke', colorScheme[1])
.attr('stroke-width', `${options.strokeWidth}` || 2);
    for (let level = 0; level < levels; level++) {
      const levelFactor = radius * ((level + 1) / levels);
      svg.selectAll(`.ticks-${level}`).data(data).join('line').attr('class', `ticks ticks-${level}`)
.attr('x1', (d, i) => levelFactor * Math.cos(angleSlice * i - Math.PI / 2))
.attr('y1', (d, i) => levelFactor * Math.sin(angleSlice * i - Math.PI / 2))
.attr('x2', (d, i) => levelFactor * Math.cos(angleSlice * (i + 1) - Math.PI / 2))
.attr('y2', (d, i) => levelFactor * Math.sin(angleSlice * (i + 1) - Math.PI / 2))
.attr('stroke', 'gray')
.attr('stroke-opacity', 0.6)
.attr('stroke-width', `${options.strokeWidth}` || 0.5);
    }
    svg.selectAll('.label').data(data).join('text').attr('class', 'label')
.attr('x', (d, i) => rScale(maxValue) * Math.cos(angleSlice * i - Math.PI / 2))
.attr('y', (d, i) => rScale(maxValue) * Math.sin(angleSlice * i - Math.PI / 2))
.text((d) => d.x)
.attr('text-anchor', 'middle')
.attr('font-size', '12px');
    svg.selectAll('.label-line').data(data).join('line').attr('class', 'label-line')
.attr('x1', 0)
.attr('y1', 0)
.attr('x2', (d, i) => rScale(maxValue) * Math.cos(angleSlice * i - Math.PI / 2))
.attr('y2', (d, i) => rScale(maxValue) * Math.sin(angleSlice * i - Math.PI / 2))
.attr('stroke', 'gray')
.attr('stroke-opacity', 0.6)
.attr('stroke-width', 0.5);
  }
  function createRadialTree(data, options, chartComponents) {
    const { svg } = chartComponents;
    const g = svg.append('g').attr('transform', `translate(${options.width / 2}, ${options.height / 2})`);
    const layout = d3.tree().size([2 * Math.PI, options.radius]);
    const root = d3.hierarchy(data);
    layout(root);
    const linkGenerator = d3.linkRadial().angle((d) => d.x).radius((d) => d.y);
    g.selectAll('.link').data(root.links()).enter().append('path')
.attr('class', 'link')
.attr('d', linkGenerator)
.style('stroke', options.linkColor)
.style('fill', 'none');
    const node = g.selectAll('.node').data(root.descendants()).enter().append('g')
.attr('class', (d) => `node${d.children ? ' node--internal' : ' node--leaf'}`)
.attr('transform', (d) => `translate(${radialPoint(d.x, d.y)})`);
    node.append('circle').attr('r', options.nodeRadius).style('fill', options.nodeColor);
    node.append('text').attr('dy', '.31em').attr('x', (d) => (d.x < Math.PI === !d.children ? 6 : -6)).attr('text-anchor', (d) => (d.x < Math.PI === !d.children ? "start" : "end"))
.attr('transform', (d) => {
      const angle = d.x * 180 / Math.PI;
      const rotation = angle < 180 ? angle - 90 : angle + 90;
      return `rotate(${rotation})`;
    })
.text((d) => d.data.name)
.style('font-size', options.childTextSize)
.style('fill', options.textColor);
    function radialPoint(x2, y2) {
      return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
    }
  }
  function max(values, valueof) {
    let max2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2;
        }
      }
    } else {
      let index = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
          max2 = value2;
        }
      }
    }
    return max2;
  }
  function min(values, valueof) {
    let min2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2;
        }
      }
    } else {
      let index = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
          min2 = value2;
        }
      }
    }
    return min2;
  }
  function sum(values, valueof) {
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value2 of values) {
        if (value2 = +value2) {
          sum2 += value2;
        }
      }
    } else {
      let index = -1;
      for (let value2 of values) {
        if (value2 = +valueof(value2, ++index, values)) {
          sum2 += value2;
        }
      }
    }
    return sum2;
  }
  function justify(node, n) {
    return node.sourceLinks.length ? node.depth : n - 1;
  }
  function constant$1(x2) {
    return function () {
      return x2;
    };
  }
  function ascendingSourceBreadth(a, b) {
    return ascendingBreadth(a.source, b.source) || a.index - b.index;
  }
  function ascendingTargetBreadth(a, b) {
    return ascendingBreadth(a.target, b.target) || a.index - b.index;
  }
  function ascendingBreadth(a, b) {
    return a.y0 - b.y0;
  }
  function value(d) {
    return d.value;
  }
  function defaultId(d) {
    return d.index;
  }
  function defaultNodes(graph) {
    return graph.nodes;
  }
  function defaultLinks(graph) {
    return graph.links;
  }
  function find(nodeById, id) {
    const node = nodeById.get(id);
    if (!node) {throw new Error("missing: " + id);}
    return node;
  }
  function computeLinkBreadths({ nodes }) {
    for (const node of nodes) {
      let {y0} = node;
      let y1 = y0;
      for (const link2 of node.sourceLinks) {
        link2.y0 = y0 + link2.width / 2;
        y0 += link2.width;
      }
      for (const link2 of node.targetLinks) {
        link2.y1 = y1 + link2.width / 2;
        y1 += link2.width;
      }
    }
  }
  function Sankey() {
    let x0 = 0; let y0 = 0; let x1 = 1; let 
y1 = 1;
    let dx = 24;
    let dy = 8; let 
py;
    let id = defaultId;
    let align = justify;
    let sort;
    let linkSort;
    let nodes = defaultNodes;
    let links = defaultLinks;
    let iterations = 6;
    function sankey() {
      const graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
      computeNodeLinks(graph);
      computeNodeValues(graph);
      computeNodeDepths(graph);
      computeNodeHeights(graph);
      computeNodeBreadths(graph);
      computeLinkBreadths(graph);
      return graph;
    }
    sankey.update = function (graph) {
      computeLinkBreadths(graph);
      return graph;
    };
    sankey.nodeId = function (_) {
      return arguments.length ? (id = typeof _ === 'function' ? _ : constant$1(_), sankey) : id;
    };
    sankey.nodeAlign = function (_) {
      return arguments.length ? (align = typeof _ === 'function' ? _ : constant$1(_), sankey) : align;
    };
    sankey.nodeSort = function (_) {
      return arguments.length ? (sort = _, sankey) : sort;
    };
    sankey.nodeWidth = function (_) {
      return arguments.length ? (dx = +_, sankey) : dx;
    };
    sankey.nodePadding = function (_) {
      return arguments.length ? (dy = py = +_, sankey) : dy;
    };
    sankey.nodes = function (_) {
      return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant$1(_), sankey) : nodes;
    };
    sankey.links = function (_) {
      return arguments.length ? (links = typeof _ === 'function' ? _ : constant$1(_), sankey) : links;
    };
    sankey.linkSort = function (_) {
      return arguments.length ? (linkSort = _, sankey) : linkSort;
    };
    sankey.size = function (_) {
      return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
    };
    sankey.extent = function (_) {
      return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
    };
    sankey.iterations = function (_) {
      return arguments.length ? (iterations = +_, sankey) : iterations;
    };
    function computeNodeLinks({ nodes: nodes2, links: links2 }) {
      for (const [i, node] of nodes2.entries()) {
        node.index = i;
        node.sourceLinks = [];
        node.targetLinks = [];
      }
      const nodeById = new Map(nodes2.map((d, i) => [id(d, i, nodes2), d]));
      for (const [i, link2] of links2.entries()) {
        link2.index = i;
        let { source, target } = link2;
        if (typeof source !== 'object') {source = link2.source = find(nodeById, source);}
        if (typeof target !== 'object') {target = link2.target = find(nodeById, target);}
        source.sourceLinks.push(link2);
        target.targetLinks.push(link2);
      }
      if (linkSort != null) {
        for (const { sourceLinks, targetLinks } of nodes2) {
          sourceLinks.sort(linkSort);
          targetLinks.sort(linkSort);
        }
      }
    }
    function computeNodeValues({ nodes: nodes2 }) {
      for (const node of nodes2) {
        node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
      }
    }
    function computeNodeDepths({ nodes: nodes2 }) {
      const n = nodes2.length;
      let current = new Set(nodes2);
      let next = /* @__PURE__ */ new Set();
      let x2 = 0;
      while (current.size) {
        for (const node of current) {
          node.depth = x2;
          for (const { target } of node.sourceLinks) {
            next.add(target);
          }
        }
        if (++x2 > n) {throw new Error("circular link");}
        current = next;
        next = /* @__PURE__ */ new Set();
      }
    }
    function computeNodeHeights({ nodes: nodes2 }) {
      const n = nodes2.length;
      let current = new Set(nodes2);
      let next = /* @__PURE__ */ new Set();
      let x2 = 0;
      while (current.size) {
        for (const node of current) {
          node.height = x2;
          for (const { source } of node.targetLinks) {
            next.add(source);
          }
        }
        if (++x2 > n) {throw new Error("circular link");}
        current = next;
        next = /* @__PURE__ */ new Set();
      }
    }
    function computeNodeLayers({ nodes: nodes2 }) {
      const x2 = max(nodes2, (d) => d.depth) + 1;
      const kx = (x1 - x0 - dx) / (x2 - 1);
      const columns = new Array(x2);
      for (const node of nodes2) {
        const i = Math.max(0, Math.min(x2 - 1, Math.floor(align.call(null, node, x2))));
        node.layer = i;
        node.x0 = x0 + i * kx;
        node.x1 = node.x0 + dx;
        if (columns[i]) {columns[i].push(node);}
        else {columns[i] = [node];}
      }
      if (sort) {for (const column of columns) {
          column.sort(sort);
        }}
      return columns;
    }
    function initializeNodeBreadths(columns) {
      const ky = min(columns, (c) => (y1 - y0 - (c.length - 1) * py) / sum(c, value));
      for (const nodes2 of columns) {
        let y2 = y0;
        for (const node of nodes2) {
          node.y0 = y2;
          node.y1 = y2 + node.value * ky;
          y2 = node.y1 + py;
          for (const link2 of node.sourceLinks) {
            link2.width = link2.value * ky;
          }
        }
        y2 = (y1 - y2 + py) / (nodes2.length + 1);
        for (let i = 0; i < nodes2.length; ++i) {
          const node = nodes2[i];
          node.y0 += y2 * (i + 1);
          node.y1 += y2 * (i + 1);
        }
        reorderLinks(nodes2);
      }
    }
    function computeNodeBreadths(graph) {
      const columns = computeNodeLayers(graph);
      py = Math.min(dy, (y1 - y0) / (max(columns, (c) => c.length) - 1));
      initializeNodeBreadths(columns);
      for (let i = 0; i < iterations; ++i) {
        const alpha = 0.99**i;
        const beta = Math.max(1 - alpha, (i + 1) / iterations);
        relaxRightToLeft(columns, alpha, beta);
        relaxLeftToRight(columns, alpha, beta);
      }
    }
    function relaxLeftToRight(columns, alpha, beta) {
      for (let i = 1, n = columns.length; i < n; ++i) {
        const column = columns[i];
        for (const target of column) {
          let y2 = 0;
          let w = 0;
          for (const { source, value: value2 } of target.targetLinks) {
            const v = value2 * (target.layer - source.layer);
            y2 += targetTop(source, target) * v;
            w += v;
          }
          if (!(w > 0)) {continue;}
          const dy2 = (y2 / w - target.y0) * alpha;
          target.y0 += dy2;
          target.y1 += dy2;
          reorderNodeLinks(target);
        }
        if (sort === void 0) {column.sort(ascendingBreadth);}
        resolveCollisions(column, beta);
      }
    }
    function relaxRightToLeft(columns, alpha, beta) {
      for (let n = columns.length, i = n - 2; i >= 0; --i) {
        const column = columns[i];
        for (const source of column) {
          let y2 = 0;
          let w = 0;
          for (const { target, value: value2 } of source.sourceLinks) {
            const v = value2 * (target.layer - source.layer);
            y2 += sourceTop(source, target) * v;
            w += v;
          }
          if (!(w > 0)) {continue;}
          const dy2 = (y2 / w - source.y0) * alpha;
          source.y0 += dy2;
          source.y1 += dy2;
          reorderNodeLinks(source);
        }
        if (sort === void 0) {column.sort(ascendingBreadth);}
        resolveCollisions(column, beta);
      }
    }
    function resolveCollisions(nodes2, alpha) {
      const i = nodes2.length >> 1;
      const subject = nodes2[i];
      resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
      resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
      resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
      resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
    }
    function resolveCollisionsTopToBottom(nodes2, y2, i, alpha) {
      for (; i < nodes2.length; ++i) {
        const node = nodes2[i];
        const dy2 = (y2 - node.y0) * alpha;
        if (dy2 > 1e-6) {node.y0 += dy2, node.y1 += dy2;}
        y2 = node.y1 + py;
      }
    }
    function resolveCollisionsBottomToTop(nodes2, y2, i, alpha) {
      for (; i >= 0; --i) {
        const node = nodes2[i];
        const dy2 = (node.y1 - y2) * alpha;
        if (dy2 > 1e-6) {node.y0 -= dy2, node.y1 -= dy2;}
        y2 = node.y0 - py;
      }
    }
    function reorderNodeLinks({ sourceLinks, targetLinks }) {
      if (linkSort === void 0) {
        for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
          sourceLinks2.sort(ascendingTargetBreadth);
        }
        for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
          targetLinks2.sort(ascendingSourceBreadth);
        }
      }
    }
    function reorderLinks(nodes2) {
      if (linkSort === void 0) {
        for (const { sourceLinks, targetLinks } of nodes2) {
          sourceLinks.sort(ascendingTargetBreadth);
          targetLinks.sort(ascendingSourceBreadth);
        }
      }
    }
    function targetTop(source, target) {
      let y2 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
      for (const { target: node, width } of source.sourceLinks) {
        if (node === target) {break;}
        y2 += width + py;
      }
      for (const { source: node, width } of target.targetLinks) {
        if (node === source) {break;}
        y2 -= width;
      }
      return y2;
    }
    function sourceTop(source, target) {
      let y2 = target.y0 - (target.targetLinks.length - 1) * py / 2;
      for (const { source: node, width } of target.targetLinks) {
        if (node === source) {break;}
        y2 += width + py;
      }
      for (const { target: node, width } of source.sourceLinks) {
        if (node === target) {break;}
        y2 -= width;
      }
      return y2;
    }
    return sankey;
  }
  let pi = Math.PI; var tau = 2 * pi; var epsilon$1 = 1e-6; var 
tauEpsilon = tau - epsilon$1;
  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = '';
  }
  function path() {
    return new Path();
  }
  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo(x2, y2) {
      this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
    },
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo(x2, y2) {
      this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
    },
    quadraticCurveTo(x1, y1, x2, y2) {
      this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
    },
    bezierCurveTo(x1, y1, x2, y2, x3, y3) {
      this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
    },
    arcTo(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
      if (r < 0)
        throw new Error("negative radius: " + r);
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      } else if (!(l01_2 > epsilon$1))
        ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      } else {
        var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
        if (Math.abs(t01 - 1) > epsilon$1) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }
        this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc(x2, y2, r, a0, a1, ccw) {
      x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (r < 0)
        throw new Error("negative radius: " + r);
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      } else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
        this._ += "L" + x0 + "," + y0;
      }
      if (!r)
        return;
      if (da < 0)
        da = da % tau + tau;
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      } else if (da > epsilon$1) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
      }
    },
    rect(x2, y2, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
    },
    toString() {
      return this._;
    }
  };
  function constant(x2) {
    return function constant2() {
      return x2;
    };
  }
  function x(p) {
    return p[0];
  }
  function y(p) {
    return p[1];
  }
  let {slice} = Array.prototype;
  function linkSource(d) {
    return d.source;
  }
  function linkTarget(d) {
    return d.target;
  }
  function link(curve) {
    let source = linkSource; var target = linkTarget; var x$1 = x; var y$1 = y; var 
context = null;
    function link2() {
      let buffer; var argv = slice.call(arguments); var s = source.apply(this, argv); var 
t = target.apply(this, argv);
      if (!context) {context = buffer = path();}
      curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
      if (buffer) {return context = null, buffer + "" || null;}
    }
    link2.source = function (_) {
      return arguments.length ? (source = _, link2) : source;
    };
    link2.target = function (_) {
      return arguments.length ? (target = _, link2) : target;
    };
    link2.x = function (_) {
      return arguments.length ? (x$1 = typeof _ === 'function' ? _ : constant(+_), link2) : x$1;
    };
    link2.y = function (_) {
      return arguments.length ? (y$1 = typeof _ === 'function' ? _ : constant(+_), link2) : y$1;
    };
    link2.context = function (_) {
      return arguments.length ? (context = _ == null ? null : _, link2) : context;
    };
    return link2;
  }
  function curveHorizontal(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
  }
  function linkHorizontal() {
    return link(curveHorizontal);
  }
  function horizontalSource(d) {
    return [d.source.x1, d.y0];
  }
  function horizontalTarget(d) {
    return [d.target.x0, d.y1];
  }
  function sankeyLinkHorizontal() {
    return linkHorizontal().source(horizontalSource).target(horizontalTarget);
  }
  function createSankeyDiagram(data, options, chartComponents) {
    const {
      width,
      height,
      nodeWidth,
      nodePadding,
    } = options;
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const { svg } = chartComponents;
    svg.append('g');
    const sankey = Sankey().nodeWidth(nodeWidth).nodePadding(nodePadding).extent([[1, 1], [width - 1, height - 5]]);
    const { nodes, links } = sankey(data);
    svg.append('g').selectAll('rect').data(nodes).join('rect')
.attr('x', (d) => d.x0)
.attr('y', (d) => d.y0)
.attr('height', (d) => d.y1 - d.y0)
.attr('width', (d) => d.x1 - d.x0)
.attr('fill', (d) => color(d.index))
.attr('stroke', `${options.strokeColor}`);
    svg.append('g').selectAll('text').data(nodes).join('text')
.attr('x', (d) => d.x0 - 6)
.attr('y', (d) => (d.y1 + d.y0) / 2)
.attr('dy', '0.35em')
.attr('text-anchor', `${options.textAnchor}`)
.text((d) => d.name)
.style('font-size', '12px')
.style('fill', '#000')
.filter((d) => d.x0 < width / 2)
.attr('x', (d) => d.x1 + 6)
.attr('text-anchor', 'start');
    svg.append('g').selectAll('path').data(links).join('path')
.attr('d', sankeyLinkHorizontal())
.attr('fill', 'none')
.attr('stroke', (d) => color(d.source.index))
.attr('stroke-opacity', 0.5)
.attr('stroke-width', (d) => Math.max(1, d.width));
  }
  function createD3ScatterPlot(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    svg.append('g').selectAll('circle').data(data).join('circle')
.attr('cx', (d) => x2(d.x))
.attr('cy', (d) => y2(d.y))
.attr('r', options.radius)
.attr('fill', `${options.color}`);
  }
  function createD3StackedBarChart(data, options, chartComponents) {
    const {
      x: x2,
      y: y2,
      svg,
    } = chartComponents;
    const color = d3.scaleOrdinal().domain(data[0].values.map((v) => v.group)).range(options.color);
    const stack = d3.stack().keys(data[0].values.map((v) => v.group)).value((d, key) => d.find((v) => v.group === key).value);
    const bars = svg.append('g').selectAll('g').data(stack(data.map((d) => d.values))).join('g')
.attr('fill', (d) => color(d.key));
    bars.selectAll('rect').data((d) => d).join('rect').attr('x', (d, i) => x2(data[i].category))
.attr('y', (d) => y2(d[1]))
.attr('height', (d) => y2(d[0]) - y2(d[1]))
.attr('width', x2.bandwidth());
  }
  function createD3SunburstChart(data, options, chartComponents) {
    const color = d3.scaleOrdinal(options.colorScheme);
    const {
      width,
      height,
      margin,
      radius,
    } = options;
    const { svg } = chartComponents;
    const partition = (data2) => {
      const root = d3.hierarchy(data2).sum((d) => d.value).sort((a, b) => b.value - a.value);
      return d3.partition().size([2 * Math.PI, root.height + 1])(root);
    };
    const arc = d3.arc().startAngle((d) => d.x0).endAngle((d) => d.x1).padAngle((d) => Math.min((d.x1 - d.x0) / 2, 5e-3))
.padRadius(radius * 1.5)
.innerRadius((d) => d.y0 * radius)
.outerRadius((d) => Math.max(d.y0 * radius, d.y1 * radius - 1));
    const g = svg.append('g').attr('transform', `translate(${width / 2},${height / 2})`);
    g.selectAll('path').data(partition(data).descendants()).enter().append('path')
.attr('fill', (d) => {
      while (d.depth > 1) {d = d.parent;}
      return color(d.data.name);
    })
.attr('fill-opacity', (d) => (d.children ? 0.6 : 0.4))
.attr('d', arc)
.on('click', (event2, d) => {
    });
    g.selectAll('text').data(partition(data).descendants()).enter().append('text')
.attr('transform', (d) => {
      const x2 = (d.x0 + d.x1) / 2 * 180 / Math.PI;
      const y2 = (d.y0 + d.y1) / 2 * radius;
      return `rotate(${x2 - 90}) translate(${y2},0) rotate(${x2 < 180 ? 0 : 180})`;
    })
.attr('text-anchor', (d) => ((d.x0 + d.x1) / 2 * 180 / Math.PI < 180 ? "start" : "end"))
.attr('dy', '0.35em')
.attr('font-size', options.childTextSize)
.text((d) => d.data.name)
.attr('fill-opacity', (d) => +labelVisible(d))
.attr('display', (d) => (labelVisible(d) ? null : "none"));
    function labelVisible(d) {
      return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0 + 0.01;
    }
  }
  function createTreeDiagram(data, options, chartComponents) {
    const {
      width,
      height,
      color,
      radius,
      strokeColor,
    } = options;
    const { svg } = chartComponents;
    const tree = d3.tree().size([height - 10, width - 10]);
    const root = d3.hierarchy(data);
    tree(root);
    svg.selectAll('.link').data(root.links()).join('path').attr('class', 'link')
.attr('fill', 'none')
.attr('stroke', strokeColor)
.attr('stroke-width', `${options.strokeWidth}` || 1.5)
.attr('stroke-opacity', options.opacity)
.attr('d', d3.linkHorizontal().x((d) => d.y).y((d) => d.x));
    const node = svg.selectAll('.node').data(root.descendants()).join('g').attr('class', 'node')
.attr('transform', (d) => `translate(${d.y}, ${d.x})`);
    node.append('circle').attr('r', radius).style('fill', color);
    node.append('text').attr('dy', '0.31em').attr('x', (d) => (d.children ? -radius : radius)).text((d) => d.data.name)
.style('font-size', `${options.childTextSize}`)
.style('fill', '#000');
  }
  function createD3TreeMap(data, options, chartComponents) {
    const width = options.width || 600;
    const height = options.height || 400;
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const { svg } = chartComponents;
    const treemap = d3.treemap().size([width, height]).padding(1).round(true);
    const root = d3.hierarchy(data).sum((d) => d.value).sort((a, b) => b.value - a.value);
    treemap(root);
    const leaf = svg.selectAll('g').data(root.leaves()).join('g').attr('transform', (d) => `translate(${d.x0},${d.y0})`);
    leaf.append('rect').attr('width', (d) => d.x1 - d.x0).attr('height', (d) => d.y1 - d.y0).attr('fill', (d) => color(d.parent.data.name));
    leaf.append('text').attr('x', 3).attr('y', 12).text((d) => d.data.name)
.style('font-size', `${options.childTextSize}`);
  }
  function d3PolygonArea(polygon) {
    let i = -1; var n = polygon.length; var a; var b = polygon[n - 1]; var 
area = 0;
    while (++i < n) {
      a = b;
      b = polygon[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area / 2;
  }
  function d3PolygonCentroid(polygon) {
    let i = -1; var n = polygon.length; var x2 = 0; var y2 = 0; var a; var b = polygon[n - 1]; var c; var 
k = 0;
    while (++i < n) {
      a = b;
      b = polygon[i];
      k += c = a[0] * b[1] - b[0] * a[1];
      x2 += (a[0] + b[0]) * c;
      y2 += (a[1] + b[1]) * c;
    }
    return k *= 3, [x2 / k, y2 / k];
  }
  function d3PolygonContains(polygon, point) {
    let n = polygon.length; var p = polygon[n - 1]; var x2 = point[0]; var y2 = point[1]; var x0 = p[0]; var y0 = p[1]; var x1; var y1; var 
inside = false;
    for (let i = 0; i < n; ++i) {
      p = polygon[i], x1 = p[0], y1 = p[1];
      if (y1 > y2 !== y0 > y2 && x2 < (x0 - x1) * (y2 - y1) / (y0 - y1) + x1) {inside = !inside;}
      x0 = x1, y0 = y1;
    }
    return inside;
  }
  let frame = 0; var timeout = 0; var interval = 0; var pokeDelay = 1e3; var taskHead; var taskTail; var clockLast = 0; var clockNow = 0; var clockSkew = 0; var clock = typeof performance === "object" && performance.now ? performance : Date; var 
setFrame = typeof window === 'object' && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    let t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    let t = taskHead; var 
e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) {t._call.call(null, e);}
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    let now2 = clock.now(); var 
delay = now2 - clockLast;
    if (delay > pokeDelay) {clockSkew -= delay, clockLast = now2;}
  }
  function nap() {
    let t0; var t1 = taskHead; var t2; var 
time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) {time = t1._time;}
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame) {return;}
    if (timeout) {timeout = clearTimeout(timeout);}
    let delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) {timeout = setTimeout(wake, time - clock.now() - clockSkew);}
      if (interval) {interval = clearInterval(interval);}
    } else {
      if (!interval) {clockLast = clock.now(), interval = setInterval(poke, pokeDelay);}
      frame = 1, setFrame(wake);
    }
  }
  let noop = {
 value: () => {
  } 
};
  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = `${arguments[i]  }`) || t in _ || /[\s.]/.test(t)) {throw new Error("illegal type: " + t);}
      _[t] = [];
    }
    return new Dispatch(_);
  }
  function Dispatch(_) {
    this._ = _;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map((t) => {
      let name = ''; var 
i = t.indexOf('.');
      if (i >= 0) {name = t.slice(i + 1), t = t.slice(0, i);}
      if (t && !types.hasOwnProperty(t)) {throw new Error("unknown type: " + t);}
      return { type: t, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on(typename, callback) {
      var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i < n)
          if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
            return t;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type)
          _[t] = set(_[t], typename.name, callback);
        else if (callback == null)
          for (t in _)
            _[t] = set(_[t], typename.name, null);
      }
      return this;
    },
    copy() {
      var copy = {}, _ = this._;
      for (var t in _)
        copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call(type, that) {
      if ((n = arguments.length - 2) > 0)
        for (var args = new Array(n), i = 0, n, t; i < n; ++i)
          args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    },
    apply(type, that, args) {
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    }
  };
  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }
  function set(type, name, callback) {
    for (let i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) {type.push({ name, value: callback });}
    return type;
  }
  function d3Extent(values, valueof) {
    let min2;
    let max2;
    if (valueof === void 0) {
      for (const value2 of values) {
        if (value2 != null) {
          if (min2 === void 0) {
            if (value2 >= value2) {min2 = max2 = value2;}
          } else {
            if (min2 > value2) {min2 = value2;}
            if (max2 < value2) {max2 = value2;}
          }
        }
      }
    } else {
      let index = -1;
      for (let value2 of values) {
        if ((value2 = valueof(value2, ++index, values)) != null) {
          if (min2 === void 0) {
            if (value2 >= value2) {min2 = max2 = value2;}
          } else {
            if (min2 > value2) {min2 = value2;}
            if (max2 < value2) {max2 = value2;}
          }
        }
      }
    }
    return [min2, max2];
  }
  function cross(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function lexicographicOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  function computeUpperHullIndexes(points) {
    const n = points.length; const 
indexes = [0, 1];
    let size = 2; let 
i;
    for (i = 2; i < n; ++i) {
      while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) {--size;}
      indexes[size++] = i;
    }
    return indexes.slice(0, size);
  }
  function d3PolygonHull(points) {
    if ((n = points.length) < 3) {return null;}
    let i; var n; var sortedPoints = new Array(n); var 
flippedPoints = new Array(n);
    for (i = 0; i < n; ++i) {sortedPoints[i] = [+points[i][0], +points[i][1], i];}
    sortedPoints.sort(lexicographicOrder);
    for (i = 0; i < n; ++i) {flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];}
    let upperIndexes = computeUpperHullIndexes(sortedPoints); var 
lowerIndexes = computeUpperHullIndexes(flippedPoints);
    let skipLeft = lowerIndexes[0] === upperIndexes[0]; var skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1]; var 
hull = [];
    for (i = upperIndexes.length - 1; i >= 0; --i) {hull.push(points[sortedPoints[upperIndexes[i]][2]]);}
    for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) {hull.push(points[sortedPoints[lowerIndexes[i]][2]]);}
    return hull;
  }
  function polygonLength(polygon) {
    let i = -1; var n = polygon.length; var b = polygon[n - 1]; var xa; var ya; var xb = b[0]; var yb = b[1]; var 
perimeter = 0;
    while (++i < n) {
      xa = xb;
      ya = yb;
      b = polygon[i];
      xb = b[0];
      yb = b[1];
      xa -= xb;
      ya -= yb;
      perimeter += Math.hypot(xa, ya);
    }
    return perimeter;
  }
  let epsilon = 1e-10;
  function epsilonesque(n) {
    return n <= epsilon && n >= -epsilon;
  }
  function dot(v0, v1) {
    return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;
  }
  function linearDependent(v0, v1) {
    return epsilonesque(v0.x * v1.y - v0.y * v1.x) && epsilonesque(v0.y * v1.z - v0.z * v1.y) && epsilonesque(v0.z * v1.x - v0.x * v1.z);
  }
  function polygonDirection(polygon) {
    let sign; var crossproduct; var p0; var p1; var p2; var v0; var v1; var 
i;
    p0 = polygon[polygon.length - 2];
    p1 = polygon[polygon.length - 1];
    p2 = polygon[0];
    v0 = vect(p0, p1);
    v1 = vect(p1, p2);
    crossproduct = calculateCrossproduct(v0, v1);
    sign = Math.sign(crossproduct);
    p0 = p1;
    p1 = p2;
    p2 = polygon[1];
    v0 = v1;
    v1 = vect(p1, p2);
    crossproduct = calculateCrossproduct(v0, v1);
    if (Math.sign(crossproduct) !== sign) {
      return void 0;
    }
    for (i = 2; i < polygon.length - 1; i++) {
      p0 = p1;
      p1 = p2;
      p2 = polygon[i];
      v0 = v1;
      v1 = vect(p1, p2);
      crossproduct = calculateCrossproduct(v0, v1);
      if (Math.sign(crossproduct) !== sign) {
        return void 0;
      }
    }
    return sign;
  }
  function vect(from, to) {
    return [to[0] - from[0], to[1] - from[1]];
  }
  function calculateCrossproduct(v0, v1) {
    return v0[0] * v1[1] - v0[1] * v1[0];
  }
  function ConflictListNode(face, vert) {
    this.face = face;
    this.vert = vert;
    this.nextf = null;
    this.prevf = null;
    this.nextv = null;
    this.prevv = null;
  }
  function ConflictList(forFace) {
    this.forFace = forFace;
    this.head = null;
  }
  ConflictList.prototype.add = function (cln) {
    if (this.head === null) {
      this.head = cln;
    } else if (this.forFace) {
        this.head.prevv = cln;
        cln.nextv = this.head;
        this.head = cln;
      } else {
        this.head.prevf = cln;
        cln.nextf = this.head;
        this.head = cln;
      }
  };
  ConflictList.prototype.isEmpty = function () {
    return this.head === null;
  };
  ConflictList.prototype.fill = function (visible) {
    if (this.forFace) {
      return;
    }
    let curr = this.head;
    do {
      visible.push(curr.face);
      curr.face.marked = true;
      curr = curr.nextf;
    } while (curr !== null);
  };
  ConflictList.prototype.removeAll = function () {
    if (this.forFace) {
      var curr = this.head;
      do {
        if (curr.prevf === null) {
          if (curr.nextf === null) {
            curr.vert.conflicts.head = null;
          } else {
            curr.nextf.prevf = null;
            curr.vert.conflicts.head = curr.nextf;
          }
        } else {
          if (curr.nextf != null) {
            curr.nextf.prevf = curr.prevf;
          }
          curr.prevf.nextf = curr.nextf;
        }
        curr = curr.nextv;
        if (curr != null) {
          curr.prevv = null;
        }
      } while (curr != null);
    } else {
      var curr = this.head;
      do {
        if (curr.prevv == null) {
          if (curr.nextv == null) {
            curr.face.conflicts.head = null;
          } else {
            curr.nextv.prevv = null;
            curr.face.conflicts.head = curr.nextv;
          }
        } else {
          if (curr.nextv != null) {
            curr.nextv.prevv = curr.prevv;
          }
          curr.prevv.nextv = curr.nextv;
        }
        curr = curr.nextf;
        if (curr != null) {curr.prevf = null;}
      } while (curr != null);
    }
  };
  ConflictList.prototype.getVertices = function () {
    let list = []; var 
curr = this.head;
    while (curr !== null) {
      list.push(curr.vert);
      curr = curr.nextv;
    }
    return list;
  };
  function Vertex(x2, y2, z, weight, orig, isDummy) {
    this.x = x2;
    this.y = y2;
    this.weight = epsilon;
    this.index = 0;
    this.conflicts = new ConflictList(false);
    this.neighbours = null;
    this.nonClippedPolygon = null;
    this.polygon = null;
    this.originalObject = null;
    this.isDummy = false;
    if (orig !== void 0) {
      this.originalObject = orig;
    }
    if (isDummy != void 0) {
      this.isDummy = isDummy;
    }
    if (weight != null) {
      this.weight = weight;
    }
    if (z != null) {
      this.z = z;
    } else {
      this.z = this.projectZ(this.x, this.y, this.weight);
    }
  }
  Vertex.prototype.projectZ = function (x2, y2, weight) {
    return x2 * x2 + y2 * y2 - weight;
  };
  Vertex.prototype.setWeight = function (weight) {
    this.weight = weight;
    this.z = this.projectZ(this.x, this.y, this.weight);
  };
  Vertex.prototype.subtract = function (v) {
    return new Vertex(v.x - this.x, v.y - this.y, v.z - this.z);
  };
  Vertex.prototype.crossproduct = function (v) {
    return new Vertex(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
  };
  Vertex.prototype.equals = function (v) {
    return this.x === v.x && this.y === v.y && this.z === v.z;
  };
  function Plane3D(face) {
    let p1 = face.verts[0];
    let p2 = face.verts[1];
    let p3 = face.verts[2];
    this.a = p1.y * (p2.z - p3.z) + p2.y * (p3.z - p1.z) + p3.y * (p1.z - p2.z);
    this.b = p1.z * (p2.x - p3.x) + p2.z * (p3.x - p1.x) + p3.z * (p1.x - p2.x);
    this.c = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);
    this.d = -1 * (p1.x * (p2.y * p3.z - p3.y * p2.z) + p2.x * (p3.y * p1.z - p1.y * p3.z) + p3.x * (p1.y * p2.z - p2.y * p1.z));
  }
  Plane3D.prototype.getNormZPlane = function () {
    return [
      -1 * (this.a / this.c),
      -1 * (this.b / this.c),
      -1 * (this.d / this.c),
    ];
  };
  Plane3D.prototype.getDualPointMappedToPlane = function () {
    let nplane = this.getNormZPlane();
    let dualPoint = new Point2D(nplane[0] / 2, nplane[1] / 2);
    return dualPoint;
  };
  function Point2D(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  function Vector(x2, y2, z) {
    this.x = x2;
    this.y = y2;
    this.z = z;
  }
  Vector.prototype.negate = function () {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
  };
  Vector.prototype.normalize = function () {
    let lenght = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    if (lenght > 0) {
      this.x /= lenght;
      this.y /= lenght;
      this.z /= lenght;
    }
  };
  function HEdge(orig, dest, face) {
    this.next = null;
    this.prev = null;
    this.twin = null;
    this.orig = orig;
    this.dest = dest;
    this.iFace = face;
  }
  HEdge.prototype.isHorizon = function () {
    return this.twin !== null && !this.iFace.marked && this.twin.iFace.marked;
  };
  HEdge.prototype.findHorizon = function(horizon) {
    if (this.isHorizon()) {
      if (horizon.length > 0 && this === horizon[0]) {
        
      } else {
        horizon.push(this);
        this.next.findHorizon(horizon);
      }
    } else {
      if (this.twin !== null) {
        this.twin.next.findHorizon(horizon);
      }
    }
  };
  HEdge.prototype.isEqual = function (origin, dest) {
    return this.orig.equals(origin) && this.dest.equals(dest) || this.orig.equals(dest) && this.dest.equals(origin);
  };
  function d3WeightedVoronoiError(message) {
    this.message = message;
    this.stack = new Error().stack;
  }
  d3WeightedVoronoiError.prototype.name = 'd3WeightedVoronoiError';
  d3WeightedVoronoiError.prototype = new Error();
  function Face(a, b, c, orient) {
    this.conflicts = new ConflictList(true);
    this.verts = [a, b, c];
    this.marked = false;
    let t = a.subtract(b).crossproduct(b.subtract(c));
    this.normal = new Vector(-t.x, -t.y, -t.z);
    this.normal.normalize();
    this.createEdges();
    this.dualPoint = null;
    if (orient != void 0) {
      this.orient(orient);
    }
  }
  Face.prototype.getDualPoint = function () {
    if (this.dualPoint == null) {
      let plane3d = new Plane3D(this);
      this.dualPoint = plane3d.getDualPointMappedToPlane();
    }
    return this.dualPoint;
  };
  Face.prototype.isVisibleFromBelow = function () {
    return this.normal.z < -14259414393190911e-25;
  };
  Face.prototype.createEdges = function () {
    this.edges = [];
    this.edges[0] = new HEdge(this.verts[0], this.verts[1], this);
    this.edges[1] = new HEdge(this.verts[1], this.verts[2], this);
    this.edges[2] = new HEdge(this.verts[2], this.verts[0], this);
    this.edges[0].next = this.edges[1];
    this.edges[0].prev = this.edges[2];
    this.edges[1].next = this.edges[2];
    this.edges[1].prev = this.edges[0];
    this.edges[2].next = this.edges[0];
    this.edges[2].prev = this.edges[1];
  };
  Face.prototype.orient = function (orient) {
    if (!(dot(this.normal, orient) < dot(this.normal, this.verts[0]))) {
      let temp = this.verts[1];
      this.verts[1] = this.verts[2];
      this.verts[2] = temp;
      this.normal.negate();
      this.createEdges();
    }
  };
  Face.prototype.getEdge = function (v0, v1) {
    for (let i = 0; i < 3; i++) {
      if (this.edges[i].isEqual(v0, v1)) {
        return this.edges[i];
      }
    }
    return null;
  };
  Face.prototype.link = function (face, v0, v1) {
    if (face instanceof Face) {
      var twin = face.getEdge(v0, v1);
      if (twin === null) {
        throw new d3WeightedVoronoiError('when linking, twin is null');
      }
      var edge = this.getEdge(v0, v1);
      if (edge === null) {
        throw new d3WeightedVoronoiError('when linking, twin is null');
      }
      twin.twin = edge;
      edge.twin = twin;
    } else {
      var twin = face;
      var edge = this.getEdge(twin.orig, twin.dest);
      twin.twin = edge;
      edge.twin = twin;
    }
  };
  Face.prototype.conflict = function (v) {
    return dot(this.normal, v) > dot(this.normal, this.verts[0]) + epsilon;
  };
  Face.prototype.getHorizon = function () {
    for (let i = 0; i < 3; i++) {
      if (this.edges[i].twin !== null && this.edges[i].twin.isHorizon()) {
        return this.edges[i];
      }
    }
    return null;
  };
  Face.prototype.removeConflict = function () {
    this.conflicts.removeAll();
  };
  function ConvexHull() {
    this.points = [];
    this.facets = [];
    this.created = [];
    this.horizon = [];
    this.visible = [];
    this.current = 0;
  }
  ConvexHull.prototype.init = function (boundingSites, sites) {
    this.points = [];
    for (let i = 0; i < sites.length; i++) {
      this.points[i] = new Vertex(sites[i].x, sites[i].y, sites[i].z, null, sites[i], false);
    }
    this.points = this.points.concat(boundingSites);
  };
  ConvexHull.prototype.permutate = function () {
    let pointSize = this.points.length;
    for (let i = pointSize - 1; i > 0; i--) {
      let ra = Math.floor(Math.random() * i);
      let temp = this.points[ra];
      temp.index = i;
      let currentItem = this.points[i];
      currentItem.index = ra;
      this.points.splice(ra, 1, currentItem);
      this.points.splice(i, 1, temp);
    }
  };
  ConvexHull.prototype.prep = function () {
    if (this.points.length <= 3) {
      throw new d3WeightedVoronoiError('Less than 4 points');
    }
    for (var i = 0; i < this.points.length; i++) {
      this.points[i].index = i;
    }
    let v0; var v1; var v2; var 
v3;
    let f1; var f2; var f3; var 
f0;
    v0 = this.points[0];
    v1 = this.points[1];
    v2 = v3 = null;
    for (var i = 2; i < this.points.length; i++) {
      if (!(linearDependent(v0, this.points[i]) && linearDependent(v1, this.points[i]))) {
        v2 = this.points[i];
        v2.index = 2;
        this.points[2].index = i;
        this.points.splice(i, 1, this.points[2]);
        this.points.splice(2, 1, v2);
        break;
      }
    }
    if (v2 === null) {
      throw new d3WeightedVoronoiError('Not enough non-planar Points (v2 is null)');
    }
    f0 = new Face(v0, v1, v2);
    for (var i = 3; i < this.points.length; i++) {
      if (!epsilonesque(dot(f0.normal, f0.verts[0]) - dot(f0.normal, this.points[i]))) {
        v3 = this.points[i];
        v3.index = 3;
        this.points[3].index = i;
        this.points.splice(i, 1, this.points[3]);
        this.points.splice(3, 1, v3);
        break;
      }
    }
    if (v3 === null) {
      throw new d3WeightedVoronoiError('Not enough non-planar Points (v3 is null)');
    }
    f0.orient(v3);
    f1 = new Face(v0, v2, v3, v1);
    f2 = new Face(v0, v1, v3, v2);
    f3 = new Face(v1, v2, v3, v0);
    this.addFacet(f0);
    this.addFacet(f1);
    this.addFacet(f2);
    this.addFacet(f3);
    f0.link(f1, v0, v2);
    f0.link(f2, v0, v1);
    f0.link(f3, v1, v2);
    f1.link(f2, v0, v3);
    f1.link(f3, v2, v3);
    f2.link(f3, v3, v1);
    this.current = 4;
    let v;
    for (var i = this.current; i < this.points.length; i++) {
      v = this.points[i];
      if (f0.conflict(v)) {
        this.addConflict(f0, v);
      }
      if (f1.conflict(v)) {
        this.addConflict(f1, v);
      }
      if (f2.conflict(v)) {
        this.addConflict(f2, v);
      }
      if (f3.conflict(v)) {
        this.addConflict(f3, v);
      }
    }
  }, // IN: Faces old1 old2 and fn
  ConvexHull.prototype.addConflicts = function (old1, old2, fn) {
    let l1 = old1.conflicts.getVertices();
    let l2 = old2.conflicts.getVertices();
    let nCL = [];
    let v1; var 
v2;
    var i; var 
l;
    i = l = 0;
    while (i < l1.length || l < l2.length) {
      if (i < l1.length && l < l2.length) {
        v1 = l1[i];
        v2 = l2[l];
        if (v1.index === v2.index) {
          nCL.push(v1);
          i++;
          l++;
        } else if (v1.index > v2.index) {
          nCL.push(v1);
          i++;
        } else {
          nCL.push(v2);
          l++;
        }
      } else if (i < l1.length) {
        nCL.push(l1[i++]);
      } else {
        nCL.push(l2[l++]);
      }
    }
    for (var i = nCL.length - 1; i >= 0; i--) {
      v1 = nCL[i];
      if (fn.conflict(v1)) {this.addConflict(fn, v1);}
    }
  };
  ConvexHull.prototype.addConflict = function (face, vert) {
    let e = new ConflictListNode(face, vert);
    face.conflicts.add(e);
    vert.conflicts.add(e);
  };
  ConvexHull.prototype.removeConflict = function (f) {
    f.removeConflict();
    let {index} = f;
    f.index = -1;
    if (index === this.facets.length - 1) {
      this.facets.splice(this.facets.length - 1, 1);
      return;
    }
    if (index >= this.facets.length || index < 0) {return;}
    let last = this.facets.splice(this.facets.length - 1, 1);
    last[0].index = index;
    this.facets.splice(index, 1, last[0]);
  };
  ConvexHull.prototype.addFacet = function (face) {
    face.index = this.facets.length;
    this.facets.push(face);
  };
  ConvexHull.prototype.compute = function () {
    this.prep();
    while (this.current < this.points.length) {
      let next = this.points[this.current];
      if (next.conflicts.isEmpty()) {
        this.current++;
        continue;
      }
      this.created = [];
      this.horizon = [];
      this.visible = [];
      next.conflicts.fill(this.visible);
      var e;
      for (let jF = 0; jF < this.visible.length; jF++) {
        e = this.visible[jF].getHorizon();
        if (e !== null) {
          e.findHorizon(this.horizon);
          break;
        }
      }
      let last = null; var 
first = null;
      for (let hEi = 0; hEi < this.horizon.length; hEi++) {
        let hE = this.horizon[hEi];
        let fn = new Face(next, hE.orig, hE.dest, hE.twin.next.dest);
        fn.conflicts = new ConflictList(true);
        this.addFacet(fn);
        this.created.push(fn);
        this.addConflicts(hE.iFace, hE.twin.iFace, fn);
        fn.link(hE);
        if (last !== null) {fn.link(last, next, hE.orig);}
        last = fn;
        if (first === null) {first = fn;}
      }
      if (first !== null && last !== null) {
        last.link(first, next, this.horizon[0].orig);
      }
      if (this.created.length != 0) {
        for (let f = 0; f < this.visible.length; f++) {
          this.removeConflict(this.visible[f]);
        }
        this.current++;
        this.created = [];
      }
    }
    return this.facets;
  };
  ConvexHull.prototype.clear = function () {
    this.points = [];
    this.facets = [];
    this.created = [];
    this.horizon = [];
    this.visible = [];
    this.current = 0;
  };
  function polygonClip(clip, subject) {
    let input; var closed = polygonClosed(subject); var i = -1; var n = clip.length - polygonClosed(clip); var j; var m; var a = clip[n - 1]; var b; var c; var d; var 
intersection;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = clip[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (polygonInside(d, a, b)) {
          if (!polygonInside(c, a, b)) {
            intersection = polygonIntersect(c, d, a, b);
            if (isFinite(intersection[0])) {
              subject.push(intersection);
            }
          }
          subject.push(d);
        } else if (polygonInside(c, a, b)) {
          intersection = polygonIntersect(c, d, a, b);
          if (isFinite(intersection[0])) {
            subject.push(intersection);
          }
        }
        c = d;
      }
      if (closed) {subject.push(subject[0]);}
      a = b;
    }
    return subject;
  }
  function polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function polygonIntersect(c, d, a, b) {
    let x1 = c[0]; var x3 = a[0]; var x21 = d[0] - x1; var x43 = b[0] - x3; var y1 = c[1]; var y3 = a[1]; var y21 = d[1] - y1; var y43 = b[1] - y3; var 
ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [x1 + ua * x21, y1 + ua * y21];
  }
  function polygonClosed(coordinates) {
    let a = coordinates[0]; var 
b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  function getFacesOfDestVertex(edge) {
    let faces = [];
    let previous = edge;
    let first = edge.dest;
    let site = first.originalObject;
    let neighbours = [];
    do {
      previous = previous.twin.prev;
      let siteOrigin = previous.orig.originalObject;
      if (!siteOrigin.isDummy) {
        neighbours.push(siteOrigin);
      }
      let {iFace} = previous;
      if (iFace.isVisibleFromBelow()) {
        faces.push(iFace);
      }
    } while (previous !== edge);
    site.neighbours = neighbours;
    return faces;
  }
  function computePowerDiagramIntegrated(sites, boundingSites, clippingPolygon) {
    let convexHull = new ConvexHull();
    convexHull.clear();
    convexHull.init(boundingSites, sites);
    let facets = convexHull.compute(sites);
    let polygons = [];
    let verticesVisited = [];
    let facetCount = facets.length;
    for (let i = 0; i < facetCount; i++) {
      let facet = facets[i];
      if (facet.isVisibleFromBelow()) {
        for (let e = 0; e < 3; e++) {
          let edge = facet.edges[e];
          let destVertex = edge.dest;
          let site = destVertex.originalObject;
          if (!verticesVisited[destVertex.index]) {
            verticesVisited[destVertex.index] = true;
            if (site.isDummy) {
              continue;
            }
            let faces = getFacesOfDestVertex(edge);
            let protopoly = [];
            let lastX = null;
            let lastY = null;
            let dx = 1;
            let dy = 1;
            for (let j = 0; j < faces.length; j++) {
              let point = faces[j].getDualPoint();
              let x1 = point.x;
              let y1 = point.y;
              if (lastX !== null) {
                dx = lastX - x1;
                dy = lastY - y1;
                if (dx < 0) {
                  dx = -dx;
                }
                if (dy < 0) {
                  dy = -dy;
                }
              }
              if (dx > epsilon || dy > epsilon) {
                protopoly.push([x1, y1]);
                lastX = x1;
                lastY = y1;
              }
            }
            site.nonClippedPolygon = protopoly.reverse();
            if (!site.isDummy && polygonLength(site.nonClippedPolygon) > 0) {
              let clippedPoly = polygonClip(clippingPolygon, site.nonClippedPolygon);
              site.polygon = clippedPoly;
              clippedPoly.site = site;
              if (clippedPoly.length > 0) {
                polygons.push(clippedPoly);
              }
            }
          }
        }
      }
    }
    return polygons;
  }
  function weightedVoronoi() {
    let x2 = function (d) {
      return d.x;
    };
    let y2 = function (d) {
      return d.y;
    };
    let weight = function (d) {
      return d.weight;
    };
    let clip = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
    ];
    let extent = [
      [0, 0],
      [1, 1],
    ];
    let size = [1, 1];
    function _weightedVoronoi(data) {
      let formatedSites;
      formatedSites = data.map((d) => {
        return new Vertex(x2(d), y2(d), null, weight(d), d, false);
      });
      return computePowerDiagramIntegrated(formatedSites, boundingSites(), clip);
    }
    _weightedVoronoi.x = function (_) {
      if (!arguments.length) {
        return x2;
      }
      x2 = _;
      return _weightedVoronoi;
    };
    _weightedVoronoi.y = function (_) {
      if (!arguments.length) {
        return y2;
      }
      y2 = _;
      return _weightedVoronoi;
    };
    _weightedVoronoi.weight = function (_) {
      if (!arguments.length) {
        return weight;
      }
      weight = _;
      return _weightedVoronoi;
    };
    _weightedVoronoi.clip = function (_) {
      let direction2; var xExtent; var 
yExtent;
      if (!arguments.length) {
        return clip;
      }
      xExtent = d3Extent(
        _.map((c) => {
          return c[0];
        })
      );
      yExtent = d3Extent(
        _.map((c) => {
          return c[1];
        })
      );
      direction2 = polygonDirection(_);
      if (direction2 === void 0) {
        clip = d3PolygonHull(_);
      } else if (direction2 === 1) {
        clip = _.reverse();
      } else {
        clip = _;
      }
      extent = [
        [xExtent[0], yExtent[0]],
        [xExtent[1], yExtent[1]],
      ];
      size = [xExtent[1] - xExtent[0], yExtent[1] - yExtent[0]];
      return _weightedVoronoi;
    };
    _weightedVoronoi.extent = function (_) {
      if (!arguments.length) {
        return extent;
      }
      clip = [_[0], [_[0][0], _[1][1]], _[1], [_[1][0], _[0][1]]];
      extent = _;
      size = [_[1][0] - _[0][0], _[1][1] - _[0][1]];
      return _weightedVoronoi;
    };
    _weightedVoronoi.size = function (_) {
      if (!arguments.length) {
        return size;
      }
      clip = [
        [0, 0],
        [0, _[1]],
        [_[0], _[1]],
        [_[0], 0],
      ];
      extent = [[0, 0], _];
      size = _;
      return _weightedVoronoi;
    };
    function boundingSites() {
      let minX; var maxX; var minY; var maxY; var width; var height; var x0; var x1; var y0; var y1; var boundingData = []; var 
boundingSites2 = [];
      minX = extent[0][0];
      maxX = extent[1][0];
      minY = extent[0][1];
      maxY = extent[1][1];
      width = maxX - minX;
      height = maxY - minY;
      x0 = minX - width;
      x1 = maxX + width;
      y0 = minY - height;
      y1 = maxY + height;
      boundingData[0] = [x0, y0];
      boundingData[1] = [x0, y1];
      boundingData[2] = [x1, y1];
      boundingData[3] = [x1, y0];
      for (let i = 0; i < 4; i++) {
        boundingSites2.push(
          new Vertex(
            boundingData[i][0],
            boundingData[i][1],
            null,
            epsilon,
            new Vertex(boundingData[i][0], boundingData[i][1], null, epsilon, null, true),
            true
          )
        );
      }
      return boundingSites2;
    }
    return _weightedVoronoi;
  }
  function FlickeringMitigation() {
    this.growthChangesLength = DEFAULT_LENGTH;
    this.totalAvailableArea = NaN;
    this.lastAreaError = NaN;
    this.lastGrowth = NaN;
    this.growthChanges = [];
    this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
    this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
  }
  var DEFAULT_LENGTH = 10;
  function direction(h0, h1) {
    return h0 >= h1 ? 1 : -1;
  }
  function generateGrowthChangeWeights(length) {
    let initialWeight = 3;
    let weightDecrement = 1;
    let minWeight = 1;
    let weightedCount = initialWeight;
    let growthChangeWeights = [];
    for (let i = 0; i < length; i++) {
      growthChangeWeights.push(weightedCount);
      weightedCount -= weightDecrement;
      if (weightedCount < minWeight) {
        weightedCount = minWeight;
      }
    }
    return growthChangeWeights;
  }
  function computeGrowthChangeWeightsSum(growthChangeWeights) {
    let growthChangeWeightsSum = 0;
    for (let i = 0; i < growthChangeWeights.length; i++) {
      growthChangeWeightsSum += growthChangeWeights[i];
    }
    return growthChangeWeightsSum;
  }
  FlickeringMitigation.prototype.reset = function () {
    this.lastAreaError = NaN;
    this.lastGrowth = NaN;
    this.growthChanges = [];
    this.growthChangesLength = DEFAULT_LENGTH;
    this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
    this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
    this.totalAvailableArea = NaN;
    return this;
  };
  FlickeringMitigation.prototype.clear = function () {
    this.lastAreaError = NaN;
    this.lastGrowth = NaN;
    this.growthChanges = [];
    return this;
  };
  FlickeringMitigation.prototype.length = function (_) {
    if (!arguments.length) {
      return this.growthChangesLength;
    }
    if (parseInt(_) > 0) {
      this.growthChangesLength = Math.floor(parseInt(_));
      this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
      this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
    } else {
      console.warn('FlickeringMitigation.length() accepts only positive integers; unable to handle ' + _);
    }
    return this;
  };
  FlickeringMitigation.prototype.totalArea = function (_) {
    if (!arguments.length) {
      return this.totalAvailableArea;
    }
    if (parseFloat(_) > 0) {
      this.totalAvailableArea = parseFloat(_);
    } else {
      console.warn('FlickeringMitigation.totalArea() accepts only positive numbers; unable to handle ' + _);
    }
    return this;
  };
  FlickeringMitigation.prototype.add = function (areaError) {
    let secondToLastAreaError; var 
secondToLastGrowth;
    secondToLastAreaError = this.lastAreaError;
    this.lastAreaError = areaError;
    if (!isNaN(secondToLastAreaError)) {
      secondToLastGrowth = this.lastGrowth;
      this.lastGrowth = direction(this.lastAreaError, secondToLastAreaError);
    }
    if (!isNaN(secondToLastGrowth)) {
      this.growthChanges.unshift(this.lastGrowth != secondToLastGrowth);
    }
    if (this.growthChanges.length > this.growthChangesLength) {
      this.growthChanges.pop();
    }
    return this;
  };
  FlickeringMitigation.prototype.ratio = function () {
    let weightedChangeCount = 0;
    let ratio;
    if (this.growthChanges.length < this.growthChangesLength) {
      return 0;
    }
    if (this.lastAreaError > this.totalAvailableArea / 10) {
      return 0;
    }
    for (let i = 0; i < this.growthChangesLength; i++) {
      if (this.growthChanges[i]) {
        weightedChangeCount += this.growthChangeWeights[i];
      }
    }
    ratio = weightedChangeCount / this.growthChangeWeightsSum;
    return ratio;
  };
  function randomInitialPosition() {
    let clippingPolygon; var extent; var minX; var maxX; var minY; var maxY; var dx; var 
dy;
    function _random(d, i, arr, voronoiMapSimulation2) {
      let shouldUpdateInternals = false;
      let x2; var 
y2;
      if (clippingPolygon !== voronoiMapSimulation2.clip()) {
        clippingPolygon = voronoiMapSimulation2.clip();
        extent = voronoiMapSimulation2.extent();
        shouldUpdateInternals = true;
      }
      if (shouldUpdateInternals) {
        updateInternals();
      }
      x2 = minX + dx * voronoiMapSimulation2.prng()();
      y2 = minY + dy * voronoiMapSimulation2.prng()();
      while (!d3PolygonContains(clippingPolygon, [x2, y2])) {
        x2 = minX + dx * voronoiMapSimulation2.prng()();
        y2 = minY + dy * voronoiMapSimulation2.prng()();
      }
      return [x2, y2];
    }
    function updateInternals() {
      minX = extent[0][0];
      maxX = extent[1][0];
      minY = extent[0][1];
      maxY = extent[1][1];
      dx = maxX - minX;
      dy = maxY - minY;
    }
    return _random;
  }
  function halfAverageAreaInitialWeight() {
    let clippingPolygon; var dataArray; var siteCount; var totalArea; var 
halfAverageArea;
    function _halfAverageArea(d, i, arr, voronoiMapSimulation2) {
      let shouldUpdateInternals = false;
      if (clippingPolygon !== voronoiMapSimulation2.clip()) {
        clippingPolygon = voronoiMapSimulation2.clip();
        shouldUpdateInternals |= true;
      }
      if (dataArray !== arr) {
        dataArray = arr;
        shouldUpdateInternals |= true;
      }
      if (shouldUpdateInternals) {
        updateInternals();
      }
      return halfAverageArea;
    }
    function updateInternals() {
      siteCount = dataArray.length;
      totalArea = d3PolygonArea(clippingPolygon);
      halfAverageArea = totalArea / siteCount / 2;
    }
    return _halfAverageArea;
  }
  function d3VoronoiMapError(message) {
    this.message = message;
    this.stack = new Error().stack;
  }
  d3VoronoiMapError.prototype.name = 'd3VoronoiMapError';
  d3VoronoiMapError.prototype = new Error();
  function voronoiMapSimulation(data) {
    let DEFAULT_CONVERGENCE_RATIO = 0.01;
    let DEFAULT_MAX_ITERATION_COUNT = 50;
    let DEFAULT_MIN_WEIGHT_RATIO = 0.01;
    let DEFAULT_PRNG = Math.random;
    let DEFAULT_INITIAL_POSITION = randomInitialPosition();
    let DEFAULT_INITIAL_WEIGHT = halfAverageAreaInitialWeight();
    let epsilon2 = 1e-10;
    let weight = function (d) {
      return d.weight;
    };
    let convergenceRatio = DEFAULT_CONVERGENCE_RATIO;
    let maxIterationCount = DEFAULT_MAX_ITERATION_COUNT;
    let minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO;
    let prng = DEFAULT_PRNG;
    let initialPosition = DEFAULT_INITIAL_POSITION;
    let initialWeight = DEFAULT_INITIAL_WEIGHT;
    let weightedVoronoi$1 = weightedVoronoi(); var flickeringMitigation = new FlickeringMitigation(); var shouldInitialize = true; var siteCount; var totalArea; var areaErrorTreshold; var iterationCount; var polygons; var areaError; var converged; var 
ended;
    let simulation; var stepper = timer(step); var 
event2 = dispatch('tick', 'end');
    const HANDLE_OVERWEIGHTED_VARIANT = 1;
    const HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT = 1e3;
    let handleOverweighted;
    function sqr(d) {
      return d**2;
    }
    function squaredDistance(s0, s1) {
      return sqr(s1.x - s0.x) + sqr(s1.y - s0.y);
    }
    simulation = {
      tick,
      restart() {
        stepper.restart(step);
        return simulation;
      },
      stop() {
        stepper.stop();
        return simulation;
      },
      weight(_) {
        if (!arguments.length) {
          return weight;
        }
        weight = _;
        shouldInitialize = true;
        return simulation;
      },
      convergenceRatio(_) {
        if (!arguments.length) {
          return convergenceRatio;
        }
        convergenceRatio = _;
        shouldInitialize = true;
        return simulation;
      },
      maxIterationCount(_) {
        if (!arguments.length) {
          return maxIterationCount;
        }
        maxIterationCount = _;
        return simulation;
      },
      minWeightRatio(_) {
        if (!arguments.length) {
          return minWeightRatio;
        }
        minWeightRatio = _;
        shouldInitialize = true;
        return simulation;
      },
      clip(_) {
        if (!arguments.length) {
          return weightedVoronoi$1.clip();
        }
        weightedVoronoi$1.clip(_);
        shouldInitialize = true;
        return simulation;
      },
      extent(_) {
        if (!arguments.length) {
          return weightedVoronoi$1.extent();
        }
        weightedVoronoi$1.extent(_);
        shouldInitialize = true;
        return simulation;
      },
      size(_) {
        if (!arguments.length) {
          return weightedVoronoi$1.size();
        }
        weightedVoronoi$1.size(_);
        shouldInitialize = true;
        return simulation;
      },
      prng(_) {
        if (!arguments.length) {
          return prng;
        }
        prng = _;
        shouldInitialize = true;
        return simulation;
      },
      initialPosition(_) {
        if (!arguments.length) {
          return initialPosition;
        }
        initialPosition = _;
        shouldInitialize = true;
        return simulation;
      },
      initialWeight(_) {
        if (!arguments.length) {
          return initialWeight;
        }
        initialWeight = _;
        shouldInitialize = true;
        return simulation;
      },
      state() {
        if (shouldInitialize) {
          initializeSimulation();
        }
        return {
          ended,
          iterationCount,
          convergenceRatio: areaError / totalArea,
          polygons
        };
      },
      on(name, _) {
        if (arguments.length === 1) {
          return event2.on(name);
        }
        event2.on(name, _);
        return simulation;
      }
    };
    function step() {
      tick();
      event2.call('tick', simulation);
      if (ended) {
        stepper.stop();
        event2.call('end', simulation);
      }
    }
    function tick() {
      if (!ended) {
        if (shouldInitialize) {
          initializeSimulation();
        }
        polygons = adapt(polygons, flickeringMitigation.ratio());
        iterationCount++;
        areaError = computeAreaError(polygons);
        flickeringMitigation.add(areaError);
        converged = areaError < areaErrorTreshold;
        ended = converged || iterationCount >= maxIterationCount;
      }
    }
    function initializeSimulation() {
      setHandleOverweighted();
      siteCount = data.length;
      totalArea = Math.abs(d3PolygonArea(weightedVoronoi$1.clip()));
      areaErrorTreshold = convergenceRatio * totalArea;
      flickeringMitigation.clear().totalArea(totalArea);
      iterationCount = 0;
      converged = false;
      polygons = initialize(data, simulation);
      ended = false;
      shouldInitialize = false;
    }
    function initialize(data2, simulation2) {
      let maxWeight = data2.reduce((max2, d) => {
          return Math.max(max2, weight(d));
        }, -Infinity); var 
minAllowedWeight = maxWeight * minWeightRatio;
      let weights; var 
mapPoints;
      weights = data2.map((d, i, arr) => {
        return {
          index: i,
          weight: Math.max(weight(d), minAllowedWeight),
          initialPosition: initialPosition(d, i, arr, simulation2),
          initialWeight: initialWeight(d, i, arr, simulation2),
          originalData: d,
        };
      });
      mapPoints = createMapPoints(weights, simulation2);
      handleOverweighted(mapPoints);
      return weightedVoronoi$1(mapPoints);
    }
    function createMapPoints(basePoints, simulation2) {
      let totalWeight = basePoints.reduce((acc, bp) => {
        return acc += bp.weight;
      }, 0);
      let initialPosition2;
      return basePoints.map((bp, i, bps) => {
        initialPosition2 = bp.initialPosition;
        if (!d3PolygonContains(weightedVoronoi$1.clip(), initialPosition2)) {
          initialPosition2 = DEFAULT_INITIAL_POSITION(bp, i, bps, simulation2);
        }
        return {
          index: bp.index,
          targetedArea: totalArea * bp.weight / totalWeight,
          data: bp,
          x: initialPosition2[0],
          y: initialPosition2[1],
          weight: bp.initialWeight,
          // ArlindNocaj/Voronoi-Treemap-Library uses an epsilonesque initial weight; using heavier initial weights allows faster weight adjustements, hence faster stabilization
        };
      });
    }
    function adapt(polygons2, flickeringMitigationRatio) {
      let adaptedMapPoints;
      adaptPositions(polygons2, flickeringMitigationRatio);
      adaptedMapPoints = polygons2.map((p) => {
        return p.site.originalObject;
      });
      polygons2 = weightedVoronoi$1(adaptedMapPoints);
      if (polygons2.length < siteCount) {
        throw new d3VoronoiMapError('at least 1 site has no area, which is not supposed to arise');
      }
      adaptWeights(polygons2, flickeringMitigationRatio);
      adaptedMapPoints = polygons2.map((p) => {
        return p.site.originalObject;
      });
      polygons2 = weightedVoronoi$1(adaptedMapPoints);
      if (polygons2.length < siteCount) {
        throw new d3VoronoiMapError('at least 1 site has no area, which is not supposed to arise');
      }
      return polygons2;
    }
    function adaptPositions(polygons2, flickeringMitigationRatio) {
      let newMapPoints = []; var 
flickeringInfluence = 0.5;
      let flickeringMitigation2; var d; var polygon; var mapPoint; var centroid; var dx; var 
dy;
      flickeringMitigation2 = flickeringInfluence * flickeringMitigationRatio;
      d = 1 - flickeringMitigation2;
      for (let i = 0; i < siteCount; i++) {
        polygon = polygons2[i];
        mapPoint = polygon.site.originalObject;
        centroid = d3PolygonCentroid(polygon);
        dx = centroid[0] - mapPoint.x;
        dy = centroid[1] - mapPoint.y;
        dx *= d;
        dy *= d;
        mapPoint.x += dx;
        mapPoint.y += dy;
        newMapPoints.push(mapPoint);
      }
      handleOverweighted(newMapPoints);
    }
    function adaptWeights(polygons2, flickeringMitigationRatio) {
      let newMapPoints = []; var 
flickeringInfluence = 0.1;
      let flickeringMitigation2; var polygon; var mapPoint; var currentArea; var adaptRatio; var 
adaptedWeight;
      flickeringMitigation2 = flickeringInfluence * flickeringMitigationRatio;
      for (let i = 0; i < siteCount; i++) {
        polygon = polygons2[i];
        mapPoint = polygon.site.originalObject;
        currentArea = d3PolygonArea(polygon);
        adaptRatio = mapPoint.targetedArea / currentArea;
        adaptRatio = Math.max(adaptRatio, 1 - flickeringInfluence + flickeringMitigation2);
        adaptRatio = Math.min(adaptRatio, 1 + flickeringInfluence - flickeringMitigation2);
        adaptedWeight = mapPoint.weight * adaptRatio;
        adaptedWeight = Math.max(adaptedWeight, epsilon2);
        mapPoint.weight = adaptedWeight;
        newMapPoints.push(mapPoint);
      }
      handleOverweighted(newMapPoints);
    }
    function handleOverweighted0(mapPoints) {
      let fixCount = 0;
      let fixApplied; var tpi; var tpj; var weightest; var lightest; var sqrD; var 
adaptedWeight;
      do {
        if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {
          throw new d3VoronoiMapError('handleOverweighted0 is looping too much');
        }
        fixApplied = false;
        for (let i = 0; i < siteCount; i++) {
          tpi = mapPoints[i];
          for (let j = i + 1; j < siteCount; j++) {
            tpj = mapPoints[j];
            if (tpi.weight > tpj.weight) {
              weightest = tpi;
              lightest = tpj;
            } else {
              weightest = tpj;
              lightest = tpi;
            }
            sqrD = squaredDistance(tpi, tpj);
            if (sqrD < weightest.weight - lightest.weight) {
              adaptedWeight = sqrD + lightest.weight / 2;
              adaptedWeight = Math.max(adaptedWeight, epsilon2);
              weightest.weight = adaptedWeight;
              fixApplied = true;
              fixCount++;
              break;
            }
          }
          if (fixApplied) {
            break;
          }
        }
      } while (fixApplied);
    }
    function handleOverweighted1(mapPoints) {
      let fixCount = 0;
      let fixApplied; var tpi; var tpj; var weightest; var lightest; var sqrD; var 
overweight;
      do {
        if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {
          throw new d3VoronoiMapError('handleOverweighted1 is looping too much');
        }
        fixApplied = false;
        for (let i = 0; i < siteCount; i++) {
          tpi = mapPoints[i];
          for (let j = i + 1; j < siteCount; j++) {
            tpj = mapPoints[j];
            if (tpi.weight > tpj.weight) {
              weightest = tpi;
              lightest = tpj;
            } else {
              weightest = tpj;
              lightest = tpi;
            }
            sqrD = squaredDistance(tpi, tpj);
            if (sqrD < weightest.weight - lightest.weight) {
              overweight = weightest.weight - lightest.weight - sqrD;
              lightest.weight += overweight + epsilon2;
              fixApplied = true;
              fixCount++;
              break;
            }
          }
          if (fixApplied) {
            break;
          }
        }
      } while (fixApplied);
    }
    function computeAreaError(polygons2) {
      let areaErrorSum = 0;
      let polygon; var mapPoint; var 
currentArea;
      for (let i = 0; i < siteCount; i++) {
        polygon = polygons2[i];
        mapPoint = polygon.site.originalObject;
        currentArea = d3PolygonArea(polygon);
        areaErrorSum += Math.abs(mapPoint.targetedArea - currentArea);
      }
      return areaErrorSum;
    }
    function setHandleOverweighted() {
      switch (HANDLE_OVERWEIGHTED_VARIANT) {
        case 0:
          handleOverweighted = handleOverweighted0;
          break;
        case 1:
          handleOverweighted = handleOverweighted1;
          break;
        default:
          console.error("unknown 'handleOverweighted' variant; using variant #1");
          handleOverweighted = handleOverweighted0;
      }
    }
    return simulation;
  }
  function voronoiTreemap() {
    let DEFAULT_CONVERGENCE_RATIO = 0.01;
    let DEFAULT_MAX_ITERATION_COUNT = 50;
    let DEFAULT_MIN_WEIGHT_RATIO = 0.01;
    let DEFAULT_PRNG = Math.random;
    let clip = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
    ];
    let extent = [
      [0, 0],
      [1, 1],
    ];
    let size = [1, 1];
    let convergenceRatio = DEFAULT_CONVERGENCE_RATIO;
    let maxIterationCount = DEFAULT_MAX_ITERATION_COUNT;
    let minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO;
    let prng = DEFAULT_PRNG;
    let unrelevantButNeedeData = [
      {
        weight: 1,
      },
      {
        weight: 1,
      }
    ];
    let _convenientReusableVoronoiMapSimulation = voronoiMapSimulation(unrelevantButNeedeData).stop();
    function _voronoiTreemap(rootNode) {
      recurse(clip, rootNode);
    }
    _voronoiTreemap.convergenceRatio = function (_) {
      if (!arguments.length) {
        return convergenceRatio;
      }
      convergenceRatio = _;
      return _voronoiTreemap;
    };
    _voronoiTreemap.maxIterationCount = function (_) {
      if (!arguments.length) {
        return maxIterationCount;
      }
      maxIterationCount = _;
      return _voronoiTreemap;
    };
    _voronoiTreemap.minWeightRatio = function (_) {
      if (!arguments.length) {
        return minWeightRatio;
      }
      minWeightRatio = _;
      return _voronoiTreemap;
    };
    _voronoiTreemap.clip = function (_) {
      if (!arguments.length) {
        return clip;
      }
      _convenientReusableVoronoiMapSimulation.clip(_);
      clip = _convenientReusableVoronoiMapSimulation.clip();
      extent = _convenientReusableVoronoiMapSimulation.extent();
      size = _convenientReusableVoronoiMapSimulation.size();
      return _voronoiTreemap;
    };
    _voronoiTreemap.extent = function (_) {
      if (!arguments.length) {
        return extent;
      }
      _convenientReusableVoronoiMapSimulation.extent(_);
      clip = _convenientReusableVoronoiMapSimulation.clip();
      extent = _convenientReusableVoronoiMapSimulation.extent();
      size = _convenientReusableVoronoiMapSimulation.size();
      return _voronoiTreemap;
    };
    _voronoiTreemap.size = function (_) {
      if (!arguments.length) {
        return size;
      }
      _convenientReusableVoronoiMapSimulation.size(_);
      clip = _convenientReusableVoronoiMapSimulation.clip();
      extent = _convenientReusableVoronoiMapSimulation.extent();
      size = _convenientReusableVoronoiMapSimulation.size();
      return _voronoiTreemap;
    };
    _voronoiTreemap.prng = function (_) {
      if (!arguments.length) {
        return prng;
      }
      prng = _;
      return _voronoiTreemap;
    };
    function recurse(clippingPolygon, node) {
      let simulation;
      node.polygon = clippingPolygon;
      if (node.height != 0) {
        simulation = voronoiMapSimulation(node.children).clip(clippingPolygon).weight((d) => {
          return d.value;
        }).convergenceRatio(convergenceRatio)
.maxIterationCount(maxIterationCount)
.minWeightRatio(minWeightRatio)
.prng(prng)
.stop();
        let state = simulation.state();
        while (!state.ended) {
          simulation.tick();
          state = simulation.state();
        }
        state.polygons.forEach((cp) => {
          recurse(cp, cp.site.originalObject.data.originalData);
        });
      }
    }
    return _voronoiTreemap;
  }
  function createVoronoiTreemap(data, options, chartComponents) {
    const { svg } = chartComponents;
    const layout = voronoiTreemap().size([options.width, options.height]);
    const root = d3.hierarchy(data).sum((d) => d.value);
    layout(root);
    const cells = root.descendants().filter((d) => d.depth);
    const categoryColor = d3.scaleOrdinal(d3.schemeCategory10);
    const groups = svg.selectAll('g').data(cells).enter().append('g')
.attr('fill', (d) => {
      if (d.depth === 1) {
        return categoryColor(d.data.name);
      }
      if (d.depth === 2) {
        const parentCategory = d.parent.data.name;
        const parentColor = categoryColor(parentCategory);
        const interpolator = d3.interpolateRgbBasis([parentColor, 'white']);
        return interpolator(d.data.value / d.parent.value);
      }
    })
.attr('stroke', `${options.strokeColor}`)
.attr('font-size', `${options.parentTextSize}`);
    groups.append('path').attr('d', (d) => d3.line().curve(d3.curveLinearClosed)(d.polygon)).attr('opacity', 0.8).attr('stroke-width', `${options.strokeWidth}` || 1);
    groups.append('text').attr('x', (d) => d3.polygonCentroid(d.polygon)[0]).attr('y', (d) => d3.polygonCentroid(d.polygon)[1]).attr('text-anchor', `${options.textAnchor}}`)
.attr('dy', '.35em')
.text((d) => d.data.name)
.style('font-size', `${options.childTextSize}`)
.style('fill', 'white');
  }
  function createD3WaterfallChart(data, options, chartComponents) {
    const { x: x2 } = chartComponents;
    const { y: y2 } = chartComponents;
    const { svg } = chartComponents;
    svg.append('g').selectAll('rect').data(data).join('rect')
.attr('x', (d) => x2(d.category))
.attr('y', (d) => y2(d.start))
.attr('height', (d) => Math.abs(y2(d.end) - y2(d.start)))
.attr('width', x2.bandwidth())
.attr('fill', options.color);
  }
  function createWordCloud(data, options, chartComponents) {
    const { width, height, y2ForceStrength } = options;
    const fontSize = (d) => Math.sqrt(d.value) * 2;
    const { svg } = chartComponents;
    const radiusScale = d3.scaleSqrt().domain([0, d3.max(data, (d) => d.value)]).range([0, options.maxRadius]);
    const clusterStrengthVal = 5e-3;
    d3.forceSimulation(data).force('charge', d3.forceManyBody().strength(options.chargeStrength)).force('center', d3.forceCenter(width / 2, height / 2)).force('collision', d3.forceCollide().radius((d) => radiusScale(d.value) + 1))
.force('y2Force', y2Force(y2ForceStrength))
.force('clusterForce', clusterForce(clusterStrengthVal, data))
.on('tick', ticked);
    Array.from(new Set(data.map((d) => d.y2)));
    const colorScales = {
      0.2: d3.interpolatePlasma,
      0.5: d3.interpolateViridis,
      0.8: d3.interpolateInferno,
    };
    if (options.bubble) {
      svg.selectAll('circle').data(data).enter().append('circle')
.attr('r', (d) => radiusScale(d.value))
.style('fill', (d) => {
        if (d.y2 !== void 0) {
          console.log('COLOR SCALES', colorScales[d.y2], 'VALUE', d.v);
          return colorScales[d.y2](d.value / 1e3);
        }
        return d3.schemeCategory10[d.value % 10];
      })
.style('opacity', options.bubbleOpacity);
    }
    const labels = svg.selectAll('text').data(data).enter().append('text')
.attr('dy', '.35em')
.style('text-anchor', 'middle')
.style('font-size', (d) => `${fontSize(d)}px`)
.style('fill', 'black')
.text((d) => d.name);
    function ticked() {
      if (options.bubble) {
        svg.selectAll('circle').attr('cx', (d) => Math.max(radiusScale(d.value), Math.min(width - radiusScale(d.value), d.x))).attr('cy', (d) => Math.max(radiusScale(d.value), Math.min(height - radiusScale(d.value), d.y)));
      }
      labels.attr('x', (d) => Math.max(fontSize(d) / 2, Math.min(width - fontSize(d) / 2, d.x))).attr('y', (d) => Math.max(fontSize(d) / 2, Math.min(height - fontSize(d) / 2, d.y)));
    }
    function y2Force(strength) {
      return (alpha) => {
        data.forEach((d) => {
          if (d.y2 !== void 0) {
            const targetY = height * d.y2;
            d.vy += (targetY - d.value) * strength * alpha;
          }
        });
      };
    }
    function clusterForce(strength, data2) {
      return (alpha) => {
        data2.forEach((d) => {
          if (d.y2 !== void 0) {
            const targetBubbles = data2.filter((bubble) => bubble.y2 === d.y2);
            targetBubbles.forEach((target) => {
              if (target !== d) {
                const dx = d.x - target.x;
                const dy = d.y - target.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const desiredDistance = (radiusScale(d.value) + radiusScale(target.value)) * strength;
                if (distance < desiredDistance) {
                  const k = (distance - desiredDistance) / distance * alpha;
                  d.vx -= dx * k;
                  d.vy -= dy * k;
                  target.vx += dx * k;
                  target.vy += dy * k;
                }
              }
            });
          }
        });
      };
    }
  }
  class D3ChartTypes {
    constructor() {
      const types = {
        adjacency: {
          _selfKey: 'adjacency',
          name: 'Adjacency',
          nameLong: 'Adjacency Matrix',
          render: createAdjacencyMatrix,
        },
        area: {
          _selfKey: 'area',
          chartClass: 'area-chart',
          name: 'Area',
          nameLong: 'Area Chart',
          render: createD3AreaChart,
        },
        bar: {
          _selfKey: 'bar',
          chartClass: 'bar-chart',
          name: 'Bar',
          nameLong: 'Bar Chart',
          render: createD3BarChart,
        },
        box: {
          _selfKey: 'box',
          chartClass: 'box-plot',
          name: 'Box',
          nameLong: 'Box Plot',
          render: createD3BoxPlot,
        },
        bubble: {
          _selfKey: 'bubble',
          chartClass: 'bubble-chart',
          name: 'Bubble',
          nameLong: 'Bubble Chart',
          render: createBubbleChart,
        },
        chord: {
          _selfKey: 'chord',
          name: 'Chord',
          nameLong: 'Chord Diagram',
          render: createChordDiagram,
        },
        cloud: {
          _selfKey: 'cloud',
          name: 'Cloud',
          nameLong: 'Cloud Diagram',
          render: createWordCloud,
        },
        cluster: {
          _selfKey: 'cluster',
          name: 'Cluster',
          nameLong: 'Cluster Diagram',
          render: createClusterDiagram,
        },
        dendrogram: {
          _selfKey: 'dendrogram',
          name: 'Dendrogram',
          nameLong: 'Dendrogram Chart',
          render: createDendrogram,
        },
        donut: {
          _selfKey: 'donut',
          chartClass: 'donut-chart',
          name: 'Donut',
          nameLong: 'Donut Chart',
          render: createD3DonutChart,
        },
        funnel: {
          _selfKey: 'funnel',
          chartClass: 'funnel-chart',
          name: 'Funnel',
          nameLong: 'Funnel Chart',
          render: createD3FunnelChart,
        },
        gauge: {
          _selfKey: 'gauge',
          chartClass: 'gauge-chart',
          name: 'Gauge',
          nameLong: 'Gauge Chart',
          render: createD3GaugeChart,
        },
        heat: {
          // TODO note: was previously 'heat-map', verify if is now type-safe to use 'heat'
          _selfKey: 'heat',
          chartClass: 'heat-map',
          name: 'Heat',
          nameLong: 'Heat Map',
          render: createD3Heatmap,
        },
        icicle: {
          _selfKey: 'icicle',
          name: 'Icicle',
          nameLong: 'Icicle Plot',
          render: createIcicleChart,
        },
        line: {
          _selfKey: 'line',
          chartClass: 'line-graph',
          name: 'Line',
          nameLong: 'Line Graph',
          render: createD3LineGraph,
        },
        marimekko: {
          _selfKey: 'marimekko',
          name: 'Marimekko',
          nameLong: 'Marimekko Diagram',
          render: createMarimekkoChart,
        },
        pie: {
          _selfKey: 'pie',
          chartClass: 'pie-chart',
          name: 'Pie',
          nameLong: 'Pie Chart',
          render: createD3PieChart,
        },
        polar: {
          _selfKey: 'polar',
          chartClass: 'polar-chart',
          name: 'Polar',
          nameLong: 'Polar Chart',
          render: createD3PolarChart,
        },
        radar: {
          _selfKey: 'radar',
          chartClass: 'radar-chart',
          name: 'Radar',
          nameLong: 'Radar Chart',
          render: createD3RadarChart,
        },
        radialTree: {
          _selfKey: 'radialTree',
          name: 'Radial Tree',
          nameLong: 'Radial Tree Diagram',
          render: createRadialTree,
        },
        sankey: {
          _selfKey: 'sankey',
          name: 'Sankey',
          nameLong: 'Sankey Diagram',
          render: createSankeyDiagram,
        },
        scatter: {
          _selfKey: 'scatter',
          chartClass: 'scatter-plot',
          name: 'Scatter',
          nameLong: 'Scatter Plot',
          render: createD3ScatterPlot,
        },
        stackedbar: {
          _selfKey: 'stackedbar',
          chartClass: 'stacked-bar-chart-plot',
          // TODO match more closely with key
          name: 'Stacked Bar',
          nameLong: 'Stacked Bar Chart',
          render: createD3StackedBarChart,
        },
        sun: {
          _selfKey: 'sun',
          name: 'Sun Burst',
          nameLong: 'Sun Burst Diagram',
          render: createD3SunburstChart,
        },
        treeDiagram: {
          _selfKey: 'treeDiagram',
          name: 'Tree Diagram',
          nameLong: 'Tree Diagram',
          render: createTreeDiagram,
        },
        treeMap: {
          _selfKey: 'treeMap',
          name: 'Tree Map',
          nameLong: 'Tree Map',
          render: createD3TreeMap,
        },
        voronoi: {
          _selfKey: 'voronoi',
          name: 'Voronoi',
          nameLong: 'Voronoi Diagram',
          render: createVoronoiTreemap,
        },
        waterfall: {
          _selfKey: 'waterfall',
          chartClass: 'waterfall-chart',
          name: 'Waterfall',
          nameLong: 'Waterfall Chart',
          render: createD3WaterfallChart,
        }
      };
      Object.assign(this, types);
    }
  }
  const d3OptionShape = {
    _selfKey: 'string',
    barWidth: 'number',
    color: 'string',
    height: 'number',
    margin: {
      bottom: 'number',
      left: 'number',
      right: 'number',
      top: 'number'
    },
    // negativeColor: 'string', // WIP
    overlay: 'boolean',
    // positiveColor: 'string', // WIP
    width: 'number',
    xAxisColor: 'string',
    xAxisPosition: 'number',
    // xDomain: 'object', // WIP
    xLabelOffsetX: 'number',
    xLabelOffsetY: 'number',
    xLabelRotation: 'number',
    xTickExtension: 'number',
    xTickFrequency: 'number',
    xTickLength: 'number',
    xTickOpacity: 'number',
    yAxisColor: 'string',
    yAxisPosition: 'number',
    // yDomain: 'object', // WIP
    yLabelOffsetX: 'number',
    yLabelOffsetY: 'number',
    yLabelRotation: 'number',
    yTickExtension: 'number',
    yTickFrequency: 'number',
    yTickLength: 'number',
    yTickOpacity: 'number'
  };
  const validOptionShapeTypes = ['string', 'number', 'boolean'];
  function validateOptionShape(shape, input) {
    Object.keys(shape).forEach((key) => {
      if (typeof shape[key] === 'object') {
        validateOptionShape(shape[key], input[key]);
      } else {
        if (!validOptionShapeTypes.includes(shape[key])) {
          throw new Error(`Invalid type specified for ${key}`);
        }
        if (typeof input[key] !== shape[key]) {
          throw new Error(`${key} must be a ${shape[key]}`);
        }
      }
    });
  }
  const d3ChartTypes$1 = new D3ChartTypes();
  class D3Visualizer {
    constructor(chartArray, data, options, selector = '#chart') {
      this.chartArray = chartArray;
      this.data = data;
      this.options = options;
      this.selector = selector;
      validateOptionShape(d3OptionShape, this.options[0]);
      this.processCharts();
    }

    // addCharts(type) { // This method probably needs to be refactored
    //   this.chartArray.push(...type);
    //   for (let i = 0; i < type.length; i++) {
    //     this.createChart[type[i]](this.data, this.options, this.chartComponents);
    //     appendAxes(this.chartArray[i], this.options, this.chartComponents);
    //   }
    // }
    processCharts() {
      for (let i = 0; i < this.chartArray.length; i++) {
        this.options[i].chartClass = d3ChartTypes$1[this.chartArray[i]].chartClass;
        this.options[i].chartNumber = i;
        if (shouldCreateChartComponents.call(this, i) || this.options[0].isUpdating) {
          this.chartComponents = createChartComponents.call(this, i);
        }
        if (!this.options[0].isUpdating) {
          const { render } = d3ChartTypes$1[this.chartArray[i]];
          render(this.data[i], this.options[i], this.chartComponents);
        }
        applyOptions.call(this, i);
        applyActions.call(this, i);
      }
    }

    removeChart() {
      d3.select(this.selector).selectAll(`svg.${this.options[0].chartClass}`).remove();
      console.log('removed', this.options.chartClass);
    }

    updateInput(data, options, selector = '#chart') {
      this.options = options;
      if (options[0].animate) {
        this.options[0].isUpdating = true;
      }
      this.data = data;
      this.selector = selector;
      this.processCharts();
    }
  }
  function applyActions(i) {
    const options = this.options[i];
    if (!this.options[0].isUpdating) {
      const axisBBox = appendAxes(this.chartArray[i], options, this.chartComponents);
      this.chartComponents.xAxisBBox = axisBBox.xAxisBBox ? axisBBox.xAxisBBox : null;
      this.chartComponents.yAxisBBox = axisBBox.yAxisBBox ? axisBBox.yAxisBBox : null;
    }
    if (options.gradient) {
      addGradient(
        this.selector,
        this.chartArray[i],
        this.chartComponents,
        this.data[i],
        options
      );
    }
    if (options.onHover) {
      onHover(this.selector, this.options);
    }
    if (options.relativeNodeSize) {
      adjustNodeSize(this.selector, this.data[i], options);
    }
    if (options.animate && this.options[0].isUpdating) {
      addAnimation(
        this.selector,
        this.data[i],
        options,
        this.chartComponents,
        options.duration
      );
    }
  }
  function applyOptions(i) {
    const options = this.options[i];
    const { isUpdating } = this.options[0];
    const allElements = d3.selectAll(`svg.${options.chartClass} circle, arc, rect, path, line, polygon, node`);
    const excludedElements = d3.selectAll('.y-axis, .x-axis, .shape-label, .shape-pointer, .y-axis * , .x-axis *');
    const elements = allElements.filter(function () {
      const currentElement = d3.select(this);
      return !excludedElements.nodes().includes(currentElement.node());
    });
    elements.each(function () {
      const element = d3.select(this);
      const { classList } = this;
      if (classList.length === 0) {
        element.classed(`${options.chartClass}${i}`, true);
      }
      if (options.opacity && classList[0] === `${options.chartClass}${i}`) {
        element.style('opacity', options.opacity);
      }
      if (options.boxShadow) {
        element.style('filter', 'drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5))');
      }
      if (isUpdating) {
        elements.attr('fill', `${options.color}`);
        elements.attr('data-initialFill', `${options.color}`);
        console.log(options.color, i);
      }
    });
  }
  function createChartComponents(i) {
    const chartComponents = createAxes(this.data[i], this.chartArray[i], this.options[i]);
    if (!this.options[0].isUpdating) {
      chartComponents.svg = createSVG(this.selector, this.chartArray[i], this.options[i]);
    }
    return chartComponents;
  }
  function shouldCreateChartComponents(i) {
    const isFirstStackedChart = this.options[i].stack && i === 0;
    const isNotUpdating = !this.options[0].isUpdating;
    const isNotStackedChart = !this.options[i].stack;
    return isFirstStackedChart && isNotUpdating || isNotStackedChart && isNotUpdating;
  }
  class OomphInterface {
    constructor(interfaceType) {
      this.interface = interfaceType;
    }

    render() {
      console.log(`Rendering interface (placeholder): ${this.interface}`);
    }
  }
  const chartTypes$2 = new D3ChartTypes();
  const optionTypes = new D3OptionTypes();
  function createChartToOptionAssociations() {
    try {
      const associations = {
        [chartTypes$2.area._selfKey]: [
          optionTypes.options2._selfKey,
        ],
        [chartTypes$2.bar._selfKey]: [
          optionTypes.options5._selfKey,
        ],
        [chartTypes$2.box._selfKey]: [
          optionTypes.options3._selfKey,
        ],
        [chartTypes$2.bubble._selfKey]: [
          optionTypes.options10._selfKey,
        ],
        [chartTypes$2.donut._selfKey]: [
          optionTypes.options4._selfKey,
        ],
        [chartTypes$2.funnel._selfKey]: [
          optionTypes.funnelChart._selfKey,
        ],
        [chartTypes$2.gauge._selfKey]: [
          optionTypes.gauge._selfKey,
        ],
        [chartTypes$2.heat._selfKey]: [
          // TODO note: was previously 'heat-map', verify now type-safe to use 'heat'
          optionTypes.options3._selfKey,
        ],
        [chartTypes$2.line._selfKey]: [
          optionTypes.options9._selfKey,
        ],
        [chartTypes$2.pie._selfKey]: [
          optionTypes.options6._selfKey,
        ],
        [chartTypes$2.polar._selfKey]: [
          optionTypes.polarChart._selfKey,
        ],
        [chartTypes$2.radar._selfKey]: [
          optionTypes.radarChart._selfKey,
        ],
        [chartTypes$2.scatter._selfKey]: [
          optionTypes.options3._selfKey,
        ],
        [chartTypes$2.stackedbar._selfKey]: [
          optionTypes.options7._selfKey,
        ],
        [chartTypes$2.waterfall._selfKey]: [
          optionTypes.waterfall._selfKey,
        ]
      };
      return associations;
    } catch (error) {
      console.error(`Possible reference to non-existent chart or option type: ${error.message}`);
      return {};
    }
  }
  const chartToOptionAssociations = createChartToOptionAssociations();
  function getChartToOptionAssociations(charts) {
    if (!charts || charts.length === 0) {
      console.error('No charts provided.');
      return [];
    }
    try {
      const associations = /* @__PURE__ */ new Set();
      const associationsBuilder = [];
      const chartTypes2 = new D3ChartTypes();
      charts.forEach((chartType) => {
        if (!chartTypes2[chartType]) {throw new Error(`Invalid chart type: ${chartType}`);}
        if (!chartToOptionAssociations[chartType]) {throw new Error(`No chart-to-options associations found for: ${chartType}`);}
        associationsBuilder.push(...chartToOptionAssociations[chartType]);
      });
      associationsBuilder.forEach((association) => {
        associations.add(association);
      });
      return associationsBuilder[0] ? associationsBuilder[0] : '';
    } catch (error) {
      console.error(error.message);
      return /* @__PURE__ */ new Set();
    }
  }
  const d3ChartTypes = new D3ChartTypes();
  const d3OptionsTypes = new D3OptionTypes();
  class VisualizerTypes {
    constructor() {
      const types = {
        d3: {
          _selfKey: 'd3',
          name: 'D3',
          nameLong: 'D3 Visualizer',
          chartTypes: d3ChartTypes,
          optionTypes: d3OptionsTypes,
        }
      };
      Object.assign(this, types);
    }
  }
  const visualizerTypes$2 = new VisualizerTypes();
  function getCompatibleChartTypes(charts, visualizer) {
    const compatibleChartTypes = /* @__PURE__ */ new Set();
    charts.forEach((chart) => {
      if (visualizerTypes$2[visualizer].chartTypes[chart]) {compatibleChartTypes.add(chart);}
    });
    return compatibleChartTypes;
  }
  class InputTypes {
    constructor() {
      const types = {
        number_number: {
          _selfKey: 'number_number',
          name: 'Number Number',
          nameLong: 'Number Number Input',
          dataFormat: ['number', 'number'],
        },
        string_number: {
          _selfKey: 'string_number',
          name: 'String Number',
          nameLong: 'String Number Input',
          dataFormat: ['string', 'number'],
        },
        string_number_string: {
          _selfKey: 'string_number_string',
          name: 'String Number String',
          nameLong: 'String Number String Input',
          dataFormat: ['string', 'number', 'string'],
        }
      };
      Object.assign(this, types);
    }
  }
  function validateArrayHelper(inputArray, expectedTypes) {
    if (!Array.isArray(inputArray) || inputArray.length !== expectedTypes.length) {
      return false;
    }
    for (let i = 0; i < inputArray.length; i++) {
      if (!validateTypeHelper(inputArray[i], expectedTypes[i])) {
        return false;
      }
    }
    return true;
  }
  function validateObjectHelper(inputObject, expectedStructure) {
    if (typeof inputObject !== 'object' || inputObject === null || Array.isArray(inputObject)) {
      return false;
    }
    const inputKeys = Object.keys(inputObject);
    const expectedKeys = Object.keys(expectedStructure);
    if (inputKeys.length !== expectedKeys.length) {
      return false;
    }
    for (let i = 0; i < inputKeys.length; i++) {
      const key = inputKeys[i];
      if (!expectedKeys.includes(key) || !validateTypeHelper(inputObject[key], expectedStructure[key])) {
        return false;
      }
    }
    return true;
  }
  function validateTypeHelper(input, expectedType) {
    if (expectedType === 'date') {
      return input instanceof Date;
    }
    if (Array.isArray(expectedType)) {
      return validateArrayHelper(input, expectedType);
    }
    if (expectedType === 'object') {
      return validateObjectHelper(input, expectedType);
    }
    return typeof input === expectedType;
  }
  function getCompatibleInputTypes(userInput) {
    if (!userInput || !Array.isArray(userInput) || userInput.length === 0) {return [];}
    const compatibleInputTypes = /* @__PURE__ */ new Set();
    const inputTypes2 = new InputTypes();
    Object.keys(inputTypes2).forEach((inputType) => {
      if (isValidInput(userInput, inputTypes2[inputType].dataFormat)) {
        compatibleInputTypes.add(inputType);
      }
    });
    if (compatibleInputTypes.length === 0) {console.error("No valid input was found.");}
    return compatibleInputTypes;
  }
  function isValidInput(input, dataFormat) {
    const inputExcerpt = [input[0].x, input[0].y];
    if (Array.isArray(inputExcerpt)) {return validateArrayHelper(inputExcerpt, dataFormat);}
    if (typeof inputData === 'object') {return validateObjectHelper(inputExcerpt, dataFormat);}
    return false;
  }
  class TagTypes {
    constructor() {
      const types = {
        basic: {
          _selfKey: 'basic',
          name: 'Basic',
          nameLong: 'Basic Tag'
        },
        geographic: {
          _selfKey: 'geographic',
          name: 'Geographic',
          nameLong: 'Geographic Tag'
        },
        hierarchic: {
          _selfKey: 'hierarchic',
          name: 'Hierarchic',
          nameLong: 'Hierarchic Tag'
        },
      };
      Object.assign(this, types);
    }
  }
  const inputTypes = new InputTypes();
  const tagTypes$1 = new TagTypes();
  function createInputToTagAssociations() {
    try {
      const associations = {
        [inputTypes.number_number._selfKey]: [
          tagTypes$1.hierarchic._selfKey,
        ],
        [inputTypes.string_number._selfKey]: [
          tagTypes$1.basic._selfKey,
        ],
        [inputTypes.string_number_string._selfKey]: [
          tagTypes$1.hierarchic._selfKey,
        ]
      };
      return associations;
    } catch (error) {
      console.error(`Possible reference to non-existent input or tag type: ${error.message}`);
      return {};
    }
  }
  const inputToTagAssociations = createInputToTagAssociations();
  function getInputToTagAssociations(inputs) {
    if (!inputs || inputs.length === 0) {
      console.error('No inputs provided.');
    }
    try {
      const associations = /* @__PURE__ */ new Set();
      const associationsBuilder = [];
      const inputTypes2 = new InputTypes();
      inputs.forEach((inputType) => {
        if (!inputTypes2[inputType]) {throw new Error(`Invalid input type: ${inputType}`);}
        if (!inputToTagAssociations[inputType]) {throw new Error(`No input-to-tag associations found for: ${inputType}`);}
        associationsBuilder.push(...inputToTagAssociations[inputType]);
      });
      associationsBuilder.forEach((association) => {
        associations.add(association);
      });
      return associations;
    } catch (error) {
      console.error(error.message);
      return /* @__PURE__ */ new Set();
    }
  }
  const chartTypes$1 = new ChartTypes();
  const tagTypes = new TagTypes();
  function createTagToChartAssociations() {
    try {
      const associations = {
        [tagTypes.basic._selfKey]: [
          chartTypes$1.area._selfKey,
          chartTypes$1.bar._selfKey,
          chartTypes$1.box._selfKey,
          chartTypes$1.donut._selfKey,
          chartTypes$1.funnel._selfKey,
          chartTypes$1.gauge._selfKey,
          chartTypes$1.heat._selfKey,
          chartTypes$1.line._selfKey,
          chartTypes$1.pie._selfKey,
          chartTypes$1.polar._selfKey,
          chartTypes$1.radar._selfKey,
          chartTypes$1.scatter._selfKey,
          chartTypes$1.stackedBar._selfKey,
          chartTypes$1.waterfall._selfKey,
        ],
        [tagTypes.hierarchic._selfKey]: [
          chartTypes$1.adjacency._selfKey,
          chartTypes$1.chord._selfKey,
          chartTypes$1.cloud._selfKey,
          chartTypes$1.cluster._selfKey,
          chartTypes$1.dendrogram._selfKey,
          chartTypes$1.icicle._selfKey,
          chartTypes$1.marimekko._selfKey,
          chartTypes$1.radialTree._selfKey,
          chartTypes$1.sankey._selfKey,
          chartTypes$1.sun._selfKey,
          chartTypes$1.treeDiagram._selfKey,
          chartTypes$1.treeMap._selfKey,
          chartTypes$1.voronoi._selfKey,
        ]
      };
      return associations;
    } catch (error) {
      console.error(`Possible reference to non-existent tag or chart type: ${error.message}`);
      return {};
    }
  }
  const tagToChartAssociations = createTagToChartAssociations();
  function getTagToChartAssociations(tags) {
    if (!tags || tags.length === 0) {
      console.error('No tags provided.');
      return [];
    }
    try {
      const associations = /* @__PURE__ */ new Set();
      const associationsBuilder = [];
      const tagTypes2 = new TagTypes();
      tags.forEach((tagType) => {
        if (!tagTypes2[tagType]) {throw new Error(`Invalid tag type: ${tagType}`);}
        if (!tagToChartAssociations[tagType]) {throw new Error(`No tag-to-chart associations found for: ${tagType}`);}
        associationsBuilder.push(...tagToChartAssociations[tagType]);
      });
      associationsBuilder.forEach((association) => {
        associations.add(association);
      });
      return associations;
    } catch (error) {
      console.error(error.message);
      return /* @__PURE__ */ new Set();
    }
  }
  const chartTypes = new ChartTypes();
  const visualizerTypes$1 = new VisualizerTypes();
  function hasValidRenderVisualizerArguments(obj, chartType) {
    if (!chartType || chartType.length === 0 || !chartTypes[chartType]) {
      console.error('Invalid chart type provided.');
      return false;
    }
    if (!obj.charts.has(chartType)) {
      console.error(`${visualizerTypes$1[obj.visualizer].name} visualizer does not support '${chartType}' chart type.`);
      return false;
    }
    if (!obj.chartsEligible.has(chartType)) {
      console.error(`Instantiated object does not support '${chartType}' chart type.`);
      return false;
    }
    if (!obj.visualizer || obj.visualizer.length === 0 || !visualizerTypes$1[obj.visualizer]) {
      console.error('Invalid visualizer provided.');
      return false;
    }
    if (!obj.data) {
      console.error('Invalid data detected.');
      return false;
    }
    if (obj.data.length === 0) {
      console.warn('There are no data points to draw.');
    }
    console.log(`Drawing a ${chartTypes[chartType].nameLong} with ${obj.data.length} data point(s) using ${visualizerTypes$1[obj.visualizer].name}.`);
    return true;
  }
  class InterfaceTypes {
    constructor() {
      const types = {
        default: {
          _selfKey: 'default',
          name: 'Default',
          nameLong: 'Default Interface'
        },
      };
      Object.assign(this, types);
    }
  }
  const interfaceTypes = new InterfaceTypes();
  function verifyInterface(iface) {
    if (!iface || iface.length === 0 || !interfaceTypes[iface]) {
      console.error(`Unsupported interface: ${iface}`);
      return '';
    }
    return interfaceTypes[iface]._selfKey;
  }
  const visualizerTypes = new VisualizerTypes();
  function verifyVisualizer(visualizer) {
    if (!visualizer || visualizer.length === 0 || !visualizerTypes[visualizer]) {
      console.error(`Unsupported visualizer: ${visualizer}`);
      return '';
    }
    return visualizerTypes[visualizer]._selfKey;
  }
  class OomphChart {
    constructor(exportObj = {}, inputData2 = null, visualizer = 'd3', iface = 'default') {
      if (inputData2) {
        this.data = inputData2;
        this.inputs = getCompatibleInputTypes(this.data);
        this.tags = getInputToTagAssociations(this.inputs);
        this.chartsEligible = getTagToChartAssociations(this.tags);
        this.visualizer = verifyVisualizer(visualizer);
        this.charts = getCompatibleChartTypes(this.chartsEligible, this.visualizer);
        this.interface = verifyInterface(iface);
      } else {
        this.exportObjMethod(exportObj);
      }
    }

    render(chartType, interfaceType = this.interface) {
      this.renderInterface(interfaceType);
      this.renderVisualizer(chartType);
    }

    renderInterface() {
      const oomphInterface = new OomphInterface(this.interface);
      oomphInterface.render();
    }

    renderVisualizer(chartType) {
      if (hasValidRenderVisualizerArguments(this, chartType)) {
        const chartTypes2 = new ChartTypes();
        const optionTypes2 = new D3OptionTypes();
        const tempSingleOption = getChartToOptionAssociations([chartType]);
        const charts = chartTypes2[chartType]._selfKey;
        const options = optionTypes2[tempSingleOption];
        new D3Visualizer([charts], [this.data], [options]);
      } else {console.error("Could not render visualizer due to invalid arguments.");}
    }

    exportObjMethod(obj) {
      obj = this;
      return obj;
    }
  }
  new OomphChart();
  //   // Higher-order factory function
  //   const factoryFunction = function(obj) {
  //     // Assign original class definition to obj
  //     obj.OomphChart = OomphChart;

  //     return obj;
  // };

  // return factoryFunction;
});
